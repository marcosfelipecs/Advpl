#INCLUDE "MATA250.CH" //MARCOS
#INCLUDE "PROTHEUS.CH"
#DEFINE DS_MODALFRAME 128
#DEFINE USADO CHR(0)+CHR(0)+CHR(1)
STATIC __l250FLD
Static _lNewMRP     := Nil

Static __lAutomacao := IsInCallStack("MAT250_045")
/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё MATA250  Ё Autor Ё Eveli Morasco         Ё Data Ё 06/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa para digitacao das producoes.                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function Mata250(xRotAuto, nOpc,lDigAuto)

	Local aCores := A240aCores()
	Local lPyme  := IIf(Type("__lPyme") <> "U",__lPyme,.F.)
	Local uX, nI
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Define Variaveis para filtrar browse                         Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local cFiltraSD3 := ""
	Local lContinua	 := .T.
	Local aRotAdic
	Local nPos

	Private lTranWMS:= .T.
	Private aNeed 		:= {}
	Private lDelOpSC 	:= GetMV("MV_DELOPSC")== "S"
	Private aRotAuto    := Nil
	Private lPerdInf    := SuperGetMV("MV_PERDINF",.F.,.F.)
	Private nFCICalc    := SuperGetMV("MV_FCICALC",.F.,0)
	PRIVATE aCtbDia	    := {}
	Private lExistePM   := .F. //Indica se existe produГЦo a maior para permitir requisitar quando o empenho estiver zerado
	Private lProc113    := .F.
	Private aArray113
	Private aAtuSD3  := {}  //Array p/ Atualizacao do campo D3_DTLANC
	Private lLoteACD := SuperGetMV("MV_INTACD",.F.,"0") == "1" .And.;
	IsInCallStack("ACDV020") .And. ;
	ValType(xRotAuto) == "A" .And. ;
	Len(xRotAuto) >= 8 .And.;
	aScan(xRotAuto[8],"D3_LOTECTL") > 0 .And. ;
	!Empty(xRotAuto[8,2])

	Private lAptEmp650 := NIL
	Private lAtuEmpExe := .F.
	Private lctbLote	:= SuperGetMV("MV_PCPCTLT",.F.,.T.) // Parametro que defini se a contabilizacao sera em lote ou individual. padrao lote .T.
    Private aClonexRota := aClone(xRotAuto) // Copiar array para rotina Pendente.

	Private aProdAuto := {}
	Private aEmpSaldo := {}
	Private aEmpQtNec := {}
	Private lPrdProp   := .F.
	Private lReabreOp  := .F.
	Private lValReabr  := .F.

	Private lRetBen     := .F.
	Private cChaveF1    := ""
	Private nPosDValid as numeric	

	Private aIndAuto    := {}  

	nPos := aScan(xRotAuto,{|x| x[1] == "ATUEMP"})
	If ( nPos > 0 .AND. xRotAuto[nPos,2] == "T" )
		lAtuEmpExe :=.T.
	Else
		lAtuEmpExe :=.F.
	EndIf

	nPos := aScan(xRotAuto,{|x| x[1] == "APTEMP"})
	If nPos > 0
		lAptEmp650 := xRotAuto[nPos,2]
	EndIf

	nPos := aScan(xRotAuto,{|x| x[1] == "RETBEN"})
	If ( nPos > 0 .And. xRotAuto[nPos,2] == "T" )
		lRetBen := .T.
		nPos := aScan(xRotAuto,{|x| x[1] == "D3_CHAVEF1"})
		If nPos > 0
			cChaveF1 := xRotAuto[nPos,2]
		EndIf
	EndIf

	If xRotAuto <> Nil
		aRotAuto := xRotAuto
		nOpc := If(aRotAuto == Nil, Nil, If(nOpc == Nil, 3, nOpc))
	Endif

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a permissao do programa em relacao aos modulos      Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If AMIIn(4,10,25,97,98,44)
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Variaveis utilizadas no sistema.                             Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private lProdAut := GetMv("MV_PRODAUT")

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Variaveis utilizadas no Apontamento de Refugo por Motivo     Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private lSavePerda	:= .F.
		Private lEnvCQProd 	:= .F.
		Private aPerda  	:= {}
		Private aHdPerda 	:= {}
		Private nPosQuant,nPosMot,nPosDesc,nPosTipo,nPosCod,nPosLoc,nPosLote

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Pega a variavel que identifica se o calculo do custo e' :    Ё
		//Ё               O = On-Line                                    Ё
		//Ё               M = Mensal                                     Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private cCusMed 	:= GetMv("mv_CusMed")
		Private lDigAutoAux := lDigAuto
		Private l250Auto 	:= ( aRotAuto <> Nil )
		Private l240Auto 	:= .F.

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Variavel utilizada para Integracao com Quality - Processos  	Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private lIntQual	:=.F.

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o custo medio e' calculado On-Line               Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If cCusMed == "O"

			Private nHdlPrv 			// Endereco do arquivo de contra prova dos lanctos cont.

			Private cLoteEst 			// Numero do lote para lancamentos do estoque

			Private lCriaHeader := .T. // Para criar o header do arquivo Contra Prova

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Posiciona numero do Lote para Lancamentos do Faturamento     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea("SX5")
			dbSeek(xFilial("SX5")+"09EST")
			cLoteEst:=IIF(Found(),Trim(X5Descri()),"EST ")

			Private nTotal		:= 0	// Total dos lancamentos contabeis

			Private cArquivo			// Nome do arquivo contra prova

		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Esta variavel indica se utiliza segunda unidade de medida    Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private lUsaSegUm

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Estas variaveis indicam para as funcoes de validacao qual    Ё
		//Ё programa as esta' chamando                                   Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private l240:=.F.,l250 :=.T.,l241:=.F.,l242:=.F.,l261:=.F.,l185:=.F.,l650:=.F.,l680:=.F.,l681:=.F.

		Private dDataFec:= MVUlmes()

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Define Array contendo as Rotinas a executar do programa      Ё
		//Ё ----------- Elementos contidos por dimensao ------------     Ё
		//Ё 1. Nome a aparecer no cabecalho                              Ё
		//Ё 2. Nome da Rotina associada                                  Ё
		//Ё 3. Usado pela rotina                                         Ё
		//Ё 4. Tipo de Transa┤└o a ser efetuada                          Ё
		//Ё    1 - Pesquisa e Posiciona em um Banco de Dados             Ё
		//Ё    2 - Simplesmente Mostra os Campos                         Ё
		//Ё    3 - Inclui registros no Bancos de Dados                   Ё
		//Ё    4 - Altera o registro corrente                            Ё
		//Ё    5 - Estorna registro selecionado gerando devolucoes       Ё
		//Ё        automaticas                                           Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private aRotina := MenuDef()

		// Caso possua as colunas para as informacoes de associacao de lote inclui a opcao
		AADD(aRotina,{STR0079,"A250Assoc", 0 , 2})    		//"Assoc. Lote"

		AADD(aRotina,{OemToAnsi(STR0078),"A240Legenda",0,2}) 	//"Legenda"

		If l250Auto .And. nOpc == 6
			aEval(aRotina, {|z,w| aRotina[w, 4] := 2})
			aRotina[5, 4] := 5
			nOpc := 5
		EndIf

		If l250Auto
			//ProteГЦo para nЦo ocorrer ErrorLog no ExecAuto
			//No ExecAuto nЦo existe acols da tela de lotes
			nPosDValid := ''
		endif

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё P.E. Utilizado para adicionar botoes ao Menu Principal       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If !l250Auto .And. ExistBlock("MT250MNU")
			aRotAdic := ExecBlock("MT250MNU",.F.,.F.)
			If ValType(aRotAdic) == "A"
				AEval(aRotAdic,{|x| AAdd(aRotina,x)})
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se trabalha com segunda unidade de medida           Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		lUsaSegUm := .T.
		dbSelectArea("SX3")
		dbSetOrder(2)
		dbSeek("B1_SEGUM")
		If !X3USO(X3_USADO)
			dbSeek("B2_QTSEGUM")
			If !X3USO(X3_USADO)
				lUsaSegUm := .F.
			EndIf
		EndIf
		dbSetOrder(1)

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Array contendo os campos aceitos no MATXATU                  Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private aAcho:={}

		AADD(aAcho,"D3_TM"		)
		AADD(aAcho,"D3_OP"		)
		AADD(aAcho,"D3_COD"		)
		AADD(aAcho,"D3_QUANT"	)
		AADD(aAcho,"D3_UM"		)
		If lUsaSegUm
			AADD(aAcho,"D3_QTSEGUM"	)
			AADD(aAcho,"D3_SEGUM"	)
		EndIf
		AADD(aAcho,"D3_PARCTOT"	)
		AADD(aAcho,"D3_LOCAL"	)
		AADD(aAcho,"D3_CC"		)
		AADD(aAcho,"D3_CONTA"	)
		AADD(aAcho,"D3_EMISSAO"	)
		AADD(aAcho,"D3_DOC"		)
		If SD3->(FieldPos("D3_FORNDOC")) > 0
			AADD(aAcho,"D3_FORNDOC"	)
			AADD(aAcho,"D3_LOJADOC"	)
		EndIf
		AADD(aAcho,"D3_PERDA"	)
		AADD(aAcho,"D3_DESCRI"	)

		If !lProdaut
			AADD(aAcho,"D3_LOTECTL")
			AADD(aAcho,"D3_DTVALID")
			AADD(aAcho,"D3_POTENCI")
		EndIf

		//здддддддддддддддддд©
		//Ё Portaria CAT83   |
		//юдддддддддддддддддды
		If V240CAT83()
			aaDD(aAcho,"D3_CODLAN")
		EndIf

		//здддддддддддддддддд©
		//Ё Percentual FCI   |
		//юдддддддддддддддддды
		If nFCICalc == 1
			aaDD(aAcho,"D3_PERIMP")
		EndIf

		//зддддддддддддддддддддддддддддддддддддддд©
		//Ё Trata campos  - Diario    		      Ё
		//юддддддддддддддддддддддддддддддддддддддды
		If ( UsaSeqCor() )
			AADD(aAcho,"D3_NODIA")
		EndIf

		If IntWms()
			AADD(aAcho, 'D3_SERVIC')
		EndIf

		If __l250FLD == NIL
			__l250FLD := ExistBlock("A250FLDS")
		EndIf
		If __l250FLD
			uX := ExecBlock("A250FLDS",.F.,.F.)
			If ValType(uX) == "C"
				AADD(aAcho,uX)
			ElseIf ValType(uX) == "A"
				For ni:=1 To Len(uX)
					AADD(aAcho,uX[ni])
				Next
			EndIf
		EndIf

		dbSelectArea("SX3")
		dbSeek("SD3")
		While !EOF() .And. (X3_ARQUIVO == "SD3")
			If X3USO(X3_USADO) .And. cNivel >= X3_NIVEL .And. (ASCAN(aAcho,Trim(X3_CAMPO)) == 0) .And. X3_PROPRI == "U"
				AADD(aAcho,TRIM(X3_CAMPO))
			EndIf
			dbSkip()
		EndDo

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Define o cabecalho da tela de atualizacoes                   Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Private cCadastro := STR0006  //"Produ┤■es"

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё mv_par01 - Se mostra e permite digitar lancamentos contabeis   Ё
		//Ё mv_par02 - Se deve aglutinar os lancamentos contabeis          Ё
		//Ё mv_par03 - Encerra todos os Itens da Grade                     Ё
		//Ё mv_par04 - Estorna todos os Itens da Grade                     Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Pergunte("MTA250",.F.)

		If l250Auto
			Private aHeader	  := {}
			Private acols     := {}
			Private lGrade    := MaGrade()
			Private cLocCQOrig:= ""
			Private lProdTotal:= .F.
			If IsAtNewGrd()
				Private oGrade  := MsMatGrade():New('oGrade',,"D3_QUANT",,"aVldGrade('A250')",,	{	{"D3_QUANT"		,Nil,{	{"D3_QTSEGUM"	,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) } }} }, ;
				{"D3_QTSEGUM"	,Nil,{	{"D3_QUANT"		,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) } }} }, ;
				{"D3_PARCTOT"	,Nil,Nil},;
				{"D3_PERDA"		,Nil,Nil};
				})
				oGrade:lShowGrd := .F.
			Else
				Private aColsGrade:= {}
				Private aHeadGrade:= {}
				Private aColsPT   := {}
				Private aQtdPerda := {}
			EndIf
			nPos := aScan(aRotAuto,{|x| x[1] == "AUTPRTOTAL"})
			If ( nPos > 0 .and. aRotAuto[nPos,2] == "S" )
				lProdTotal:=.T.
			Else
				lProdTotal:=.F.
			EndIf

			lEstornoAut := .F.

			If nOpc == 7
				lEstornoAut := .T.
			EndIf

			If nOpc == 5
				SeekAuto("SD3",aRotAuto)
			EndIf

			If MBrowseAuto(nOpc,aRotAuto,"SD3",if (lEstornoAut,.T.,.F.))
				lContinua := .F.
			EndIf
		Else

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ativa tecla F12 para acionar perguntas                         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			Set Key VK_F12 To MTA250PERG()

			If ExistBlock( "M250FIL" )
				cFiltraSD3	:= ExecBlock( "M250FIL", .F., .F. )
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Endereca a funcao de BROWSE                                  Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			mBrowse( 6, 1,22,75,"SD3",,,,,,aCores,,,,,,,,,,,,cFiltraSD3)

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁRestaura a condicao de Entrada                                          Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea("SD3")
			dbSetOrder(1)
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Desativa tecla que aciona perguntas                            Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			Set Key VK_F12 To
		EndIf
		If lContinua
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Fecha arquivo de controle de geracao de OPs intermediarias     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			A650CloseBatch()
		EndIf
	EndIf
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250VisualЁ Autor Ё Eveli Morasco         Ё Data Ё 06/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa para visualizar as digitacoes das producoes       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250Visual(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Visual(cAlias,nReg,nOpc)
	Local aAcho:={}, uX, nI
	AADD(aAcho,"D3_TM"		)
	AADD(aAcho,"D3_OP"		)
	AADD(aAcho,"D3_COD"	 	)
	AADD(aAcho,"D3_QUANT"	)
	AADD(aAcho,"D3_UM"		)
	If lUsaSegUm
		AADD(aAcho,"D3_QTSEGUM"	)
		AADD(aAcho,"D3_SEGUM"	)
	EndIf
	AADD(aAcho,"D3_PARCTOT"	)
	AADD(aAcho,"D3_LOCAL"	)
	AADD(aAcho,"D3_CC"		)
	AADD(aAcho,"D3_CONTA"	)
	AADD(aAcho,"D3_EMISSAO"	)
	AADD(aAcho,"D3_DOC"		)
	If SD3->(FieldPos("D3_FORNDOC")) > 0
		AADD(aAcho,"D3_FORNDOC"	)
		AADD(aAcho,"D3_LOJADOC"	)
	EndIf
	AADD(aAcho,"D3_ESTORNO"	)
	AADD(aAcho,"D3_PERDA"	)
	If IntWms()
		AADD(aAcho, 'D3_SERVIC')
	EndIf

	//здддддддддддддддддд©
	//Ё Portaria CAT83   |
	//юдддддддддддддддддды
	If V240CAT83()
		aaDD(aAcho,"D3_CODLAN")
	EndIf

	//здддддддддддддддддд©
	//Ё Percentual FCI   |
	//юдддддддддддддддддды
	If nFCICalc == 1
		aaDD(aAcho,"D3_PERIMP")
	EndIf

	AADD(aAcho,"D3_LOTECTL"	)
	AADD(aAcho,"D3_DTVALID"	)

	If __l250FLD == NIL
		__l250FLD := ExistBlock("A250FLDS")
	EndIf

	If __l250FLD
		uX := ExecBlock("A250FLDS",.F.,.F.)
		If ValType(uX) == "C"
			AADD(aAcho,uX)
		ElseIf ValType(uX) == "A"
			For ni:=1 To Len(uX)
				AADD(aAcho,uX[ni])
			Next
		EndIf
	EndIf

	dbSelectArea( cAlias )
	If Subs(D3_CF,1,2) != "ER" .And. Subs(D3_CF,1,2) != "PR"
		Help(" ",1,"A250NAO")
	Else
		AxVisual(cAlias,nReg,nOpc,aAcho)
	EndIf
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250IncluiЁ Autor Ё Eveli Morasco         Ё Data Ё 06/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa para inclusao de producoes                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250Inclui(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Inclui(cAlias,nReg,nOpc)
	Local nOpca    := 0
	Local lRet     := .T.
	Local aButtons := NIL // Utilizado para incluir botoes atraves de EXECBLOCK
	Local nX 	   := 0
	Local nPosGrv  := 0
	Local aAreaSD3 := {}
	Local cMsgErro := ""
	Private cPcpPend := '1'

	PRIVATE aHeader	  := {}
	PRIVATE acols     := {}
	PRIVATE lGrade    := MaGrade()
	PRIVATE cLocCQOrig:= ""
	DEFAULT lTranWMS:= .T.

	If Type('N')=='U'
		Private N := 1
	EndIf

	If Type("aIndAuto") == "U"
		Private aIndAuto := {}  
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Cria Ambiente/Objeto para tratamento de grade        Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If IsAtNewGrd()
		//MsMatGrade():New(cObj,cProdRef,cCpo,cTudoOk,cVldCpoGrd,aSetKey,aCposCtrlGrd,lShowGrd)
		PRIVATE oGrade	  := MsMatGrade():New('oGrade',,"D3_QUANT",,"aVldGrade('A250')",, ;
		{	{"D3_QUANT"		,NIL,{	{"D3_QTSEGUM"	,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) } }} }, ;
			{"D3_QTSEGUM"	,NIL,{	{"D3_QUANT"		,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) } }} },;
			{"D3_PARCTOT"	,NIL,NIL},;
			{"D3_PERDA"		,NIL,NIL};
			})
	Else
		PRIVATE aColsGrade:= {}
		PRIVATE aHeadGrade:= {}
		PRIVATE aColsPT   := {}
		PRIVATE aQtdPerda := {}
	EndIf

	Private cA240End := CriaVar('DB_LOCALIZ')

	IF l250Auto
		Private oError      := NIL
		Private bError      := {|e| oError := e, Break(e)}
		Private bErrorBlock := ErrorBlock( bError )
	ENDIF

	Default aProdAuto := {}
	Default aEmpSaldo := {}
	Default aEmpQtNec := {}

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Executa ponto de entrada para montar array com botoes a      Ё
	//Ё serem apresentados na tela                                   Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If (ExistBlock("M250BUT"))
		aButtons:=ExecBlock("M250BUT",.F.,.F.,{nOpc})
		If ValType(aButtons) # "A"
			aButtons:=NIL
		EndIf
	EndIf

	fRetPrdAut(' ', 'S')
	fRetParPrd(' ', 'S')
	
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verificar data do ultimo fechamento em SX6.                  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If dDataFec >= dDataBase
		Help ( " ", 1, "FECHTO" )
		lRet := .F.
	EndIf

	If lRet
		dbSelectArea("SF5")
		Set Filter To F5_TIPO == "P"
		dbGoTop()
		dbSelectArea(cAlias)

		If ( ! l250Auto )
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ativa tecla F4 para consultar OPs apenas deste produto.      Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			Set Key VK_F4 TO A250ShowF4()
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Inicializa a gravacao dos lancamentos do SIGAPCO          Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		PcoIniLan("000152")

		if TableInDic("T4K")
			nPosRotOr := aScan(aRotAuto,{|x| x[1] == "PENDENTE"})
			if nPosRotOr > 0
				cPCPPEND  :=  cValtoChar(aRotAuto[nPosRotOr][2])
			endif
		endif

        IF  cPCPPEND == "3"
            aAdd(aRotAuto,{"GRAVA","3",NIL})
        Else
            Begin transaction

				aProdAuto := {}
				aEmpSaldo := {}
				aEmpQtNec := {}
				aIndAuto  := {}

				lTranWMS:= .T.
                nOpca := AxInclui(cAlias,nReg,nOpc,aAcho,/*cFunc*/,/*aCpos*/,"A250TudoOk()",/*lF3*/,'a250GravD3()',aButtons,/*aParam*/,aRotAuto,/*lVirtual*/)

                IF l250Auto .AND. ValType(oError) != "U"
					DisarmTransaction()
					Help(NIL, NIL, STR0135, NIL, oError:Description + cValToChar(oError:ErrorStack), 1, 0, NIL, NIL, NIL, NIL, NIL, {cValToChar(oError:ErrorStack)}) //AJUDA
				ENDIF

                if nOpca = 0
                    aAdd(aRotAuto,{"GRAVA","4",NIL})
                Endif

                nPosGrv:= aScan(aRotAuto,{|x| x[1] == "GRAVA"})

                IF l250Auto .AND. cPcpPend <> '1' .AND. nPosGrv>0
                    disarmTransaction()
                    Break
                EndIf
				If !lTranWMS 
					DisarmTransaction()
				Endif
            end transaction 

        EndIf

        If nPosGrv = 0
		    nPosGrv:= aScan(aRotAuto,{|x| x[1] == "GRAVA"})
        Endif

		IF l250Auto .AND. cPcpPend <> '1' .AND. nPosGrv>0 //grava as pendЙncias de apontamento para serem processadas posteriormente

			lMsErroAuto := .T.

			IF nPosGrv > 0
				IF aRotAuto[nPosGrv,2] == "2"
					AutoGrLog(STR0130) //"O Registro do arquivo SB2 encontra-se Bloqueado por outro UsuАrio!! "
				ENDIF
			ENDIF

			IF cPcpPend == "3" // Todos apontamentos entram como pendentes
				cMsgErro	:=  STR0131 //"Parametro MV_APTPEND =  3 - Grava todos apontamentos como pendentes	"
				AutoGrLog(STR0131)
			Endif


            IF cPCPPEND # "4" //Reprocessamento
                IF FindFunction("ErrosApt")
                    IF cPcpPend # "3"
                        cMsgErro	:= ErrosApt()
                    ENDIF
                EndIF
        	    a250GrvPnd(aClonexRota,"MATA250", cMsgErro )
            ENDIF

        endif

		//APONTAMENTO POR PRODUTO
		If lProc113 .And. !l250Auto
			lProc113 := .F.
			If FindFunction("A113DelSD3")
				lRet := A113DelSD3()
			EndIf
			Return
		Else
			If FindFunction("A113SetD3")
				A113SetD3(SD3->D3_NUMSEQ)
			EndIf
		Endif

		If nOpca == 1

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se existe integracao com o QIP no apontamento das Producoes Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If SuperGetMV("MV_QIPMAT",.F.,"N") == "S" .And. SuperGetMV("MV_QIPOPEP",.F.,"2") == '3' .And. IntQIP(SD3->D3_COD,"2")
				QIPAtualiza("SD3",1)
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё  Processa Gatilhos                                   Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
			EvalTrigger()

			//-- Integrado ao wms devera avaliar as regras para convocacao do servico e disponibilizar os
			//-- registros do SDB para convocacao, ou exibir as mensagens de erro WMS caso necessАrio
			If IntWms()
				WmsExeServ()
			EndIf
			// Executa P.E. apos gravacao total dos movimentos
			If ExistBlock("A250ETRAN")
				ExecBlock("A250ETRAN",.F.,.F.)
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Desativa a tecla F4.                                         Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Set Key VK_F4 To

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Processa quando nao confirma movimento                       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		IF lctbLote
			If !(nOpca == 1) .Or. l250Auto
				A250Comum(aCtbDia)
			EndIf
		Endif

		aPerda		:={}
		aHdPerda	:={}
		lSavePerda	:=.F.
		dbSelectArea("SF5")
		dbClearFilter()
		dbGoTop()

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Finaliza a gravacao dos lancamentos do SIGAPCO            Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		PcoFinLan("000152")
	EndIf
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250EstornЁ Autor Ё Eveli Morasco         Ё Data Ё 07/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de exclusao de Produtos                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250Estorn(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Estorn(cAlias,nReg,nOpc)
	/*
	VariАvel nRegSD3 И utilizada para posicionar no registro correto, quando for realizar o estorno.
	Quando И executado o estorno atravИs de rotina automАtica, a funГЦo MsRotAuto pode desposicionar
	do registro da SD3. Utilizado para integraГЦo TOTVS MES.
	*/
	Local lReposic   := Iif(Type("nRegSD3")=="N" .And. nRegSD3 > 0, SD3->(dbGoTo(nRegSD3)), .F.)
	Local aButtons := NIL // Utilizado para incluir botoes atraves de EXECBLOCK
	Local nOpca,lDigita,lAglutina
	Local aAC := { OemToAnsi(STR0007),OemToAnsi(STR0008)}   //"Abandona"###"Confirma"
	Local cIdent
	Local nRec,aRecSD3
	Local cSeekSB8   :="",cComparaSB8:=""
	Local nSaldoSB8  :=0,nQuantSDA:=0
	Local cItemGrd   := ''
	Local cCF		 := ''
	Local lAborta    := .F.
	Local nSB2Order  := SB2->(IndexOrd())
	Local nSB2Recno  := SB2->(Recno())
	Local lEstorna   := .T.
	Local cLocCQ     := GetMvNNR('MV_CQ','98')
	Local cSeekSD7   := ''
	Local aAreaSD3   := SD3->(GetArea())
	Local cNumSeq    := ''
	Local cOp        := ''
	Local cSeekSD3   := ''
	Local nQuant     := 0
	Local nQuant2UM  := 0
	Local nPerda     := 0
	Local bCampo     := {|nCpo| Field(nCpo) }
	Local cCodRef	 := ""

	//--------- Existe somente para manter legado ate R4 --------
	Local cMascara	 := GetMv("MV_MASCGRD")
	Local nTamRef	 := Val(Substr(cMascara,1,2))
	//-----------------------------------------------------------
	Local lMonta     := .F.
	Local cNumOP     := ' ',cNumOpOrig:= ''
	Local cReqAut    := A250ReqAut(GetMV("MV_REQAUT"))
	Local cDevAut    := A250DevAut(SuperGetMV("MV_DEVAUT",.F.,cReqAut))
	Local cEstNeg    := GetMV("MV_ESTNEG")
	Local nOpc1
	Local nQtdSD3	:=	0
	Local lEmpNeg	:= .F.
	Local aTam		:= {}
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel utilizada para controlar qdo deve liberar OP para   Ё
	//Ё producao apos estorno de apontamento parcial.                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lLiberOP:=.F.
	Local oDlg
	Local I
	Local lContinua := .T.
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se devera' estornar ou nao todos os itens da Grade     Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lEstGrd    := If(mv_par04 == 1 , .T. , .F.)
	Local cAliasNew  := 'SD3'
	Local cQuery	 := ''
	Local lQuery	 := .F.
	Local lEmpPrev   := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
	Local aCtbDia	 := {}
	Local nX		 := 0
	Local aTravas	 := {}
	Local lConsVenc	 := GetMV('MV_LOTVENC')=='S'
	Local lOpEncer	 := .F.
	Local aObjects   := {}
	Local aSize      := {}
	Local aInfo      := {}
	Local lPmsInt	 := IsIntegTop(,.T.)
	Local lIntACD 	 := SuperGetMV("MV_INTACD",.F.,"0") == "1"
	Local l250GREST  := ExistTemplate("MT250GREST")
	Local lPE250Gres := ExistBlock("MT250GREST")
	Local cOrdemPai  := Nil
	Local lWmsSD3    := IIf(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local nTamC2Num  := TamSX3("C2_NUM")[1]
	Local nTamC2Itm  := TamSX3("C2_ITEM")[1]
	Local lDelTBMRP  := _lNewMRP == NIL
	Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
	Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP
	Local cEndereco  := ''
	Local cAliasQry  := GetNextAlias()

	Private aTELA[0][0],aGETS[0]
		
	Private lAbreOP    := .T.

	If IsAtNewGrd()
		Private oGrade	  := MsMatGrade():New('oGrade',,"D3_QUANT",,"aVldGrade('A250')",, ;
		{	{"D3_QUANT"		,NIL,{	{"D3_QTSEGUM"	,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) } }} }, ;
		{"D3_QTSEGUM"	,NIL,{	{"D3_QUANT"		,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) } }} }, ;
		{"D3_PARCTOT"	,NIL,NIL},;
		{"D3_PERDA"		,NIL,NIL};
		})
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Executa ponto de entrada para montar array com botoes a      Ё
	//Ё serem apresentados na tela                                   Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If (ExistBlock("M250BUT"))
		aButtons:=ExecBlock("M250BUT",.F.,.F.,{nOpc})
		If ValType(aButtons) # "A"
			aButtons:=NIL
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica se o usuario tem permissao de delecao. Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддды
	lContinua := MaAvalPerm(1,{SD3->D3_COD,"MTA250",5})
	If !lContinua
		Help(,,1,'SEMPERM')
	EndIf

	fRetPrdAut(' ', 'S')
	fRetParPrd(' ', 'S')

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(SD3->D3_OP) )

	If Subs(D3_CF,1,2) == "ER"
		Help(" ",1,"A250MOVEST")
		lContinua := .F.
	ElseIf D3_CF != "PR0" .And. lProdaut
		Help(" ",1,"A250PRDAUT")
		lContinua := .F.
	ElseIf D3_CF == "PR1"
		Help(" ",1,"A250ESTPR1")
		lContinua := .F.
	ElseIf Subs(D3_CF,1,2) != "PR"
		Help(" ",1,"A250NAO")
		lContinua := .F.
	ElseIf D3_ESTORNO == "S"
		Help(" ",1,"A250ESTORN")
		lContinua := .F.
	ElseIf A250NEstor( D3_IDENT )
		Help(" ",1,"A250NESTOR")
		lContinua := .F.
	EndIf
	If lContinua
		SC2->(dbSetOrder(1))
		If !SC2->(dbSeek(xFilial("SC2")+SD3->D3_OP))
			Help(" ",1,"A650NOP",,SD3->D3_OP,02,01)
			lContinua := .F.
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica calendАrio contАbil                Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lContinua
		lContinua := (CtbValiDt(Nil,SD3->D3_EMISSAO,,Nil ,Nil ,{"EST001"}))
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida se o Apontamento da OP foi originado pelo SIGAAGR     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lContinua
		lContinua := A250INTAGR(SD3->D3_OP)
	EndIf

	//-- Todas as ordens de servico do WMS nao executadas para esta producao, serao travadas e estornadas na funcao A250DesAtu
	//-- As ordens de servico ja executadas deverao ser estornadas pela rotina de execucao de servicos do WMS
	If	lContinua .And. IntWms(SD3->D3_COD) .And. !Empty(SD3->D3_SERVIC) .And. !lWmsSD3
		lContinua := WmsAvalSC2("2",,,,SD3->(Recno()))
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida produtos bloqueados(Produtos Acabados)		Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SB1->(dbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1")+SD3->D3_COD))
	If lContinua .And. SB1->B1_MSBLQL $ "1"
		Aviso("A250BLOQ",STR0015+ " ''" +AllTrim(SB1->B1_COD)+ "'' " +STR0075,{"OK"})   //Produto bloqueado
		lContinua := .F.
	Endif

	lReabreOp  := .F.
	lValReabr  := .F.

	If lContinua
		RestArea(aAreaSD3)
		cNum := SD3->D3_DOC
		cItemGrd:= Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD))
		cNumOpOrig:= Substr(SD3->D3_OP,1,Len(SD3->D3_OP)-Len(cItemGrd))
		cDoc    := SD3->D3_DOC
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se for estornar todos os itens da Grade,a Enchoice sera' mon-Ё
		//Ё tada de acordo com as variaveis de memoria, caso contrario,  Ё
		//Ё sera' montada baseando-se no registro corrente no SD3        Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lEstGrd .And. !Empty(cItemGrd)
			lMonta := .T.
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Salva a integridade dos campos de Bancos de Dados            Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			For i := 1 To FCount()
				M->&(EVAL(bCampo,i)) := FieldGet(i)
			Next i
			lQuery := .F.
			If ( TcSrvType()<>"AS/400" )
				lQuery := .T.
				cAliasNew := GetNextAlias()
				cQuery := " SELECT SUM(D3_QUANT) QTD, SUM(D3_QTSEGUM) QTSEGUM, SUM(D3_PERDA) PERDA FROM "+RetSqlName('SD3')
				cQuery += " WHERE "
				cQuery += " D3_FILIAL = '"+xFilial("SD3")+"' AND "
				cQuery += " D3_DOC = '"+cDoc+"' AND "
				cQuery += " D3_ESTORNO <> 'S' AND "
				cQuery += " D3_CF = 'PRO' AND "
				cQuery += " D3_OP LIKE '"+AllTrim(cNumOpOrig)+"%' AND "
				cQuery += " D_E_L_E_T_ = ' ' "
				cQuery := ChangeQuery(cQuery)
				DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cQuery),cAliasNew,.F.,.T.)
				aTam := TamSx3("D3_QUANT")
				TCSetField( cAliasNew, "QTD", "N",aTam[1] , aTam[2] )
				aTam := TamSx3("D3_QTSEGUM")
				TCSetField( cAliasNew, "QTSEGUM", "N",aTam[1] , aTam[2] )
				aTam := TamSx3("D3_PERDA")
				TCSetField( cAliasNew, "PERDA", "N",aTam[1] , aTam[2] )
			EndIf
			If lQuery
				nQuant 	:= (cAliasNew)->QTD
				nQuant2UM	:= (cAliasNew)->QTSEGUM
				nPerda		:= (cAliasNew)->PERDA
				(cAliasNew)->(DbCloseArea())
			Else
				dbSetOrder(2)
				dbSeek(xFilial("SD3")+cDoc)
				aAreaSD3:=SD3->(GetArea())
				Do While ! Eof() .And. D3_FILIAL+SD3->D3_DOC == xFilial("SD3")+cDoc
					If D3_ESTORNO != "S" .And. D3_CF == "PR0" .And. cNumOpOrig  == Substr(SD3->D3_OP,1,Len(SD3->D3_OP)-Len(cItemGrd))
						nQuant		+=	D3_QUANT
						nQuant2UM 	+=	D3_QTSEGUM
						nPerda		+=	D3_PERDA
					EndIf
					dbSkip()
				EndDo
			EndIf

			If IsAtNewGrd()
				cCodRef		 := M->D3_COD
				MatGrdPrrf(@cCodRef,.T.)
				M->D3_COD    := cCodRef
			Else
				M->D3_COD    := Substr(M->D3_COD,1,nTamRef)
			EndIf

			M->D3_QUANT  := nQuant
			M->D3_QTSEGUM:= nQuant2UM
			M->D3_PERDA  := nPerda
			M->D3_LOTECTL:= ' '
			M->D3_OP     := Substr(M->D3_OP,1,Len(M->D3_OP)-Len(cItemGrd))
		EndIf

		RestArea(aAreaSD3)
		While If(lMonta,!Eof() .And. D3_FILIAL+D3_DOC == xFilial("SD3")+cDoc,.T.)
			If SD3->D3_ESTORNO == "S"  .Or. cNumOpOrig <> Substr(SD3->D3_OP,1,Len(SD3->D3_OP)-Len(cItemGrd))
				dbSkip()
				loop
			EndIf
			If !lEstGrd .And. Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD))!=cItemGrd
				SD3->(dbSkip())
				loop
			EndIf

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se o produto est═ sendo inventariado.      Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If BlqInvent(D3_COD,D3_LOCAL)
				Help(" ",1,"BLQINVENT",,D3_COD+STR0048+D3_LOCAL,1,11) //" Almox: "
				lContinua := .F.
				Exit
			EndIf

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Analisa se o tipo do armazem permite a movimentacao |
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lContinua .And. AvalBlqLoc(D3_COD,D3_LOCAL,Nil,,,,,,,D3_OP)
				lContinua := .F.
				Exit
			EndIf

			If D3_CF != "PR0"
				dbSkip()
				loop
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verificar data do ultimo fechamento em SX6.                  Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If dDataFec >= SD3->D3_EMISSAO
				Help ( " ", 1, "FECHTO" )
				lContinua := .F.
				Exit
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Caso o produto use localizacao, verificar se producao ja foi Ё
			//Ё distribuida.                                                 Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Localiza(SD3->D3_COD,.T.)
				If lWmsNew .And. IntWms(SD3->D3_COD)
					nQuantSDA := WmsSldD0G(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_NUMSEQ,SD3->D3_DOC)
				Else
					dbSelectArea("SDA")
					dbSetOrder(1)
					If dbSeek(xFilial("SDA")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ+SD3->D3_DOC)
						If SDA->DA_QTDORI # SDA->DA_SALDO
							dbSelectArea(cAlias)
							Help(" ",1,"SDAJADISTR")
							lContinua := .F.
							Exit
						Else
							//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Obtem quantidade empenhada por esperar distribuicao  Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
							nQuantSDA:=SDA->DA_QTDORI
						EndIf
					EndIf
					dbSelectArea(cAlias)
				EndIf
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se Devolucoes (geradas p/Qtd Negativa na Estrut) podem ser Estornadas Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea('SD3')
			aAreaSD3 := GetArea()
			cNumSeq  := D3_NUMSEQ
			cOp      := Alltrim(D3_OP)
			dbSetOrder(4)
			If dbSeek(cSeekSD3:=xFilial("SD3")+cNumSeq, .F.)
				Do While !Eof() .And. D3_FILIAL+D3_NUMSEQ == cSeekSD3
					If (Subs(D3_CF,1,1)=='D') .And. Empty(D3_ESTORNO) .And. ;
					(Alltrim(D3_OP)==cOp .Or. ;
					(Iif(lProdAut,SubStr(D3_OP,1,nTamC2Num+nTamC2Itm)==SubStr(cOp,1,nTamC2Num+nTamC2Itm),.F.)) )
						If !(MatVldEst(D3_COD,D3_LOCAL,D3_LOTECTL,D3_NUMLOTE,D3_LOCALIZ,D3_NUMSERI,D3_NUMSEQ,D3_DOC,D3_QUANT))
							RestArea(aAreaSD3)
							lContinua := .F.
							Exit
						EndIf
					EndIf
					dbSkip()
				EndDo
				If !lContinua
					Exit
				EndIf
			EndIf
			RestArea(aAreaSD3)

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se saldo do Lote/Sub-Lote esta Ok p/ EstornoЁ
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Rastro(SD3->D3_COD)
				dbSelectArea("SB8")
				dbSetOrder(3)
				If Rastro(SD3->D3_COD,"S")
					cSeekSB8:=xFilial("SB8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL+SD3->D3_NUMLOTE
					cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
				Else
					cSeekSB8:=xFilial("SB8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL
					cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
				EndIf
				dbSeek(cSeekSB8)
				Do While !Eof() .And. cSeekSB8 == &(cComparaSB8)
					If SD3->D3_EMISSAO > dDataBase
						nSaldoSB8+=SB8Saldo(,,,,,lEmpPrev,,SD3->D3_EMISSAO)
					Else
						nSaldoSB8+=SB8Saldo(,,,,,lEmpPrev,,dDataBase)
					EndIf
					dbSkip()
				EndDo
				dbSelectArea("SD3")
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Soma Saldo no SB8 com quantidade que espera distribuicaoЁ
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If (nSaldoSB8+nQuantSDA) < D3_QUANT
					Help(" ",1,"MA240NEGLT")
					lContinua := .F.
					Exit
				EndIf
			EndIf

			dbSelectArea(cAlias)

			//-- Verifica se a Produ┤фo no CQ pode ser realmente Excluida
			If SD3->D3_LOCAL == cLocCQ
				SD7->(dbSetOrder(3))
				If SD7->(dbSeek(xFilial('SD7')+SD3->D3_COD+SD3->D3_NUMSEQ, .F.)) .And. SD7->D7_ORIGLAN == 'PR'
					cSeekSD7 := xFilial('SD7') + SD7->D7_NUMERO + SD7->D7_PRODUTO
					SD7->(dbSetOrder(1))
					SD7->(dbSeek(cSeekSD7, .F.))
					Do While !SD7->(Eof()) .And. cSeekSD7 == SD7->D7_FILIAL+SD7->D7_NUMERO+SD7->D7_PRODUTO
						If SD7->D7_TIPO > 0 .And. Empty(SD7->D7_ESTORNO)
							Help(' ',1,'A261MOVICQ')
							lContinua := .F.
							Exit
						EndIf
						SD7->(dbSkip())
					EndDo
					If !lContinua
						Exit
					EndIf
				EndIf
			EndIf

			If lMonta
				dbSelectArea("SD3")
				dbSkip()
			Else
				Exit
			EndIf
		EndDo
	EndIf
	If lContinua
		RestArea(aAreaSD3)
		If l250Auto
			nOpca := 2
		Else
			//зддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ajusta a largura para o tamanho padrao Protheus Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддды
			aSize := MsAdvSize(,.F.,400)
			aObjects := {}
			AAdd( aObjects, { 100, 100, .T., .T. } )
			aInfo    := { aSize[1], aSize[2], aSize[3], aSize[4], 2, 2 }
			aPosObj := MsObjSize( aInfo, aObjects )

			nOpcA:=0
			DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
			nOpcA:=EnChoice( cAlias, nReg, nOpc, aAC,"AC",OemToAnsi(STR0009),aAcho,aPosObj[1],,,,,,,,lMonta)   //"Quanto ao estorno?"
			ACTIVATE MSDIALOG oDlg  ON INIT EnchoiceBar(oDlg,{|| nOpca := 2,oDlg:End()},{|| nOpca := 1,oDlg:End()},,aButtons)
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Este ponto de entrada permite validar algum campo espe-Ё
		//Ё cifico do usuario antes de se realizar o Estorno.      Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If nOpca == 2
			If ExistTemplate('MT250EST')
				lEstorna := ExecTemplate('MT250EST',.F.,.F.)
			EndIf
			If ExistBlock('MT250EST')
				lEstorna := Execblock('MT250EST',.F.,.F.)
			EndIf
		EndIf

		lEstorna:=If(lEstorna.And.!l250Auto,A250VldPV(),lEstorna)

		If nOpcA == 2 .And. lEstorna

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se existe integracao com o QIP no apontamento das Producoes Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If SuperGetMV("MV_QIPMAT",.F.,"N") == "S" .And. SuperGetMV("MV_QIPOPEP",.F.,"2") == '3' .And. IntQIP(SD3->D3_COD,"2")
				QIPAtualiza("SD3",2)
			EndIf

			dbSelectArea(cAlias)
			dbSetOrder(2)
			If lMonta
				dbSeek(xFilial("SD3")+cDoc)
			EndIf
			While If(lMonta,!Eof() .And. D3_FILIAL+D3_DOC == xFilial("SD3")+cDoc,.T.)
				If SD3->D3_ESTORNO == "S" .Or. cNumOpOrig  <> Substr(SD3->D3_OP,1,Len(SD3->D3_OP)-Len(SC2->C2_ITEMGRD))
					dbSkip()
					loop
				EndIf
				If D3_CF != "PR0"
					dbSkip()
					loop
				EndIf
				If !lEstGrd .And. Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD)) != cItemGrd
					SD3->(dbSkip())
					loop
				EndIf

				aRecSD3	:= SD3->(GetArea())
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se o custo medio e' calculado On-Line               Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If cCusMed == "O"
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё mv_par01 - Se mostra e permite digitar lancamentos contabeis   Ё
					//Ё mv_par02 - Se deve aglutinar os lancamentos contabeis          Ё
					//Ё mv_par03 - Encerra todos os Itens da Grade                     Ё
					//Ё mv_par04 - Estorna todos os Itens da Grade                     Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					pergunte("MTA250",.F.)
					lDigita   := Iif(mv_par01 == 1,.T.,.F.)
					lAglutina := Iif(mv_par02 == 1,.T.,.F.)
				EndIf

				//-- Avisa sobre Saldo Negativo ap╒s o Estorno
				nSB2Order := SB2->(IndexOrd())
				nSB2Recno := SB2->(Recno())
				SB2->(dbSetOrder(1))
				If SB2->(DbSeek(xFilial('SB2') + SD3->D3_COD + SD3->D3_LOCAL, .F.))
					nQtdSD3	:=	SD3->D3_QUANT
					If IntePms().AND. !lPmsInt
						//Tira as requisicoes Automaticas do PMS pois estas serao estornadas
						nQtdSD3	-=	QtdReqPMS()
					EndIf				
				
					If (SaldoMov(Localiza(SD3->D3_COD,.T.),.F.,Nil,A250PARTERC()==1,Nil,Nil,Nil,SD3->D3_EMISSAO) - nQtdSD3) < 0
						If !A250SalPer(nQtdSD3)
							If cEstNeg == "N"
								Aviso(STR0035,STR0094+" "+SD3->D3_COD+" "+STR0095+" "+SD3->D3_LOCAL+" "+STR0096,{"Ok"}) //"Esta movimentaГЦo nЦo sera permitida, porque ira deixar o saldo em estoque do Produto"
								lAborta := .T.
							Else
								If !l250Auto
									If Aviso(STR0035, STR0036 + AllTrim(SB2->B2_COD) + STR0037, {STR0038,STR0039},,, 1) # 2//'Aten┤└o'###'O saldo do produto '###' ficar═ negativo ap╒s o Estorno !'###'Abandona'###'Processa'
										lAborta := .T.
									EndIf
								EndIf
							Endif
						EndIf
					ElseIf (SB2->B2_QATU - nQtdSD3) < SB2->B2_RESERVA
						If cEstNeg == "N"
							Aviso(STR0035, STR0036 + AllTrim(SB2->B2_COD) + STR0047, {STR0038},,, 1) //'Aten┤└o'###'O saldo do produto '###' j═ esta comprometido em Pedidos Liberados !'###'Abandona'
							lAborta := .T.
						EndIf
					EndIf
				EndIf
				SB2->(dbSetOrder(nSB2Order))
				SB2->(MsGoto(nSB2Recno))

				Begin Transaction
					If !lAborta
						If !lProdAut
							//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Verifica se a OP esta encerrada                                Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							lOpEncer := ( !Empty( SC2->C2_DATRF ) )

							//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Envia p/func. de estorno das atualizacoes (SD3,SB2,SB3,SC2,..) Ё
							//Ё para parametro MV_PRODAUT == .F.                               Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							A250DesAtu(lLiberOP,,@aCtbDia,Nil,Nil,@aMRPxJson)

							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Recompoe o saldo do empenho - OP Encerrada                      Ё
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							If lOpEncer .AND. lAbreOP
								dbSelectArea("SD4")
								dbSetOrder(2)
								dbSeek(xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
								While SD4->(!EOF() .AND. D4_FILIAL+D4_OP==xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)

									If (SD4->(FieldPos('D4_QTNECES')) > 0)
										nQtNeces := SD4->D4_QTNECES
									Else
										nQtNeces := 0
									EndIf

									lGrvLote := a250GrvLt(SD4->D4_COD, SD4->D4_OP, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_LOTECTL)

									GravaEmp(	SD4->D4_COD,;
									SD4->D4_LOCAL,;
									SD4->D4_SLDEMP,;
									SD4->D4_SLDEMP2,;
									SD4->D4_LOTECTL,;
									SD4->D4_NUMLOTE,;
									NIL,;
									NIL,;
									SD4->D4_OP,;
									SD4->D4_TRT,;
									NIL,;
									NIL,;
									"SC2",;
									SD4->D4_OPORIG,;
									SD4->D4_DATA,;
									@aTravas,;
									.F.,;
									NIL,;
									.T.,;
									.T.,;		//Grava SD4
									lConsVenc,;
									NIL,;
									NIL,;
									.T.,;
									NIL,;
									NIL,;
									NIL,;
									lOpEncer,;
									/*29*/,;
									/*30*/,;
									/*31*/,;
									lGrvLote,;
									NIL,;
									NIL,;
									nQtNeces)

									//Para os casos produГЦo parcial com encerramento e posterior estorno, deve-se localizar o endereГo da sobra
									//Em seguida, usar o saldo existente na SD4 para efetuar a movimentaГЦo.*/
									// Realiza o estorno das requisiГУes no WMS
									If lWmsNew .And. IntWms(SD4->D4_COD)
										BeginSql Alias cAliasQry
											SELECT DC_LOCALIZ
											FROM %Table:SDC% SDC
											WHERE SDC.DC_FILIAL = %xFilial:SDC%
										 	AND SDC.DC_PRODUTO = %Exp:SD4->D4_COD%
										 	AND SDC.DC_LOCAL = %Exp:SD4->D4_LOCAL%
										 	AND SDC.DC_OP = %Exp:SD4->D4_OP%
										 	AND SDC.DC_TRT = %Exp:SD4->D4_TRT%
										 	AND SDC.DC_IDDCF = %Exp:SD4->D4_IDDCF%
										 	AND SDC.%NotDel%
										 EndSql

										 If (cAliasQry)->(!Eof())
										 	cEndereco := (cAliasQry)->DC_LOCALIZ
										 Else
										 	cEndereco := ''
										 EndIf
										 (cAliasQry)->(dbCloseArea())
										 
										WmsEmpReq("SC2",SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_SLDEMP,cEndereco,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,/*cNumSerie*/,SD4->D4_OP,SD4->D4_TRT,/*cIdDCF*/,/*cIdUnitiz*/,.F./*lEstorno*/,.T./*lCriaSDC*/, /*lEmpD14*/,,lOpEncer)
									EndIf

									//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Remove travas dos registros utilizados                  Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									MaDesTrava(aTravas)

									dbSelectArea("SD4")

									RecLock("SD4",.F.)
									SD4->D4_SLDEMP	:= 0
									SD4->D4_SLDEMP2	:= 0
									MsUnlock()

									dbSetOrder(2)
									SD4->(dbSkip())
								Enddo
							Endif
						Else
							//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Envia p/func. de estorno das atualizacoes (SD3,SB2,SB3,SC2,..) Ё
							//Ё para parametro MV_PRODAUT == .T.                               Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							cNumOp := SubStr(SD3->D3_OP,1,8)
							cOp    := Alltrim(SD3->D3_OP)
							cIdent := SD3->D3_IDENT
							cItemGrd := Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD))
							cOrdemPai := SD3->D3_OP

							If SD3->D3_PARCTOT # "T"
								lLiberOP:=A250Status(Alltrim(SD3->D3_OP), SD3->D3_NUMSEQ)
							EndIf

							dbSelectArea("SC2")
							dbSetOrder(1)

							dbSeek(xFilial("SC2")+cOp)
							Do While !Eof() .And. SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM == xFilial("SC2")+cNumOp

								//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Verifica se a OP esta encerrada                                Ё
								//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								lOpEncer := ( !Empty( SC2->C2_DATRF ) )

								//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Verifica se devera estornar ou nao todos os Itens da Grade,    Ё
								//Ё conforme parametro MV_ESTGRD                                   Ё
								//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								If !lEstGrd .And. SC2->C2_ITEMGRD != cItemGrd
									SC2->(dbSkip())
									loop
								EndIf
								//здддддддддддддддддддддддддддддддддддддддддд©
								//Ё Verifica se o produto possui empenho     Ё
								//Ё negativo                                 Ё
								//юдддддддддддддддддддддддддддддддддддддддддды
								lEmpNeg	:= A250EmpNeg(SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
								nRec:=Recno()

								dbSelectArea("SD3")
								dbSetOrder(1)
								If dbSeek(xFilial("SD3")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD+SC2->C2_PRODUTO)
									Do While !Eof() .And. xFilial("SD3")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD+SC2->C2_PRODUTO == SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD

										If SD3->D3_ESTORNO == "S"
											SD3->(dbSkip())
											loop
										EndIf

										If Substr(SD3->D3_CF,1,2) == "PR" .And. SD3->D3_IDENT == cIdent
											A250DesAtu(lLiberOP,,@aCtbDia,,cOrdemPai,@aMRPxJson)
											Exit
										EndIf
										dbSkip()
									EndDo
									cCF := "PR/"+If(cReqAut == "D","RE/","")+If(cDevAut == "D","DE/","")
									If (cReqAut == "D" .Or. cDevAut == "D").And. (SC2->C2_QUJE+If(lPerdInf,0,SC2->C2_PERDA) = 0)
										//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										//Ё Restaura o empenho das ordens de producao que nao possu-Ё
										//Ё em movimentacao para as requisicoes ou devol. digitadas |
										//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
										DbSelectArea("SD4")
										DbSetOrder(2)
										DbSeek(xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
										While SD4->(!EOF() .AND. D4_FILIAL+D4_OP==xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
											If !SD3->( DbSeek(xFilial("SD3")+SD4->(D4_OP+D4_COD+D4_LOCAL)) .And. D3_ESTORNO # "S" .And. (Substr(D3_CF,1,2) $ cCF ) )
												//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												//Ё Atualiza quantidade do SD4                              Ё
												//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
												RecLock("SD4",.F.)
												D4_QUANT := D4_QTDEORI
												MsUnlock()
											Else
												//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												//Ё Recompoe o saldo do empenho                                     Ё
												//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
												GravaEmp(	SD4->D4_COD,;		//01
												SD4->D4_LOCAL,;
												SD4->D4_SLDEMP,;
												SD4->D4_SLDEMP2,;
												SD4->D4_LOTECTL,;
												SD4->D4_NUMLOTE,;
												NIL,;
												NIL,;
												SD4->D4_OP,;
												SD4->D4_TRT,;
												NIL,;
												NIL,;
												"SC2",;
												SD4->D4_OPORIG,;
												SD4->D4_DATA,;
												@aTravas,;
												.F.,;		//ALTERADO
												NIL,;
												.T.,;
												.T.,;		//Grava SD4
												lConsVenc,;
												NIL,;
												NIL,;
												.T.,;
												NIL,;
												NIL,;
												NIL,;
												lOpEncer,;
												/*29*/,;
												/*30*/,;
												/*31*/,;
												IIf(Empty(SD4->D4_LOTECTL),.F.,.T.))
											EndIf
											SD4->(DbSkip())
										EndDo
									Else
										//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										//Ё Recompoe o saldo do empenho - OP Encerrada                      Ё
										//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
										If lOpEncer .AND. lAbreOP
											dbSelectArea("SD4")
											dbSetOrder(2)
											dbSeek(xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
											While SD4->(!EOF() .AND. D4_FILIAL+D4_OP==xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)

												lGrvLote := a250GrvLt(SD4->D4_COD, SD4->D4_OP, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_LOTECTL)
												
												GravaEmp(	SD4->D4_COD,;		//01
												SD4->D4_LOCAL,;
												SD4->D4_SLDEMP,;
												SD4->D4_SLDEMP2,;
												SD4->D4_LOTECTL,;
												SD4->D4_NUMLOTE,;
												NIL,;
												NIL,;
												SD4->D4_OP,;
												SD4->D4_TRT,;
												NIL,;
												NIL,;
												"SC2",;
												SD4->D4_OPORIG,;
												SD4->D4_DATA,;
												@aTravas,;
												.F.,;		//ALTERADO
												NIL,;
												.T.,;
												.T.,;		//Grava SD4
												lConsVenc,;
												NIL,;
												NIL,;
												.T.,;
												NIL,;
												NIL,;
												NIL,;
												lOpEncer,;
												/*29*/,;
												/*30*/,;
												/*31*/,;
												lGrvLote)

												//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												//Ё Remove travas dos registros utilizados                  Ё
												//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
												MaDesTrava(aTravas)

												dbSelectArea("SD4")

												RecLock("SD4",.F.)
												SD4->D4_SLDEMP	:= 0
												SD4->D4_SLDEMP2	:= 0
												MsUnlock()

												dbSetOrder(2)
												SD4->(dbSkip())
											Enddo
										Endif
									EndIf
								ElseIf !lEmpNeg .And. cReqAut == "D" .And. cEstNeg == "S" .And. (SC2->C2_QUJE+If(lPerdInf,0,SC2->C2_PERDA) <= 0) .And. (!Empty(SC2->C2_DATRF))
									dbSelectArea("SC2")
									nOpc1 := Aviso(STR0035, STR0052 +SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN +" / "+ SC2->C2_PRODUTO +;								 //"Atencao"###"A Ordem de Producao "
									STR0053 +; //"foi encerrada, sem Qtde. Produzida / Qtde. de Perda (C2_QUJE+C2_PERDA ==0). IMPORTANTE: Se Esta OP for Liberada"
									STR0054 +; //" para producao, os Empenhos deverao ser Ajustados atraves da Rotina de Ajustes de Empenhos. "
									STR0055,{STR0056, STR0057},,, 1 ) //"Esta OP devera ser liberada para Producao ?"###"Sim"###"Nao"
									//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Deixa OP disponivel para Producao.                 Ё
									//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
									If nOpc1 == 1
										RecLock("SC2",.F.)
										Replace C2_DATRF With Ctod("  /   /  ")
										If lIntNewMRP
											A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
										EndIf
									EndIf
								ElseIf !lEmpNeg .And. cReqAut == "D" .And. (SC2->C2_QUJE+If(lPerdInf,0,SC2->C2_PERDA) = 0)
									RecLock("SC2",.F.)
									Replace C2_DATRF With Ctod("  /   /  ")
									If lIntNewMRP
										A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
									EndIf
								ElseIf lEmpNeg .And. cDevAut == "D" .And. (SC2->C2_QUJE+If(lPerdInf,0,SC2->C2_PERDA) = 0)
									RecLock("SC2",.F.)
									Replace C2_DATRF With Ctod("  /   /  ")
									If lIntNewMRP
										A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
									EndIf
								EndIf

								dbSelectArea("SC2")
								MsGoto(nRec)
								dbSkip()
							EndDo
						EndIf
					EndIf

					dbSelectArea("SD3")
					RestArea(aRecSD3)

					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Integracao com o ACD -  Deleta registro da tabela CB0 no estorno do apontamento 	   Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					/*
					If lIntACD .And. FindFunction("CBMT250GREST")
						CBMT250GREST()
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Template acionando Ponto de Entrada                             Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					ElseIf l250GREST
						ExecTemplate("MT250GREST",.F.,.F.)
					EndIf
					*/

					If l250GREST
						ExecTemplate("MT250GREST",.F.,.F.)
					EndIf

					// Anderson 22/01/03
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Este ponto de entrada permite realizar gravacoes e/ou exclusoes em Ё
					//Ё tabelas e/ou campos especificos do usuario apos realizar o Estorno.Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If lPE250Gres
						ExecbLock("MT250GREST",.F.,.F.)
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Integracao com SIGASGA                     Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					If !Empty(SD3->D3_OP)
						SGESTORGEE(SD3->D3_OP)//Exclusao de Gases de Efeito Estufa - GEE
					Endif
				End Transaction
				If lMonta
					dbSelectArea("SD3")
					dbSkip()
				Else
					Exit
				EndIf
			EndDo

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Chama integraГЦo com novo MRP                                Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lIntNewMRP
				If Len(aMRPxJson[1]) > 0
					MATA650INT("INSERT", aMRPxJson[1])
					aSize(aMRPxJson[1], 0)
					FreeObj(aMRPxJson[2])
					aMRPxJson[2] := Nil
				EndIf
				If lDelTBMRP
					_lNewMRP := Nil
				EndIf
			EndIf

			dbSelectArea("SD3")
			dbSetOrder(1)

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se o custo medio e' calculado On-Line               Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If !lAborta .And. cCusMed == "O"
				RodaProva(nHdlPrv,nTotal)
				//зддддддддддддддддддддддддддд©
				//ЁAtualiza o cСdigo de diАrioЁ
				//юддддддддддддддддддддддддддды
				If !Empty(aCtbDia)
					cCodDiario := CtbaVerdia()
					For nX := 1 to Len(aCtbDia)
						aCtbDia[nX][3] := cCodDiario
					Next nX
				EndIf

				If cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
					lCriaHeader := .T.
					If !(aAtuSD3 == Nil) .And. ValType(aAtuSD3) == "A"
						For nX:=1 to len(aAtuSD3)
							MsGoTo(aAtuSD3[nX])
							RecLock("SD3",.F.)
							Replace D3_DTLANC With dDataBase
							MsUnLock()
						Next
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	dbSelectArea(cAlias)
Return

/*/{Protheus.doc} A250PARTERC
	Define o preenchimento da variavel cParTerc
	@type  Function
	@author mauricio.joao
	@since 17/05/2021
	@version 1.0
	@return cParTerc, character, definiГЦo do campo
/*/
Function A250PARTERC()
Local cParTerc as numeric
	//A POSICAO 8 DO PERGUNTE E LOCALIZADO, NAO EXISTE PARA TODOS OS PAISES
	//ENTAO PARA OS PAISES QUE NAO POSSUEM A POSICAO 8 NO DICIONARIO
	//O PROGRAMA ASSUME AUTOMATICAMENTE A POSICAO 9 COMO 8
	If cPaisLoc == 'ANG' .or. cPaisLoc == 'EQU' .or. cPaisLoc == 'HAI' .or. cPaisLoc == 'PTG'
		If IsInCallStack("MATA680") .Or. IsInCallStack("MATA681")
			cParTerc := MV_PAR09
		else
			cParTerc := MV_PAR07
		EndIf
	else
		If IsInCallStack("MATA680") .Or. IsInCallStack("MATA681")
			cParTerc := MV_PAR08
		else
			cParTerc := MV_PAR07
		EndIf
	EndIf	

Return cParTerc

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250Encer Ё Autor Ё Marcos Bregantim      Ё Data Ё 11/03/94 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de Encerramento de Ops.                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250Encer(ExpC1,ExpN1,ExpN2)                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Encer(cAlias, nReg, nOpc)

═ ═ Local aAC ═ ═ ═ ═:= { STR0007,STR0008 } ═ //"Abandona"###"Confirma"
═ ═ Local aAreaSD3 ═ := ''
═ ═ Local aInfo ═ ═ ═:= {}
═ ═ Local aObjects ═ := {}
═ ═ Local aSize ═ ═ ═:= {}
═ ═ Local aTam ═ ═ ═ := {}
═ ═ Local bCampo ═ ═ := {|nCpo| Field(nCpo) }
═ ═ Local cAliasNew ═:= ''
═ ═ Local cChavPesq ═:= SD3->(D3_OP+D3_COD)
═ ═ Local cCodRef ═ ═:= ''
═ ═ Local cMascara ═ := GetMv("MV_MASCGRD")
═ ═ Local cNumOP ═ ═ := ''
═ ═ Local cOp
═ ═ Local cOpOrig ═ ═:= 0
═ ═ Local cQuery ═ ═ := ''
═ ═ Local cSeqPai ═ ═:= ''
═ ═ Local dEmissao
═ ═ Local i ═ ═ ═ ═ ═:= 0
═ ═ Local lA250SPRC ═:= NIL
═ ═ Local lContinua ═:= .T.
═ ═ Local lEncOP ═ ═ := SuperGetMV("MV_ENCEOP",.F.,.F.)
═ ═ Local lIntSFC ═ ═:= IntegraSFC() .And. !IsInCallStack("AUTO681")
═ ═ Local lMonta ═ ═ := .F.
═ ═ Local lParcTot ═ := .F.
    Local lPeEncerOP := ExistBlock("M680ENCOP")
═ ═ Local lQuery ═ ═ := .F.
═ ═ Local lWmsSD3 ═ ═:= IIf(!(Type('lExecWms')=='U'), lExecWms, .F.)
═ ═ Local nOpca
═ ═ Local nPerda ═ ═ := 0
═ ═ Local nProdProp ═:= GetMV("MV_PRODPR0",NIL,1)
═ ═ Local nQuant ═ ═ := 0
═ ═ Local nQuant2UM ═:= 0
═ ═ Local nRecSD3
═ ═ Local nTamRef ═ ═:= Val(Substr(cMascara,1,2))
═ ═ Local oDlg

	

	// Verifica se devera encerrar ou nao todos os itens da Grade
	Local lEncGrd   := If( mv_par03 == 1, .T., .F.)
	Local lDelTBMRP  := _lNewMRP == NIL
	Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
	Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)

	Private aTELA[0][0],aGETS[0]

	If Type("l250Auto") == "U"
		Private l250Auto := .F.
	EndIf

	fRetPrdAut(' ', 'S')
	fRetParPrd(' ', 'S')

	If cAlias=="SD3"
		// Posiciona SB1 para referencia de validaГЦo de produto bloqueado.
		DbSelectArea("SB1")
		DbSetOrder(1)
		MsSeek(xFilial("SB1")+SD3->D3_COD)
	EndIf

	// Verifica se o usuario tem permissao de alteracao.
	lContinua := MaAvalPerm(1,{SD3->D3_COD,"MTA650",4})
	If !lContinua
		Help(,,1,'SEMPERM')
	EndIf

	// Verifica calendАrio contАbil
	If lContinua
		lContinua := (CtbValiDt(Nil,SD3->D3_EMISSAO,,Nil ,Nil ,{"EST001"}))
	EndIf

	dbSelectArea(cAlias)
	If Subs(D3_CF,1,2) == "ER"
		Help(" ",1,"A250MOVEST")
		lContinua := .F.
	ElseIf Subs(D3_CF,1,2) != "PR"
		Help(" ",1,"A250NAO")
		lContinua := .F.
	ElseIf D3_ESTORNO == "S"
		Help(" ",1,"A250ESTORN")
		lContinua := .F.
	EndIf

	//-- Tratamento de Encerramento de OP com separaГЦo WMS, somente permitirА caso seja estornado o ServiГo no WMS
	If lContinua .And. IntWms() .And. !lWmsSD3
		lContinua := WmsAvalSC2("3",,,,SD3->(Recno()))
	EndIf

	// MATEUS HENGLE - 02/05/23
	IF nProdProp == 3 	// Se MV_PRODPR0 = 3 -> Olha a data de emissao

		If lContinua .And. dDataFec >= SD3->D3_EMISSAO 
			Help ( " ", 1, "FECHTO" )
			lContinua := .F.
		EndIf

	ELSE 			// Se MV_PRODPR0 <> 3 -> Olha a DataBase, como jА estava anteriormente

		If lContinua .And. dDataFec >= dDataBase
			Help ( " ", 1, "FECHTO" )
			lContinua := .F.
		EndIf

	ENDIF
	// MATEUS HENGLE - 02/05/23




	// Valida produtos bloqueados(Produtos Acabados)
	If lContinua .And. SB1->B1_MSBLQL $ "1"
		Aviso("A250BLOQ",STR0015+ " ''" +AllTrim(SB1->B1_COD)+ "'' " +STR0075,{"OK"})   //Produto bloqueado
		lContinua := .F.
	Endif

	// Verifica se a Ordem de Producao nao foi encerrada por outra estacao
	If lContinua .And. SC2->(dbSeek(xFilial("SC2")+Alltrim(SD3->D3_OP))) .And. !Empty(SC2->C2_DATRF)
		Help(" ",1,"A250ENCERR")
		lContinua := .F.
	EndIf

	//Forca o posicionamento no ultimo apontamento de producao.
	nRecSD3 := Recno()
	dbSetOrder(1)
	dbSeek(xFilial("SD3")+cChavPesq)
	While !EOF() .And. D3_FILIAL+D3_OP+D3_COD == xFilial("SD3")+cChavPesq
		If Substr(D3_CF,1,2) == "PR" .And. D3_ESTORNO # "S" .And. D3_EMISSAO > dEmissao
			nRecSD3 := Recno()
			dEmissao := D3_EMISSAO
		EndIf
		dbSkip()
	End
	MsGoTo(nRecSD3)

	// Verifica se a Ordem de Producao possui saldo em processo
	If ExistBlock("A250SPRC")
		lA250SPRC := ExecBlock("A250SPRC",.F.,.F.,{D3_OP,D3_EMISSAO})
	EndIf
	If lContinua .And. If(ValType(lA250SPRC)#"L",A250VerReq(D3_OP,D3_EMISSAO),!lA250SPRC)
		Help(" ",1,"A250NOENC")
		lContinua := .F.
	EndIf

	//-- Impede encerramento de OP integrada ao Chao de Fabrica
	If lContinua .And. lIntSFC
		CYQ->(dbSetOrder(1))
		lContinua := !CYQ->(dbSeek(xFilial("CYQ")+SD3->D3_OP))
		If !lContinua
			Aviso(STR0035,STR0117,{"OK"}) //-- Esta OP И movimentada somente atravИs do mСdulo ChЦo de FАbrica.
		EndIf
	EndIf

	If lContinua
		aAreaSD3:= SD3->(GetArea())
		cNum 	:= SD3->D3_DOC
		cItemGrd:= Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD))
		cNumOp  := Substr(SD3->D3_OP,1,Len(SD3->D3_OP)-Len(cItemGrd))
		cOpOrig := SD3->D3_OP
		cDoc    := SD3->D3_DOC
		cSeqPai := SC2->C2_SEQPAI

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se for encerrar todos os itens da Grade,a Enchoice sera' mon-Ё
		//Ё tada de acordo com as variaveis de memoria, caso contrario,  Ё
		//Ё sera' montada baseando-se no registro corrente no SD3        Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lEncGrd .And. !Empty(cItemGrd)
			lMonta := .T.
			// Salva a integridade dos campos de Bancos de Dados
			For i := 1 To FCount()
				M->&(EVAL(bCampo,i)) := FieldGet(i)
			Next i
			dbSetOrder(2)
			dbSeek(xFilial("SD3")+cDoc)
			aAreaSD3:=SD3->(GetArea())
			lQuery := .T.
			cAliasNew := GetNextAlias()
			cQuery := " SELECT SUM(D3_QUANT) QTD, SUM(D3_QTSEGUM) QTSEGUM, SUM(D3_PERDA) PERDA FROM "+RetSqlName('SD3')
			cQuery += " WHERE "
			cQuery += " D3_FILIAL = '"+xFilial("SD3")+"' AND "
			cQuery += " D3_DOC = '"+cDoc+"' AND "
			cQuery += " D3_ESTORNO <> 'S' AND "
			cQuery += " D3_CF = 'PRO' AND "
			cQuery += " D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery(cQuery)
			DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cQuery),cAliasNew,.F.,.T.)
			aTam := TamSx3("D3_QUANT")
			TCSetField( cAliasNew, "QTD", "N",aTam[1] , aTam[2] )
			aTam := TamSx3("D3_QTSEGUM")
			TCSetField( cAliasNew, "QTSEGUM", "N",aTam[1] , aTam[2] )
			aTam := TamSx3("D3_PERDA")
			TCSetField( cAliasNew, "PERDA", "N",aTam[1] , aTam[2] )
			If lQuery
				nQuant 	:= (cAliasNew)->QTD
				nQuant2UM	:= (cAliasNew)->QTSEGUM
				nPerda		:= (cAliasNew)->PERDA
				(cAliasNew)->(DbCloseArea())
				SD3->(RestArea(aAreaSD3))
			Else
				Do While ! Eof() .And. D3_FILIAL+SD3->D3_DOC == xFilial("SD3")+cDoc
					If D3_ESTORNO != "S" .And. D3_CF == "PR0"
						nQuant+= D3_QUANT
						nQuant2UM += D3_QTSEGUM
						nPerda+=D3_PERDA
					EndIf
					dbSkip()
				EndDo
			EndIf

			If IsAtNewGrd()
				cCodRef		 := M->D3_COD
				MatGrdPrrf(@cCodRef,.T.)
				M->D3_COD    := cCodRef
			Else
				M->D3_COD    := Substr(M->D3_COD,1,nTamRef)
			EndIf

			M->D3_QUANT  := nQuant
			M->D3_QTSEGUM:= nQuant2UM
			M->D3_PERDA  := nPerda
			M->D3_LOTECTL:= ' '
			M->D3_OP     := Substr(M->D3_OP,1,Len(M->D3_OP)-Len(cItemGrd))
		EndIf

		If !lIntQual .And. (! l250Auto)

			// Ajusta a largura para o tamanho padrao Protheus
			aSize := MsAdvSize(,.F.,400)
			aObjects := {}
			AAdd( aObjects, { 100, 100, .T., .T. } )
			aInfo    := { aSize[1], aSize[2], aSize[3], aSize[4], 2, 2 }
			aPosObj := MsObjSize( aInfo, aObjects )

			DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
			nOpcA:=0
			nOpcA:=EnChoice( cAlias, nReg, nOpc, aAC,"AC",OemToAnsi(STR0010),aAcho,aPosObj[1], , , , , , , ,lMonta)      //"Quanto ao Encerramento?"
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If(A250EndOk(),(nOpca := 2,oDlg:End()),)},{|| nOpca := 1,oDlg:End()})
		Else
			nOpca:= If( (!lIntQual) .Or. A250EndOk(), 2, 0)
		EndIf

		// Executa funcao que encerra OP
		If nOpcA == 2
			//здддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Quando utiliza proporcionalizacao tipo 3   Ё
			//Ё no recalculo do custo medio pergunta se    Ё
			//Ё altera tipo do apontamento                 Ё
			//юдддддддддддддддддддддддддддддддддддддддддддды
			If nProdProp == 3
				If l250Auto
					lParcTot:=If(Type("lProdTotal") <> "U", lProdTotal,.F.)
				Else
					lParcTot:=Aviso(STR0035,STR0060,{STR0056,STR0057},,,1) == 1
				EndIf
			EndIf

			RestArea(aAreaSD3)

			While !Eof() .And. D3_FILIAL+D3_DOC == xFilial("SD3")+cDoc

				If !(D3_CF $ "PR0/PR1")
					dbSkip()
					loop
				EndIf
				If !lEncGrd .And. Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD))!=cItemGrd
					dbSkip()
					loop
				EndIf
				If SC2->(dbSeek(xFilial("SC2")+SD3->D3_OP)) .And. Empty(SC2->C2_DATRF)
					If 	IsInCallStack("MATA250")
						If ( SC2->C2_SEQPAI > cSeqPai .Or.(SC2->C2_SEQPAI == cSeqPai .And. SD3->D3_OP == cOpOrig))
							If lParcTot
								Reclock("SD3",.F.)
								Replace D3_PARCTOT With "T"
								MsUNlock()
							EndIf
							A250End(.T., .T., @aMRPxJson)
						EndIf
					ElseIF IsInCallStack("MATA680") .Or. IsInCallStack("MATA681")
						If lEncOP .And. lPeEncerOP
							lEncOP:=ExecbLock("M680ENCOP",.F.,.F.)
							If ValType(lEncOP) # "L"
								lEncOP:=.T.
							EndIf
						EndIf
						If ((SC2->C2_SEQPAI > cSeqPai .And. lEncOP) .Or. (SC2->C2_SEQPAI == cSeqPai .And. SD3->D3_OP == cOpOrig))
							If lParcTot
								Reclock("SD3",.F.)
								Replace D3_PARCTOT With "T"
								MsUNlock()
							EndIf
							A250End(.T., .T., @aMRPxJson)
						EndIf
					Endif
				EndIf
				dbSelectArea("SD3")
				SD3->(dbSkip())
			EndDo

			// Chama integraГЦo com novo MRP
			If lIntNewMRP
				MATA650INT("INSERT", aMRPxJson[1])
				aSize(aMRPxJson[1], 0)
				FreeObj(aMRPxJson[2])
				aMRPxJson[2] := Nil
				If lDelTBMRP
					_lNewMRP := Nil
				EndIf
			EndIf

			//Integracao com SIGASGA
			SGAGEEPCP(cOpOrig,"3")//Geracao de Gases de Efeito Estufa - GEE

			//здддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza Valores Rateados                  Ё
			//юдддддддддддддддддддддддддддддддддддддддддддды
			/*
			Issue: DMANSMARTSQUAD1-13239
			Ticket: 5661790
			Foi alinhado com a equipe de Custos sobre o rateio no Encerramento da OP
			e o rateio nЦo deve ser feito no MATA250.
			Por esse motivo estamos retirando o rateio do MATA250. Qualquer dЗvida referente ao processo
			de Custos deve ser tratado com a equipe de Custos.
			O alinhamento com a equipe de Custos estА na issue DMANSMARTSQUAD1-13239.
			*/
			/*
			If nProdProp == 3 .And. lParcTot

				aAreaSD3En := SD3->(GETAREA())
				aAreaSC2En := SC2->(GETAREA())

				DbSelectArea("SC2")
				SC2->(DbSetOrder(1))
				SC2->(dbGoTop())
				SC2->(dbSeek(xFilial("SC2")+cOpOrig))

				//Busca valor total das requisiГУes
				nCusto := 0
				DbSelectArea("SD3")
				SD3->(DbSetOrder(1))
				SD3->(dbGoTop())
				SD3->(dbSeek(xFilial("SD3")+cOpOrig))
				While !Eof() .And. SD3->D3_FILIAL+SD3->D3_OP == xFilial("SD3")+cOpOrig
					If (SD3->D3_CF $ "PR0/PR1") .Or. SD3->D3_ESTORNO == "S"
						SD3->(dbSkip())
						loop
					EndIf

					If SD3->D3_CUSTO1 > 0
						nCusto += SD3->D3_CUSTO1
					EndIf
					SD3->(dbSkip())
				EndDo

				//Rateia o valor total das requisiГУes entre todas produГУes
				If nCusto > 0
					DbSelectArea("SD3")
					SD3->(DbSetOrder(1))
					SD3->(dbGoTop())
					SD3->(dbSeek(xFilial("SD3")+cOpOrig))
					While !Eof() .And. SD3->D3_FILIAL+SD3->D3_OP == xFilial("SD3")+cOpOrig
						If (!(SD3->D3_CF $ "PR0/PR1")) .Or. SD3->D3_ESTORNO == "S"
							SD3->(dbSkip())
							loop
						EndIf

						SD3->(Reclock("SD3",.F.))
						Replace SD3->D3_CUSTO1  With (nCusto * (SD3->D3_QUANT/SC2->C2_QUJE))
						SD3->(MsUNlock())

						SD3->(dbSkip())
					EndDo
				EndIf
				SD3->(RestArea(aAreaSD3En))
				SC2->(RestArea(aAreaSC2En))
			EndIf
			*/
		EndIf
	EndIf
	dbSelectArea(cAlias)

Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A250Atu  Ё Autor Ё Claudinei M. Benzi    Ё Data Ё 23/06/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de atualizacoes (SD3,SB2,SB3,SC2,...)             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250/MATA680                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Atu(cAlias,cIdent,aPedidos,aCriaDif,aBaixaComp, nQuantProd, nQuantPerda, cNumOp, cDoc, dEmissao, cParcTot,aChkBaixaC,cLotePrd,cSubLotePrd, nParPercPrM,lEncerraOP,lAtuEmp,aMRPxJson)
	Static lA250FilD4
	Static lSD3250I
	Static lSD3250ITE
	Static lA250ENDE  := NIL
	Static lA250ArrD4 := NIL

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Tamanho do array dos custos. Esta variavel foi criada para   Ё
	//Ё tornar mais facil a atualizacao do programa da Wily Dresser. Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local nX := 0
	Local zI := 0
	Local nTamArrCus := 5
	Local nIndice := 1,cLocal,cMes,cNumSeq,nRecPai,cLocReq
	Local aCustoI[nTamArrCus],aCustoD[nTamArrCus],aValApr[nTamArrCus],aValAprFF[nTamArrCus],cBxProp,cReqAut,cDevAut,cApropri
	Local aCM[nTamArrCus],aCusto[nTamArrCus],aCustoFF[nTamArrCus],aCustoFFI[nTamArrCus],aCustoFFD[nTamArrCus],aCustoTot[nTamArrCus]
	Local cLocProc := GetMvNNR('MV_LOCPROC','99')
	Local aTamSX3:={},nDecSD3,nDecSD4
	Local nQtdSD4Dif:=0,nQtSD4Dif2:=0,lCriaDif:=.F.,aTravas:={},aCamposDif:={}
	Local bCampo := {|nCPO| Field(nCPO) }
	Local nAchou:=0,nQtdaLib:=0
	Local nDecAnt := Set(3,8)
	Local i:=0,z:=0,w:=0, a:=0
	Local lFoiProCQ := .F.
	Local lIndicePE  := ExistBlock('A250INDI')
	Local nIndicePE  := 0
	Local cA250ENDE  := NIL
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel utilizada para gerar devolucao qdo usa qtd negativa Ё
	//Ё na estrutura.                                                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lGeraDev	:=.F.
	Local lDevCQ	:= .F.

	Local aBaixLote   := {}

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel utilizada para informar se movimentacao de producao Ё
	//Ё foi total ou parcial.                                        Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lProdTot:=NIL

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas qdo usa localizacao fisica              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local cSeek		:=""
	Local cCompara	:=""
	Local nQuantDC	:=0
	Local nQuantDC2	:=0
	Local nRecSDC	:=0
	Local lCriaSDC	:=.F.
	Local lConsRegD4:=.T.

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas para baixa "INTELIGENTE" do empenho     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local nAchouSD4   :=0
	Local nQuantBxSD4 :=0
	Local nQuantBx2SD4:=0
	Local nBaixaBxSD4 :=0
	Local nBaixaBx2SD4:=0
	Local cProdBxSD4  :=""
	Local cTrtBxSD4   :=""
	Local cDValSD4    := Replicate('z', Len(DtoS(SD4->D4_DTVALID)))
	Local cLoteSD4    := Replicate('z', Len(SD4->D4_LOTECTL))
	Local cSLoteSD4   := Replicate('z', Len(SD4->D4_NUMLOTE))
	Local cOPOrigSD4  := Replicate('z', Len(SD4->D4_OPORIG))
	Local cCQ			:= GetMvNNR('MV_CQ','98')
	Local aProdsSD4   :={{}}
	Local aArraySD4   :={{}}
	Local nQuant      :=0
	Local nQuant2UM   :=0
	Local nTamOP      := Len(Alltrim(&(cAlias+"->"+Substr(cAlias,2,2)+"_OP")))
	Local cAliasQry   := ""
	Local cAliasSB8   := "SB8"
	Local cQuery      := ""
	Local nLoop       := 0
	Local nQuantOrig  :={}
	Local aLotespOrig :={}
	Local aA250ArrD4  := NIL
	Local lContProc  := .T.
	Local aEmpPronto := {}
	Local cNoLib     := ""
	Local aEstruSB8  := SB8->( dbStruct() )
	Local nCntFor    := 0
	Local lContinua  := .T.
	Local lEmpPrev   := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
	Local cFilDelDC  := ""
	Local aSavAlias  := {}
	Local nPrapont	 := GetNewPar("MV_PRAPONT",2)
	Local nCalcD4 	 := 0
	Local cQipMat	 := GetNewPar("MV_QIPMAT","N")
	Local nProdProp  := SuperGetMV("MV_PRODPR0",NIL,1)
	
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel para indicar se existe PE para atualizar dados do empenho na producao do item empenhadoЁ
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	
	Local lExeAtuEmp:= .F.
	Local lBlockSD4 := ExistBlock("A250ATSD4")
	Local lLibPed   := SuperGetMV("MV_LIBACIM",.F.,.T.)
	Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
	Local lMt680qua := .T. // Indica se existe o PE MT680QUA 
	Local nPMacNut  := 0
	Local nPMicNut  := 0
	Local nRecnoC2	:= 0
	Local nLibFat	:= 0
	Local lAtuSd4   := .F.
	local nqtd      := 0

	//зддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se utiliza custo FIFO On-Line      Ё
	//юддддддддддддддддддддддддддддддддддддддддддддды
	Local lFFOnLine := IsFifoOnLine()

	Local l240CAT83  := FindFunction("V240CAT83") .And. V240CAT83()

	Local aAreaSH6 := {}
	Local nQtdPerOpe := 0
	Local cD3Observa := ""
	Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local cD4LOTECTL := CriaVar("D4_LOTECTL")
	Local cD4NUMLOTE := CriaVar("D4_NUMLOTE")

	Local nPos := 0
	Local nCols := 0

	Local lVldTpArr := Iif(Type("aAtuSD3") == "A",.T.,.F.)

	Local cFornDoc	:= " "
	Local cLojaDoc	:= " "
	Local lFornece := SD3->(ColumnPos("D3_FORNDOC")) > 0 .And. SD3->(ColumnPos("D3_LOJADOC")) > 0
	Local RetSB8Sald
	Local oSqlLogDoc  := Nil
	Local RetRastro
	Local RetLocD4
	Local ProdWms
	Local lDelTBMRP  := _lNewMRP == NIL
	Local lIntLocal  := aMRPxJson == NIL
	Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)

	Local lRet       := .T.
	Local lRetParPrd := .F.
	Local lTranEst   := .F.
	Local nPercPrM   := 0
	Local nQuantEst  := 0
	Local nQuantEst1 := 0
	Local nQuantUso  := 0
	Local aArrayAuto := {}

	Local lBxComp    := .F.
	Local nQtdPrdAnt := 0

	Local lUsaTRT	 := SuperGetMV("MV_USATRT",.F.,.T.)
	Local cTrtVazio	 := CriaVar("D4_TRT",.F.)

	Local lAtuLog := .T. //DMANSMARTSQUAD1-26905

	Local nAchouInd   := 0 

	Default aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)

	Private lDelOpSC := GetMV("MV_DELOPSC")== "S"

	If Type("l250Auto") == "U"
		Private l250Auto := .F.
	EndIf

    If Type("l681Auto") == "U"
		Private l681Auto := .F.
	EndIf

    If Type("l680Auto") == "U"
		Private l680Auto := .F.
	EndIf

	If Type("lRollWMS") == "U"
   		Private lRollWMS := .F.
	EndIf

	If Type("aIndAuto") == "U"
		Private aIndAuto := {}  
	EndIf

	Default nQuantProd  := SD3->D3_QUANT
	Default nQuantPerda := SD3->D3_PERDA
	Default cNumOP      := SD3->D3_OP
	Default cDoc        := SD3->D3_DOC
	Default dEmissao    := SD3->D3_EMISSAO
	Default cParcTot    := SD3->D3_PARCTOT
	Default cLotePrd    := SD3->D3_LOTECTL
	Default cSubLotePrd := SD3->D3_NUMLOTE
	Default lAtuEmp     := .T.

	/*
	lAtuEmp - Quando estiver .F., identifica que serЦo atualizadas apenas as informaГУes da OP, sem fazer a baixa dos empenhos.
	Utilizado para integraГЦo TOTVS MES, com o conceito de Consumo Real.
	*/
	If Type("nComps") != "N" .And. Type("aCols") == "A"
		Private nComps      := Len(aCols)
	EndIf

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(cNumOp) )

	If lFornece
		cFornDoc := SD3->D3_FORNDOC
		cLojaDoc := SD3->D3_LOJADOC
	EndIf

	If Type("aCols") == "A" .And. Type("nComps") == "N" .And. nComps == 0
		nComps := Len(aCols)
	EndIf
	cD3Observa := SD3->D3_OBSERVA

	If nParPercPrM = NIL
		nParPercPrM := 0
	EndIf

	If lEncerraOP = NIL
		lEncerraOP := .F.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel para gravar demanda no mes corretoЁ
	//юдддддддддддддддддддддддддддддддддддддддддддды
	cMes     := "B3_Q"+StrZero(Month(dEmissao),2)
	lProdTot := cParcTot == "T"

	cBxProp  := GetMv("MV_BXPROP")
	cReqAut  := A250ReqAut(GetMv("MV_REQAUT"))
	cDevAut  := A250DevAut(SuperGetMV("MV_DEVAUT",.F.,cReqAut))

	nRecPai  := SD3->(RecNo())

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250FilD4 == NIL
		lA250FilD4 := ExistBlock("A250FSD4")
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para selecionar SD4Ё
	//Ё ou ordenar quais empenhos serao considerados primeiro           Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250ArrD4 == NIL
		lA250ArrD4 := ExistBlock('A250ARD4')
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada SD3250I            Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lSD3250ITE == NIL
		lSD3250ITE := ExistTemplate("SD3250I")
	EndIf

	If lSD3250I == NIL
		lSD3250I := ExistBlock("SD3250I")
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada A250ENDE           Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250ENDE == NIL
		lA250ENDE := ExistBlock('A250ENDE')
	EndIf
	aTamSX3:=TamSX3("D3_QUANT")
	nDecSD3:=aTamSX3[2]
	aTamSX3:=TamSX3("D4_QUANT")
	nDecSD4:=aTamSX3[2]

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel que faz amarracao entre OP Pai e OPS filhas .       Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	cIdent := IIF(cIdent==NIL,CriaVar("D3_IDENT"),cIdent)
	aPedidos := IIF(aPedidos==NIL, {}, aPedidos)
	aCriaDif := IIF(aCriaDif==NIL, {{}}, aCriaDif)
	lRetBen  := IIF(lRetBen ==NIL, .F., lRetBen)
	cChaveF1 := IIF(cChaveF1==NIL, "", cChaveF1)

	AFILL(aCM      ,0)
	AFILL(aCusto   ,0)
	AFILL(aCustoTot,0)
	AFILL(aCustoFF ,0)
	AFILL(aCustoFFI,0)
	AFILL(aCustoFFD,0)
	AFILL(aCustoI  ,0)
	AFILL(aCustoD  ,0)
	AFILL(aValApr  ,0)
	AFILL(aValAprFF,0)

	If fRetParPrd(cNumOp) // A250Atu
		lRetParPrd := .T.
	EndIf

	SC2->(dbSetOrder(1))
	SC2->(dbSeek(xFilial("SC2")+cNumOP))

	If aBaixaComp == NIL

		//здддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Posiciona tipo de movimento no SF5         Ё
		//юдддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea("SF5")
		dbSetOrder(1)
		MsSeek(xFilial("SF5")+SD3->D3_TM)

		//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Posiciona no arquivo de OP's                       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддды

		dbSelectArea("SD3")

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o custo medio e' calculado On-Line               Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If cCusMed == "O"
			If lVldTpArr
				aAdd(aAtuSD3,SD3->(Recno()))
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Se necessario cria o cabecalho do arquivo de prova           Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lCriaHeader
				lCriaHeader := .F.
				nHdlPrv := HeadProva(cLoteEst,"MATA250",Subs(cUsuario,7,6),@cArquivo)
				If nHdlPrv <= 0
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Apaga o registro gravado pelo AxInclui                       Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					dbSelectArea("SD3")
					RecLock("SD3",.F.,.T.)
					dbDelete()
					dbGoTop()
					dbSelectArea("SD3")
					Set(3, nDecAnt)
					lContinua := .F. //O lContinua esta com .F. mais o return final eh .T.
				EndIf
			EndIf
		EndIf
		If lContinua
			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Pega o proximo numero sequencial de movimento      Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea('SD3')
			cNumSeq := D3_NUMSEQ
			cLocal  := D3_LOCAL

			//-- Envia o Produto da Grade Produzido para o CQ
			If l250
				If MatGrdPrrf(M->D3_COD) .And. D3_CF == "PR0"
					lEnvCQProd := .F.
					If fEnvCQProd(D3_COD, D3_TM, .F.) .And. !Empty(D3_QUANT)
						aTam := TamSx3("D3_LOCAL")
						M->D3_LOCAL := cCQ
						RecLock("SD3",.F.)
						Replace D3_LOCAL With M->D3_LOCAL
						cLocal  := D3_LOCAL
						lEnvCQProd := .T.
					Else
						fEnvCQProd(D3_COD, D3_TM, .T.)
					EndIf
				EndIf
			EndIf

			If l680 .Or. l681
				If D3_CF == "PR0"
					lEnvCQProd := .F.
					If cQipMat == "S"
						If ExistBlock("MT680QUA")   
							lMt680qua := ExecBlock("MT680QUA",.F.,.F.)
							If ValType(lMt680qua)<> "L"
								lMt680qua :=.F.
							EndIf
						EndIf
						If fEnvCQProd(SD3->D3_COD,SD3->D3_TM,.T.) .And. nPrapont == 1 .Or.;
						(nPrapont == 2 .And. Posicione("SB1",1,xFilial("SB1")+SC2->C2_PRODUTO,"B1_NUMCQPR") <> 0 .and. lMt680qua)
							aTam := TamSx3("D3_LOCAL")
							M->D3_LOCAL := cCQ

							RecLock("SD3",.F.)
							Replace D3_LOCAL With M->D3_LOCAL

							cLocal  := D3_LOCAL

							RecLock("SH6",.F.)
							Replace H6_LOCAL With cLocal

							lEnvCQProd := .T.
							If fGeraCQ0('SD3',SD3->D3_COD, 'PR', cLocCQOrig)
								lFoiProCQ := .T.
							EndIf
						EndIf
					Else
						If fEnvCQProd(SD3->D3_COD,SD3->D3_TM,.T.) 
							//envia para o cq.
							fGeraCQ0('SD3',SD3->D3_COD, 'PR', cLocCQOrig)
							lEnvCQProd := .T.
							lFoiProCQ := .T.
						EndIf
					EndIf
				EndIf
			Else
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Gera Registro tipo 0 no CQ (SD7) e Atualiza o Contador no SB1Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If lEnvCQProd .And. SD3->D3_CF == 'PR0' .And. fGeraCQ0('SD3',SD3->D3_COD, 'PR', cLocCQOrig)
					fEnvCQProd(SD3->D3_COD,SD3->D3_TM,.T.)
					lFoiProCQ := .T.
				EndIf
			Endif
		EndIf
	Else
		cNumseq := cIdent
		SF5->(MsSeek(xFilial("SF5")+GetMV("MV_TMPAD")))
	EndIf

	lBxComp := fCompOper(cNumOP)

	If lContinua
		//здддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Atualiza arquivo de empenhos e B2_QEMP     Ё
		//юдддддддддддддддддддддддддддддддддддддддддддды
		If SF5->F5_ATUEMP == "S" .And. lAtuEmp
			If cBxProp == "S"
				If !IsInCallStack("MATA680") .AnD. !IsInCallStack("MATA681")
					If lRetParPrd
						nIndice := Min(1,nQuantProd / SC2->C2_QUANT)
					Else				
						If lProdTot .And. GetMV("MV_BXSD4TL",.F.,.T.)
							nIndice := 1
						Else
							If lPerdInf
								nIndice := Min(1,nQuantProd / SC2->C2_QUANT)
							Else
								nIndice := Min(1,(nQuantProd + nQuantPerda) / SC2->C2_QUANT)
							EndIf
						EndIf 
					EndIf
				Else
					//Quando existe Componente x OperaГЦo nЦo deve considerar a Perda das operaГУes anteriores
					//A perda da operaГЦo anterior jА foi requisitada na prСpria operaГЦo
					If lPerdInf
						nQtdPrdAnt := 0
					Else
						If lBxComp
							nQtdPrdAnt := 0 + SH6->H6_QTDPERD
						Else
							nQtdPrdAnt := SH6->H6_PERDANT + SH6->H6_QTDPERD
						EndIf
					EndIf
					 
					If cParcTot == "P"						
						nIndice := Min(1,(nQuantProd + nQtdPrdAnt) / SC2->C2_QUANT)
					EndIf

					If cParcTot == "T" .And. GetMV("MV_BXSD4TL",.F.,.T.) == .F.
						nIndice := Min(1,(nQuantProd + nQtdPrdAnt) / SC2->C2_QUANT)
					EndIf
				EndIf
			EndIf

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ponto de Entrada para alteracao do Indice utilizado no calculo do Empenho Ё
			//Ё Parametros passados para no PARAMIXB:                                     Ё
			//Ё PARAMIXB[01] = Codigo do Produto                                          Ё
			//Ё PARAMIXB[02] = Quantidade a ser apontada                                  Ё
			//Ё PARAMIXB[03] = Quantidade da Perda                                        Ё
			//Ё PARAMIXB[04] = Quantidade da OP                                           Ё
			//Ё PARAMIXB[05] = Indice calculado pelo Sistema                              Ё
			//Ё PARAMIXB[06] = Protucao Total (True) ou Parcial (False)                   Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lIndicePE
				nIndicePE := ExecBlock('A250INDI', .F., .F., {SD3->D3_COD, SD3->D3_QUANT, SD3->D3_PERDA, SC2->C2_QUANT, nIndice, lProdTot})
				If ValType(nIndicePE) == 'N'
					nIndice := nIndicePE
				EndIf
			EndIf

			If !EMPTY(aIndAuto)
				nAchouInd:=ASCAN(aIndAuto,{ |x| x[1] == cNumOP})
				If nAchouInd != 0
					nIndice := aIndAuto[nAchouInd,2]
				EndIf
			EndIf

			aBaixLote := {}

			dbSelectArea("SD4")
			dbSetOrder(2)
			dbSeek(xFilial("SD4")+cNumOp)
			While !EOF() .And. D4_FILIAL+D4_OP==xFilial("SD4")+cNumOp

				RetRastro := Rastro(SD4->D4_COD)
				If aBaixaComp # NIL .And. aScan(aBaixaComp, {|z| z[1] + z[2] == SD4->(D4_COD + D4_TRT)}) == 0
					dbSkip()
					Loop
				EndIf

				If aBaixaComp == NIL .And. aChkBaixaC # NIL .And. aScan(aChkBaixaC, {|z| z[1] + z[2] == SD4->(D4_COD + D4_TRT)}) > 0
					dbSkip()
					Loop
				EndIf

				lConsRegD4:=.T.
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If lA250FilD4
					lConsRegD4:=ExecBlock("A250FSD4",.F.,.F.,{nIndice,.T.})
					If ValType(lConsRegD4) != "L"
						lConsRegD4:=.T.
					EndIf
				EndIf

				If FindFunction("AGRAFSD4").And. FUNNAME() = 'AGRA840'
					If lConsRegD4 .And. !AGRAFSD4()
						lConsRegD4 := .F.
					EndIf
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Nao baixa se filtrar empenho                                       Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !lConsRegD4.Or.(SF5->F5_TRANMOD=="N".And.IsProdMod(D4_COD))
					dbSkip()
					Loop
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Nao baixa se empenho foi criado por diferen┤a. Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддды
				//If Rastro(D4_COD) .And. Empty(IF(RASTRO(D4_COD,"S"),D4_NUMLOTE,D4_LOTECTL)) .And. !Empty(D4_OPORIG) .And.  lProdAut .And.  Empty(A250QuJe(D4_OPORIG))
				//	dbSkip()
				//	Loop
				//EndIf
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Se o parametro mv_ReqAut indicar que as requisicoes   Ё
				//Ё de materiais diretos sao digitadas entao ele baixara' Ё
				//Ё apenas materiais indiretos , diferentes de MOD , pois Ё
				//Ё a decisao de baixar ou nao a MOD esta' no TM pelo cam-Ё
				//Ё po F5_TRANMOD = "S".                                  Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				dbSelectArea("SB1")
				MsSeek(xFilial("SB1")+SD4->D4_COD)
				cApropri := "1"
				If B1_APROPRI == "I"
					cApropri := "2"
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica o local a ser baixado           Ё
				//юдддддддддддддддддддддддддддддддддддддддддды
				If cApropri == "2"
					cLocReq := cLocProc
				Else
					cLocReq := SD4->D4_LOCAL
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se ira gerar uma Devolucao ou   Ё
				//Ё requisicao, e analisa se o processo sera Ё
				//Ё automatico ou manual.                    Ё
				//юдддддддддддддддддддддддддддддддддддддддддды
				If (QtdComp(SD4->D4_QUANT,.T.) < QtdComp(0,.T.) .And. QtdComp(SD4->D4_QTDEORI,.T.) < QtdComp(0,.T.))
					If cDevAut == "D" .And. cApropri == "1" .And. !IsProdMod(SD4->D4_COD)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				Else
					If cReqAut == "D" .And. cApropri == "1" .And. !IsProdMod(SD4->D4_COD)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				EndIf

				nPercPrM := RetPerMIt(nParPercPrM)

				lQtLote := 1
				If a250VeQtNe(SD3->D3_PARCTOT, SD3->D3_QUANT, SD3->D3_QTGANHO, SD3->D3_QTMAIOR)
					If RetRastro
						lQtLote := a250QtLote(SD4->D4_OP, SD4->D4_COD, SD4->D4_TRT)
					EndIf
				EndIf

				//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Adiciona registro em array totalizador por produtoЁ
				//юддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(aProdsSD4[Len(aProdsSD4)]) > 4095
					AADD(aProdsSD4,{})
				EndIf
				For i:=1 to Len(aProdsSD4)
					nAchouSD4:=ASCAN(aProdsSD4[i],{ |x| x[1] == SD4->D4_COD .And. Iif(lUsaTRT,x[3] == SD4->D4_TRT,.T.)})
					If nAchouSD4 != 0
						If !a250VeQtNe(SD3->D3_PARCTOT,SD3->D3_QUANT, SD3->D3_QTGANHO, SD3->D3_QTMAIOR)
                            
							If nPercPrM > 0
								//Para produГЦo a maior.
								nCalcD4 := (SD4->D4_QTDEORI*nPercPrM)+SD4->D4_QTDEORI - (SD4->D4_QTDEORI-SD4->D4_QUANT)								
							Else
								nCalcD4 := (SD4->D4_QUANT + (SD4->D4_QUANT * nPercPrM))															
							EndIf

							//DMANSMARTSQUAD1-20099 - Vivian - 03/02/21 - Efetuado arredondamento antes de somar no aProdsSD4 para utilizar a mesma regra de quando adiciona no array
							nQtdAux2  := A250CalcD4(SD4->D4_QTDEORI,nIndice,SD3->D3_PARCTOT,nCalcD4,.F.)
							nQtdAux4  := A250CalcD4(SD4->D4_QTSEGUM,nIndice,,,.F.)
                            						
							aProdsSD4[i,nAchouSD4,2] += A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nQtdAux2,nDecSD4)
							aProdsSD4[i,nAchouSD4,4] += A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nQtdAux4,nDecSD4)
							Exit
						EndIf
					EndIf
				Next i
				If nAchouSD4 ==0
					nqtd := A250CalcD4(SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM),nIndice,SD3->D3_PARCTOT,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),.F.)
					nqtd := a250QtdNec(nqtd, SD3->D3_QUANT, SD3->D3_QTGANHO, SD3->D3_QTMAIOR, SD3->D3_PARCTOT) 

					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Verifica se a quantidade de casas decimais na SD4 И igual ao calculado          Ё
					//Ё Se nЦo for, serА arredondado o valor calculado com base nas casas decimais      Ё
					//Ё da SD4 para nЦo acontecer falta de saldo ao baixar os empenhos                  Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//DMANSMARTSQUAD1-20099 - Vivian - 03/02/21 - Criada a funГЦo RetQtdArred para fazer o arredondamento da quantidade porque И efetuado em vАrios pontos
					//DMANSMARTSQUAD1-21141 - Vivian - Comentado - o arredondamento serА efetuado depois que o array aProdsSD4 estiver todo alimentado
					//nqtd := RetQtdArred(nqtd,nDecSD4)					

					AADD(aProdsSD4[Len(aProdsSD4)],{SD4->D4_COD,A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nqtd,nDecSD4),Iif(lUsaTRT,SD4->D4_TRT,cTrtVazio),A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,A250CalcD4(SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM),nIndice,,,.F.),nDecSD4)})
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Nao baixa se quantidade estiver zerada                             Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !IsInCallStack("MATA250") .AnD. !IsInCallStack("MATA680") .AnD. !IsInCallStack("MATA681")
					If QtdComp(SD4->D4_QUANT,.T.)=QtdComp(0,.T.)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				Else
					If !lExistePM
						If QtdComp(SD4->D4_QUANT,.T.)=QtdComp(0,.T.)
							dbSelectArea("SD4")
							dbSkip()
							Loop
						EndIf
					EndIf
				EndIf

				// Retorno de beneficiamento que ja requisitou (RE5) e baixou empenhos do produto nao deve requisitar/baixar novamente
				If lRetBen .And. FindFunction("MTBuscaRE5")
					If MTBuscaRE5(cChaveF1, SD4->D4_COD, SD4->D4_OP)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				EndIf

				//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Adiciona registro em array organizado por empenho Ё
				//Ё Proporcionalizando a quantidade a empenhar		  Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(aArraySD4[Len(aArraySD4)]) > 4095
					AADD(aArraySD4,{})
				EndIf

				//nQtd2 := A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),nDecSD4)
				//nQtd2 := a250QtdNec(nQtd2, SD3->D3_QUANT, SD3->D3_QTGANHO)

				nQtd7 := A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),nDecSD4)
				nQtd7 := a250QtdNec(nQtd7, SD3->D3_QUANT, SD3->D3_QTGANHO, SD3->D3_QTMAIOR, SD3->D3_PARCTOT)
				nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)

				If a250VeQtNe(SD3->D3_PARCTOT, SD3->D3_QUANT, SD3->D3_QTGANHO, SD3->D3_QTMAIOR)
					If RetRastro .And. lQtLote > 1 .And. SD3->D3_QTMAIOR > 0
						nQtd7 := A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),nDecSD4)
					Else
						If RetRastro .And. lQtLote > 1  .And. SD3->D3_QTMAIOR == 0
							nAchouBaix := ASCAN(aBaixLote,{ |x| x[1] == SD4->D4_COD .And. Iif(lUsaTRT,x[2] == SD4->D4_TRT,.T.) })
							If nAchouBaix == 0
								AADD(aBaixLote, {SD4->D4_COD, IIf(lUsaTRT,SD4->D4_TRT,cTrtVazio),nQtd7, 0})
							EndIf

							nAchouBaix := ASCAN(aBaixLote,{ |x| x[1] == SD4->D4_COD .And. Iif(lUsaTRT,x[2] == SD4->D4_TRT,.T.) })
							If nAchouBaix > 0
								If aBaixLote[nAchouBaix,3] - aBaixLote[nAchouBaix,4] > 0
									If SD4->D4_QUANT != 0
										If (aBaixLote[nAchouBaix,3] - aBaixLote[nAchouBaix,4]) > SD4->D4_QUANT
											nQtd7 := SD4->D4_QUANT
											nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)
										Else
											nQtd7 := aBaixLote[nAchouBaix,3] - aBaixLote[nAchouBaix,4]
											nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)
										EndIf
										aBaixLote[nAchouBaix,4] += nQtd7
									Else
										nQtd7 := 0
									EndIf
								Else
									nQtd7 := 0
								EndIf
							EndIf
						Else
							nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)
						EndIf
					EndIf
				EndIf

				nQtd2 := nQtd7

				AADD(aArraySD4[Len(aArraySD4)],{	SD4->(Recno()),;														//01
				nQtd2 ,;			//02
				SD4->D4_COD,;															//03
				SD4->D4_LOCAL,;												            //04
				SD4->D4_TRT,;															//05
				SD4->D4_OPORIG,;      													//06
				nQtd7,;			//07
				DTOS(SD4->D4_DTVALID),;													//08
				SD4->D4_LOTECTL,;														//09
				SD4->D4_NUMLOTE,;														//10
				SD4->D4_OP,;															//11
				A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM),nDecSD4),;		//12
				A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,	SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM),nDecSD4),; 		//13
				SD4->D4_POTENCI})														//14
				dbSelectArea("SD4")
				dbSkip()
			End
			//DMANSMARTSQUAD1-21141 - Vivian - Alterado para efetuar o arredondamento depois do cАlculo da quantidade do empenho com base no Мndice de produГЦo
			For w:=1 to Len(aProdsSD4)		
				For z:=1 to Len(aProdsSD4[w])						
					If aProdsSD4[w,z,1] != ' ' .And. aProdsSD4[w,z,2] > 0
			   			aProdsSD4[w,z,2] := RetQtdArred(aProdsSD4[w,z,2],nDecSD4)				   			   		
					EndIf

					If aProdsSD4[w,z,1] != ' ' .And. aProdsSD4[w,z,4] > 0
						aProdsSD4[w,z,4] := RetQtdArred(aProdsSD4[w,z,4],nDecSD4)
					EndIf
				Next z
			Next w
        	//Fim DMANSMARTSQUAD1-21141 

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica quais empenhos serao baixados primeiro                 Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ordena array para utilizar empenhos mais "INTELIGENTES" primeiroЁ
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			For i:=1 to Len(aArraySD4)
				//-- Forca os Empenhos sem Lote/SubLote/Dt.Valid./OP Origem a ficarem por ultimo na Indexacao
				For z:=1 to Len(aArraySD4[i])
					If Rastro(aArraySD4[i,z,3]) .And. Empty(aArraySD4[i,z,9])
						If !lRetParPrd
							If Empty(aArraySD4[i,z,6])
								aArraySD4[i,z,6] := cOPOrigSD4
							EndIf
						EndIf
						aArraySD4[i,z,9] := cLoteSD4
						If Empty(aArraySD4[i,z,8])
							aArraySD4[i,z,8] := cDValSD4
						EndIf
						If Rastro(aArraySD4[i,z,3], 'S') .And. Empty(aArraySD4[i,z,10])
							aArraySD4[i,z,10] := cSLoteSD4
						EndIf
					EndIf
				Next z
				If lUsaTRT
					ASORT(aArraySD4[i],,,{ |x,y| x[3]+x[5]+x[6]+x[8]+x[9]+x[10] < y[3]+y[5]+y[6]+y[8]+y[9]+y[10]})
				Else
					ASORT(aArraySD4[i],,,{ |x,y| x[3]+x[6]+x[8]+x[9]+x[10] < y[3]+y[6]+y[8]+y[9]+y[10]})
				EndIf
				//-- Retorna os Empenhos sem Lote/SubLote/Dt.Valid./OP Origem ao formato original
				For z:=1 to Len(aArraySD4[i])
					If aArraySD4[i,z,9] == cLoteSD4
						If !lRetParPrd
							If aArraySD4[i,z,6] == cOPOrigSD4
								aArraySD4[i,z,6] := Space(Len(aArraySD4[i,z,6]))
							EndIf
						EndIf
						aArraySD4[i,z,9] := Space(Len(aArraySD4[i,z,9]))
						If aArraySD4[i,z,8] == cDValSD4
							aArraySD4[i,z,8] := Space(Len(aArraySD4[i,z,8]))
						EndIf
						If aArraySD4[i,z,10] == cSLoteSD4
							aArraySD4[i,z,10] := Space(Len(aArraySD4[i,z,10]))
						EndIf
					EndIf
				Next z
			Next i

			// FunГЦo A250Atu - Varrer o array aArraySD4 e carregar os produtos que possuem apontamento automatico			
			If lRetParPrd
				fArrayAuto(dEmissao,aArraySD4,@aArrayAuto,cNumOp)
			EndIf 									
            
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Percorre array para adequar atraves do indice de producao quais Ё
			//Ё empenhos serao utilizados.                                      Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			
			nQuantBxSD4 := 0
			For i:=1 to Len(aArraySD4)
				For z:=1 to Len(aArraySD4[i])
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Pesquisa quantidade para este produto no empenho                Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If !(aArraySD4[i,z,3] == cProdBxSD4 .And. Iif(lUsaTRT,aArraySD4[i,z,5] == cTrtBxSD4,.T.))

						//Validar quantidade em estoque com o previsto para requisitar..
						//Caso tenha ocorrido movimentaГЦo de estoque do componente durante o apontamento
						//Na validaГЦo de estoque encontrou estoque e agora na movimentaГЦo pode nЦo ter mais o estoque
						If lRetParPrd .AND. !IsProdMod(aArraySD4[i,z,3])
							If nQuantBxSD4 > 0
								If InTransact()
									DisarmTransaction()
								EndIf
								Help(NIL,NIL,'MATA250',NIL,STR0147 + CValToChar(AllTrim(cProdBxSD4)) + STR0148 + AllTrim(CValToChar(nQuantBxSD4)) + STR0149 + '(1)' , 1,0 ) 
								//Componete sem saldo suficiente para realizar o apontamento. Componente: XYZ. Saldo faltante: 99. Apontamento cancelado.
								Return .F. 
							ENDIF
						EndIf 

						For w:=1 to Len(aProdsSD4)
							nAchouSD4:=ASCAN(aProdsSD4[w],{ |x| x[1] == aArraySD4[i,z,3] .And. Iif(lUsaTRT,x[3] == aArraySD4[i,z,5],.T.)})
							If nAchouSD4 != 0
								nQuantBxSD4 := A250AvalQt(aProdsSD4[w,nAchouSD4,2],aArraySD4[i,z,3])
								nQuantBx2SD4:= A250AvalQt(aProdsSD4[w,nAchouSD4,4],aArraySD4[i,z,3])
								Exit
							EndIf
						Next w

						If lRetParPrd
							If aArrayAuto[z,9] == .F.
								nQuantEst := fSaldoAAuto(i,z,aArraySD4,aArrayAuto,.T.,.F.)
								nQuantUso := 0
							ENDIF
						EndIf

						cProdBxSD4 := aArraySD4[i,z,3]
						cTrtBxSD4  := aArraySD4[i,z,5]
					EndIf

					If lRetParPrd
						If aArrayAuto[z,9] == .T.
							nQuantEst := fSaldoAAuto(i,z,aArraySD4,aArrayAuto,.T.,.F.)
							nQuantUso := 0
						ENDIF
					ENDIF
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Efetua o calculo de quanto sera baixado em cada empenho         Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If QtdComp(nQuantBxSD4,.T.) != QtdComp(0,.T.)
						If QtdComp(nQuantBxSD4,.T.) < QtdComp(0,.T.)
							nBaixaBxSD4:=Max(QtdComp(nQuantBxSD4),QtdComp(aArraySD4[i,z,7]))
							nBaixaBx2SD4:=Max(QtdComp(nQuantBx2SD4),QtdComp(aArraySD4[i,z,13]))
							If QtdComp(nBaixaBxSD4) > QtdComp(aArraySD4[i,z,7])
								aArraySD4[i,z,2]:=nBaixaBxSD4
							EndIf
						Else
							If lRetParPrd .And. Empty(aArraySD4[i,z,9]) // A250Atu - sem lote
								If !Empty(aArraySD4[i,z,6]) //empenho da produГЦo automАtica
									nQuantEst1 := fSaldoAAuto(i,z,aArraySD4,aArrayAuto,.T.,.T.)
										
									If nQuantEst1 >= nQuantEst
										nQuantUso := nQuantEst
										nQuantEst1 -= nQuantEst
										nQuantBxSD4 -= nQuantEst
										nQuantEst := 0
									Else
										nQuantEst  -= nQuantEst1
										nQuantBxSD4 -= nQuantEst1
										nQuantEst1 := 0							
									EndIf
								Else
									If nQuantUso > 0
										aArraySD4[i,z,2] := nQuantUso
										nQuantUso := 0
									Else
										nQuantEst1 := nQuantEst
										nQuantEst  := 0
									EndIf
								EndIf 
							Else
								nQuantEst1 := aArraySD4[i,z,7]
							EndIf 				
					
							nBaixaBxSD4:=Min(QtdComp(nQuantBxSD4),QtdComp(aArraySD4[i,z,7]))
							nBaixaBxSD4:=Min(QtdComp(nQuantBxSD4),QtdComp(nQuantEst1))
							nBaixaBx2SD4:=Min(QtdComp(nQuantBx2SD4),QtdComp(aArraySD4[i,z,13]))
							If QtdComp(nBaixaBxSD4) < QtdComp(aArraySD4[i,z,7])
								aArraySD4[i,z,2]:=nBaixaBxSD4
							EndIf
						EndIf
						nQuantBxSD4-=nBaixaBxSD4
						nQuantBx2SD4-=nBaixaBx2SD4
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Caso tenha baixado toda a quantidade necessaria, passa o indice Ё
						//Ё dos empenhos restantes para ZERO.                               Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					Else
						If lRetParPrd .And. nQuantUso > 0
							aArraySD4[i,z,2] := nQuantUso
							nQuantUso := 0
						Else
							aArraySD4[i,z,2]:=0
						EndIf
					EndIf
				Next z
			Next i

			//Validar quantidade em estoque com o previsto para requisitar
			//Caso tenha ocorrido movimentaГЦo de estoque do componente durante o apontamento
			//Na validaГЦo de estoque encontrou estoque e agora na movimentaГЦo pode nЦo ter mais o estoque
			If lRetParPrd .AND. !Empty(cProdBxSD4) .And. !IsProdMod(cProdBxSD4)
				If nQuantBxSD4 > 0
					If InTransact()
						DisarmTransaction()
					EndIf
					Help(NIL,NIL,'MATA250',NIL,STR0147 + CValToChar(AllTrim(cProdBxSD4)) + STR0148 + AllTrim(CValToChar(nQuantBxSD4)) + STR0149 + '(2)' , 1,0 ) 
					//Componete sem saldo suficiente para realizar o apontamento. Componente: XYZ. Saldo faltante: 99. Apontamento cancelado.
					Return .F. 
				ENDIF
			EndIf 

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica a existencia de um Ponto de Entrada para selecionar SD4Ё
			//Ё ou ordenar quais empenhos serao considerados primeiro           Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lA250ArrD4 .And. !lProdTot
				aA250ArrD4 := ExecBlock('A250ARD4', .F., .F., aArraySD4)
				If ValType(aA250ArrD4) == 'A'
					aArraySD4 := aClone(aA250ArrD4)
				EndIf
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Percorre array para atualizar empenho .        Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддды
			For i:=1 to Len(aArraySD4)
				For w:= 1 to Len(aArraySD4[i])
					If aArraySD4[i,w,2] != 0 .AND. NoRound(aArraySD4[i,w,2],nDecSD4) != 0
						//здддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Posiciona no registro corrente .               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SD4")
						MsGoto(aArraySD4[i,w,1])
						RetLocD4 := Localiza(SD4->D4_COD,.T.)
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Se o parametro mv_ReqAut indicar que as requisicoes   Ё
						//Ё de materiais diretos sao digitadas entao ele baixara' Ё
						//Ё apenas materiais indiretos , diferentes de MOD , pois Ё
						//Ё a decisao de baixar ou nao a MOD esta' no TM pelo cam-Ё
						//Ё po F5_TRANMOD = "S".                                  Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SB1")
						MsSeek(xFilial("SB1")+SD4->D4_COD)
						cApropri := "1"
						If B1_APROPRI == "I"
							cApropri := "2"
						EndIf
						lGeraDev:=IIF((SD4->D4_QUANT < 0 .Or. SD4->D4_QTDEORI < 0),.T.,.F.)
						lDevCQ := lGeraDev .And. fEnvCQProd(SD4->D4_COD,SD3->D3_TM,.F.,aArraySD4[i,w,2]<0)
						//здддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Baixa apenas o saldo quando for ficar negativa Ё
						//Ё Analisa a necessidade de avaliar a potencia    Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддды
						nQuant    := aArraySD4[i,w,2]
						nQuant2UM := IIf(SB1->B1_CONV == 0 , nQuant / (SD4->D4_QUANT / SD4->D4_QTSEGUM) , ConvUm(SD4->D4_COD,aArraySD4[i,w,2],aArraySD4[i,w,13],2) )
						//здддддддддддддддддддддддддддддддддддддддддддддддд©
						//ЁVerifica o tipo de baixa do material de acordo  Ё
						//Ёcom o campo B1_TIPODEC                          Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддды
						nQuant:=A250PotOrg(SD4->D4_COD,SD4->D4_POTENCI,A250AvalQt(nQuant,SD4->D4_COD),nDecSD4)
						nQuant2UM:=A250PotOrg(SD4->D4_COD,SD4->D4_POTENCI,A250AvalQt(nQuant2UM,SD4->D4_COD))
						// Caso nao preencheu o Lote no empenho e verifica potencia deve escolher o lote
						// nesse momento
						If Empty(SD4->D4_LOTECTL+SD4->D4_NUMLOTE) .And. PotencLote(SD4->D4_COD)
							// Quantidade Original na potencia maxima
							nBaixaBXSD4:=A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nQuant,nDecSD4)
							// Quantidade a ser baixada do empenho
							nQuant     :=0
							nQuantOrig := 0
							aLotespOrig:={}
							SB8->(dbSetOrder(1))
							cAliasSB8 := GetNextAlias()
							IF oSqlLogDoc == nil
								cQuery := "SELECT "
								For nCntFor := 1 To Len( aEstruSB8 )
									If nCntFor > 1
										cQuery += ", "
									EndIf
									cQuery += aEstruSB8[ nCntFor, 1 ]
								Next
								cQuery += ", R_E_C_N_O_ B8REC"

								cQuery += " FROM "+RetSqlName("SB8")+" SB8 "
								cQuery += "WHERE SB8.B8_FILIAL='"+xFilial("SB8")+"' AND "
								cQuery += "SB8.B8_PRODUTO = ? AND "
								cQuery += "SB8.B8_LOCAL = ? AND "
								cQuery += "SB8.B8_SALDO > 0 AND SB8.D_E_L_E_T_=' ' "
								cQuery += "ORDER BY "+SqlOrder(SB8->(IndexKey()))

								cQuery := ChangeQuery(cQuery)
								oSqlLogDoc := FWPreparedStatement():New(cQuery)

							EndIf
							oSqlLogDoc:SetString(1, SD4->D4_COD  )
							oSqlLogDoc:SetString(2, SD4->D4_LOCAL  )

							cQuery := oSqlLogDoc:GetFixQuery()
							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8,.T.,.T.)
							aEval(SB8->(dbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSB8,x[1],x[2],x[3],x[4]),NIL)})
							dbSelectArea(cAliasSB8)
							RetSB8Sald := SB8Saldo(,,,,cAliasSB8,lEmpPrev,,SD3->D3_EMISSAO)
							While !(cAliasSB8)->(Eof()) .And. nBaixaBXSD4 > 0 .And. (cAliasSB8)->B8_FILIAL+(cAliasSB8)->B8_PRODUTO+(cAliasSB8)->B8_LOCAL == xFilial("SB8")+SD4->D4_COD+SD4->D4_LOCAL
								If QtdComp(SB8Saldo(,,,,cAliasSB8,lEmpPrev,,SD3->D3_EMISSAO),.T.)  > QtdComp(0,.T.)

									SB8->(MsGoto((cAliasSB8)->(B8REC)))

									Reclock("SB8",.F.)
									nQuant+=Min(nBaixaBxSD4,A250PotMax(SB8->B8_PRODUTO,SB8->B8_POTENCI,RetSB8Sald,nDecSD4))
									nQuantOrig+=A250PotOrg(SB8->B8_PRODUTO,SB8->B8_POTENCI,Min(nBaixaBxSD4,A250PotMax(SB8->B8_PRODUTO,SB8->B8_POTENCI,RetSB8Sald,nDecSD4)),nDecSD4)
									AADD(aLotespOrig,{SB8->B8_LOTECTL,SB8->B8_NUMLOTE,SB8->B8_POTENCI,A250PotOrg(SB8->B8_PRODUTO,SB8->B8_POTENCI,	Min(nBaixaBxSD4,A250PotMax(SB8->B8_PRODUTO,SB8->B8_POTENCI,RetSB8Sald,nDecSD4)),nDecSD4)})
									nBaixaBXSD4 -= Min(nBaixaBxSD4,A250PotMax(SB8->B8_PRODUTO,SB8->B8_POTENCI,RetSB8Sald,nDecSD4))
									dbSelectArea(cAliasSB8)
								EndIf
								dbSkip()
							EndDo
							dbCloseArea()
							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//ЁTratamento referente a localizacao fisica caso nao produza materialЁ
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							If RetLocD4 .And. !lGeraDev .And. (Empty(SD4->D4_OPORIG) .Or. !lProdAut)
								For zi:=1 to Len(aLotespOrig)
									GravaEmp(SD4->D4_COD,;
									SD4->D4_LOCAL,;
									aLotespOrig[zi,4],;
									ConvUm(SD4->D4_COD,aLotespOrig[zi,4],0,2),;
									aLotespOrig[zi,1],;
									If(Rastro(SD4->D4_COD,"S"),aLotespOrig[zi,1],NIL),;
									NIL,;
									NIL,;
									SD4->D4_OP,;
									SD4->D4_TRT,;
									NIL,;
									NIL,;
									"SD3",;
									SD4->D4_OPORIG,;
									NIL,;
									@aTravas,;
									.F.,;
									NIL,;
									.F.,;
									.F.,;
									NIL,;
									.T.,;
									.T.,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									SD3->D3_EMISSAO)
								Next zi
							EndIf
						EndIf
						RecLock("SD4",.F.)
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Variavel utilizada para gerar devolucao qdo usa qtd negativa Ё
						//Ё na estrutura.                                                Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If QtdComp(nQuant) > QtdComp(0)
							//SE O PERDINF FOR IGUAL A FALSO, SE FOR BAIXA POR COMPONENTE, SE FOR APONTAMENTO TOTAL E SE O MOVIMENTO FOR MENOR QUE A D4_QUANT
							//ZERA O SALDO DO EMPENHO E JOGA O QUE NцO FOI USADO PARA O SALDO
							IF !lPerdInf .And. lProdTot .And. D4_QUANT > nQuant
								Replace D4_SLDEMP With D4_QUANT - Round(nQuant,nDecSD4)
								Replace D4_QUANT With 0
								lAtuSd4 := .T.
							Else
								Replace D4_QUANT With if (D4_QUANT >= nQuant,D4_QUANT - Round(nQuant,nDecSD4), 0)
							EndIf
						Else
							Replace D4_QUANT With if (D4_QUANT <= nQuant,D4_QUANT - Round(nQuant,nDecSD4), 0)
						EndIf
						If QtdComp(nQuant) > QtdComp(0)
							Replace D4_QTSEGUM With if (D4_QTSEGUM >= nQuant2UM, D4_QTSEGUM - Round(nQuant2UM,nDecSD4), 0)
						Else
							Replace D4_QTSEGUM With if (D4_QTSEGUM <= nQuant2UM, D4_QTSEGUM - Round(nQuant2UM,nDecSD4), 0)
						EndIf
						//зддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza o campo totalizador dos empenhos Ё
						//юддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SB2")
						MsSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL)
						If EOF()
							CriaSB2(SD4->D4_COD,SD4->D4_LOCAL)
						EndIf
						if !SB2->(DBRLock()) .and. (l250Auto .OR. l681Auto .OR.l680Auto ) .and. (cPcpPend == '2' .OR. cPcpPend == '3'.OR. cPcpPend == '4')// VERIFICA se o produto estА locado em outro processamento ( respeitar parБmetro cPcpPend)
							lRet := .F.
							return lRet
						endif
						// Caso nao preencheu o Lote no empenho e verifica potencia deve escolher o lote
						// nesse momento
						If Empty(SD4->D4_LOTECTL+SD4->D4_NUMLOTE) .And. PotencLote(SD4->D4_COD)
							nQuant:=nQuantOrig
						EndIf
						//здддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Verifica o tipo do movimento e o custeio da OP Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддды
						If cAproPri == "1" .And. !MAvalCusOP(SD4->D4_COD,SF5->F5_CODIGO)
							cAproPri := "9"
						EndIf

						nRecnoC2 := SC2->(Recno())
						dbSelectArea("SC2")
						dbSetOrder(1)
						If dbSeek(xFilial("SC2")+SD4->D4_OPORIG)
							nPMacNut := SC2->C2_PMACNUT
							nPMicNut := SC2->C2_PMICNUT
						Else
							nPMacNut := SB1->B1_PMACNUT
							nPMicNut := SB1->B1_PMICNUT
						EndIf
						SC2->(MsGoTo(nRecnoC2))

						//здддддддддддддддддддддддддддддддддддддддддд©
						//Ё Gera requisicao automatica               Ё
						//юдддддддддддддддддддддддддддддддддддддддддды
						If Type("aLotPrdAut") == "A" .And. ;
						(nPos := aScan(aLotPrdAut,{|x| x[1]+x[2]+x[3] == SD4->(D4_OPORIG+D4_COD+D4_LOCAL)})) > 0
							cD4NUMLOTE := aLotPrdAut[nPos,4]
							cD4LOTECTL := aLotPrdAut[nPos,5]
						Else
							cD4NUMLOTE := SD4->D4_NUMLOTE
							cD4LOTECTL := SD4->D4_LOTECTL
						EndIf
						/*
						D3_LOTECTL estА gravando em branco, por isso nЦo atualiza a qtd. empenho na sb8
						*/
						RecLock("SD3",.T.)
						Replace  D3_FILIAL With xFilial("SD3"),D3_COD     With SD4->D4_COD,;
						D3_OP      With SD4->D4_OP			,D3_LOCAL   With IIF(lDevCQ,cCQ,SD4->D4_LOCAL),;
						D3_DOC     With cDoc				,D3_EMISSAO With dEmissao,;
						D3_NUMSEQ  With cNumseq				,D3_CC      With SC2->C2_CC, D3_CLVL    With SC2->C2_CLVL,;
						D3_UM      With SB1->B1_UM			,D3_GRUPO   With SB1->B1_GRUPO,;
						D3_TIPO    With SB1->B1_TIPO		,D3_SEGUM   With SB1->B1_SEGUM,;
						D3_CONTA   With SB1->B1_CONTA		,D3_CF      With IIF(lGeraDev,"DE","RE")+cApropri,;
						D3_CHAVE   With SubStr(D3_CF,2,1)+IIF(D3_CF=="DE4","9","0"),;
						D3_QUANT   With Abs(Round(nQuant,nDecSD4)),;
						D3_NIVEL   With SC2->C2_NIVEL,;
						D3_TM      With IIF(lGeraDev,"499","999"),;
						D3_QTSEGUM With Abs(Round(nQuant2UM,nDecSD4)),;
						D3_USUARIO With CUSERNAME,;					
						D3_TRT     With SD4->D4_TRT		,D3_IDENT   With cIdent,;
						D3_NUMLOTE With cD4NUMLOTE	,D3_LOTECTL With cD4LOTECTL,;
						D3_DTVALID With SD4->D4_DTVALID ,D3_POTENCI With SD4->D4_POTENCI,;
						D3_ITEMCTA With SC2->C2_ITEMCTA,;
						D3_OBSERVA With cD3Observa

						If lFornece
							Replace	D3_FORNDOC With cFornDoc
							Replace	D3_LOJADOC WiTh cLojaDoc
						EndIf

						Replace D3_QTMAIOR With SD4->D4_QTDEORI * nPercPrM
						Replace D3_PMACNUT With nPMacNut ,	D3_PMICNUT With nPMicNut

						ProdWms := IntWms(SD4->D4_COD)
						If lWmsNew .And. ProdWms
							Replace D3_IDDCF With SD4->D4_IDDCF
						EndIf

						//здддддддддддддддддд©
						//Ё Portaria CAT83   |
						//юдддддддддддддддддды
						If l240CAT83 .And. Empty(D3_CODLAN)
							Replace D3_CODLAN With A240CAT83()
						EndIf

						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//ЁTratamento referente a localizacao fisica caso nao produza materialЁ
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If RetLocD4 .And. !lGeraDev .And. A250VlOrig(SD4->D4_OPORIG) .And. (Empty(SD4->D4_OPORIG) .Or. (!lProdAut .Or. ! Empty(A250QuJe(SD4->D4_OPORIG))))
							lCriaSDC:=.F.
							nQuantDC:=0
							nQuantDC2:=0
							dbSelectArea("SDC")
							dbSetOrder(2)
							//-- Procura por Empenhos de produtos sem controle de rastreabilidade
							If !(RetRastro)
								cSeek:=xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT
								cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"
								//-- Procura por Empenhos que nao tiveram escolha de Lote e/ou Sub-lote
							ElseIf Empty(cD4LOTECTL)
								cSeek    := xFilial('SDC')+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+Space(Len(SDC->DC_LOTECTL))+Space(Len(SDC->DC_NUMLOTE))
								cCompara := 'DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE'
							Else
								If Rastro(SD4->D4_COD,"L")
									// Procura por empenho com lote
									cSeek:=xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+cD4LOTECTL
									cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL"
								Else
									// Procura por empenho com lote+sub-lote
									cSeek:=xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+cD4LOTECTL+cD4NUMLOTE
									cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE"
								EndIf
							EndIf
							//здддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Caso nao encontre os empenhos no SDC ou    Ё
							//Ё nao tenha quantidade suficiente empenhada, Ё
							//Ё cria o SDC agora.                          Ё
							//юдддддддддддддддддддддддддддддддддддддддддддды
							If !dbSeek(cSeek)
								lCriaSDC:=.T.
							Else
								nRecSDC:=Recno()
								nQuantDC:=0
								nQuantDC2:=0
								Do While !Eof() .And. cSeek == &cCompara
									nQuantDC+=DC_QUANT
									nQuantDC2+=DC_QTSEGUM
									dbSkip()
								EndDo
								If nQuantDC < SD3->D3_QUANT
									lCriaSDC:=.T.
								EndIf
								MsGoto(nRecSDC)
							EndIf

							//ValidaГЦo Quando foi informa o lote na Sd4, e nao foi informado o endereГo.
							If FindFunction("WMSVlLtSd4") .AND. !WMSVlLtSd4(lWmsNew,ProdWms,lCriaSDC,Rastro(SD4->D4_COD,"L"),SD4->D4_LOTECTL,SD4->D4_COD,nPercPrM,SD4->D4_OP,SD4->D4_TRT,SD4->D4_LOCAL)
								If InTransact()
									DisarmTransaction()
								EndIf
								lRollWMS := .T.
								Return .F. 
							EndIf 

							//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё A250ENDE - Ponto de Entrada para forcar um endereco especifico |
							//| para baixa do Empenho. ATENCAO sempre utilizar em conjunto o   |
							//| ponto de entrada A250CHEN para validar o saldo disponivel para |
							//| o endereco informado, para evitar divergencia de Saldos.       Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							cA250ENDE := Nil
							If lA250ENDE
								cA250ENDE := ExecBlock('A250ENDE', .F., .F., SD4->(Recno()))
								If !(ValType(cA250ENDE)=='C')
									cA250ENDE := Nil
								EndIf
								//-- Verifica a existencia do Endereco informado pelo
								//-- ponto de entrada, para evitar divergencia de saldos.
								SBE->(dbSetOrder(1))
								If !SBE->( MsSeek(xFilial("SBE")+SD4->D4_LOCAL+cA250ENDE) )
									cA250ENDE := Nil
								EndIf
							EndIf
							
							/*Se houver controle de WMS, o endereГo obrigatoriamente serА o informado em tela.
                              Nessa situaГЦo, nЦo faz sentido existir o ponto de entrada A250ENDE.
                              Ou seja, os dois sЦo mutuamente excludentes.
                            */
							
							GravaEmp(SD4->D4_COD,;
							SD4->D4_LOCAL,;
							SD3->D3_QUANT-nQuantDC,;
							SD3->D3_QTSEGUM-nQuantDC2,;
							cD4LOTECTL,;
							cD4NUMLOTE,;
							cA250ENDE,;
							NIL,;
							SD4->D4_OP,;
							SD4->D4_TRT,;
							NIL,;
							NIL,;
							"SD3",;
							SD4->D4_OPORIG,;
							NIL,;
							@aTravas,;
							.F.,;
							NIL,;
							.F.,;
							.F.,;
							NIL,;
							.T.,;
							lCriaSDC,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							SD3->D3_EMISSAO)

							If lWmsNew .And. lCriaSDC .And. ProdWms
								WmsEmpReq("SD3",SD4->D4_COD,SD4->D4_LOCAL,(SD3->D3_QUANT-nQuantDC),cA250ENDE,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,/*cNumSerie*/,SD4->D4_OP,SD4->D4_TRT,/*cIdDCF*/,/*cIdUnitiz*/,.F./*lEstorno*/,lCriaSDC)
							EndIf
						EndIf
						//здддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Pega os custos medios atuais               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддды
						aCM := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)
						//здддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Grava o custo da movimentacao              Ё
						//юдддддддддддддддддддддддддддддддддддддддддддды
						aCusto   := GravaCusD3(aCM)
						aCustoFF := {0,0,0,0,0}
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Acumula os totais requisitados para atualizar OP              Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						For a := 1 to Len(aCusto)
							aCustoTot[a] += aCusto[a]
						Next a

						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza o saldo atual (VATU) com os dados do SD3     Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						//A250Atu

						////DMANSMARTSQUAD1-26905
						lAtuLog := .T.
						If l250Auto .OR. l681Auto .OR.l680Auto
							lAtuLog := .F.
						EndIf

						ltranEst := B2AtuComD3(aCusto,,,.T.,lGeraDev,,,,,,,,,,,,,,,,,,,Empty(SD4->D4_OPORIG),cLotePrd,cSubLotePrd,,aCustoFF,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,lAtuLog)
						If lTranEst .and. InTransact()
							DisarmTransaction()
						EndIf
						If lTranEst 
							Return .F. 
						EndIf

						If lAtuSd4
							GravaB2Emp("-",SD4->D4_SLDEMP,"F",.F.,0)
							fAtuSb8Sbf()
						EndIf

						// Realiza a baixa das requisiГУes no WMS
						If lWmsNew .And. ProdWms
							IF !WmsBaixaReq(SD3->(Recno()))
								If InTransact()
									DisarmTransaction()
								EndIf	
								lRollWMS := .T.
								Return .F.
							EndIf
						EndIf

						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Se controla localizacao deleta registros gerados no   Ё
						//Ё SDC para geracao das baixas no SDB da diferenca entre Ё
						//Ё SD4 e SDC.											  Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If Localiza(SD3->D3_COD,.T.)
							aSavAlias := GetArea()
							cFilDelDC := "DC_FILIAL == '" +xFilial("SDC") +"' .And. DC_PRODUTO = '" +SD3->D3_COD +"' .And. "
							cFilDelDC += "AllTrim(DC_ORIGEM) == 'SD3' .And. DC_OP == '" +SD3->D3_OP +"'"
							dbSelectArea("SDC")
							dbSetFilter({|| &cFilDelDC}, cFilDelDC)
							dbGoTop()
							While !EOF()
								RecLock("SDC",.F.)
								SDC->(dbDelete())
								SDC->(MsUnLock())
								SDC->(dbSkip())
							End
							dbClearFilter()
							RestArea(aSavAlias)
						EndIf

						//-- Se item negativo (coproduto) e controla CQ, cria SD7
						If lDevCQ .And. fGeraCQ0('SD3',SD3->D3_COD,'PR',SD4->D4_LOCAL)
							fEnvCQProd(SD3->D3_COD,SD3->D3_TM,.T.,aArraySD4[i,w,2]>0)
							If Rastro(SD3->D3_COD) .And. SD3->(D3_FILIAL+D3_COD+D3_NUMSEQ) == SD7->(D7_FILIAL+D7_PRODUTO+D7_NUMSEQ)
								RecLock('SD7',.F.)
								Replace SD7->D7_LOTECTL With SD3->D3_LOTECTL
								Replace SD7->D7_NUMLOTE With SD3->D3_NUMLOTE
								SD7->(MsUnlock())
							EndIf

							If Localiza(SD3->D3_COD) .And. !Empty(GetMV("MV_DISTAUT"))
								A100Distri(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_NUMSEQ,SD3->D3_DOC,NIL,NIL,NIL,NIL,NIL,SD3->D3_QUANT,SD3->D3_LOTECTL,SD3->D3_NUMLOTE)
								//SIGAACD - Atualiza endereco/n. serie na etiqueta
								If UsaCB0("01")
									CBOPDistAut(SD3->D3_COD,SD3->D3_OP,SD3->D3_NUMSEQ)
								EndIf
							EndIf
						EndIf

						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Avalia se custo deve ser agregado para a OP           Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If cAproPri # "9"
							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Distribui o custo para Direto ou Indireto             Ё
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							If cLocReq == cLocProc
								For nX := 1 To nTamArrCus
									aCustoI[nX]   += If(lGeraDev,aCusto[nX]*-1,aCusto[nx])
									aCustoFFI[nX] += If(lGeraDev,aCustoFF[nX]*-1,aCustoFF[nx])
								Next nX
							Else
								For nX := 1 To nTamArrCus
									aCustoD[nX]   += If(lGeraDev,aCusto[nX]*-1,aCusto[nx])
									aCustoFFD[nX] += If(lGeraDev,aCustoFF[nX]*-1,aCustoFF[nx])
								Next nX
							EndIf
						EndIf
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё So grava demanda de material que sera consumido, nao grava   Ё
						//Ё demanda de material previsto para entrar.                    Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						//здддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza arquivo de demandas               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SB3")
						MsSeek(xFilial("SB3")+SD3->D3_COD)
						If EOF()
							RecLock("SB3",.T.)
							Replace B3_FILIAL With xFilial("SB3"), B3_COD With SD4->D4_COD
						Else
							RecLock("SB3",.F.)
						EndIf						
						Replace &(cMes) With &(cMes) + nQuant
						MsUnlock()
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Grava os lancamentos nas contas orcamentarias SIGAPCO    Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SD3->D3_TM <= "500"
							PcoDetLan("000152","01","MATA250")
						Else
							PcoDetLan("000152","02","MATA250")
						EndIf

						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Verifica se o custo medio e' calculado On-Line               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If cCusMed == "O"
							If lVldTpArr
								aAdd(aAtuSD3,SD3->(Recno()))
							EndIf

							// Grava os registros que estarЦo com o cСdigo do documento contabil relacionado (Correlativo)
							If ( UsaSeqCor() ) .AND. Type("aCtbDia") == "A"
								aAdd(aCtbDia,{"SD3",SD3->(RECNO()),"","D3_NODIA","D3_DIACTB"})
							Else
								aCtbDia := {}
							EndIF

							If SubStr(SD3->D3_CF,3,1) != "2"
								If SD3->D3_TM <= "500"
									//зддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Gera o lancamento no arquivo de prova           Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддды
									nTotal+=DetProva(nHdlPrv,"668","MATA250",cLoteEst)
								Else
									//зддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Gera o lancamento no arquivo de prova           Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддды
									nTotal+=DetProva(nHdlPrv,"666","MATA250",cLoteEst)
								EndIf
							Else
								If SD3->D3_TM <= "500"
									//зддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Gera o lancamento no arquivo de prova           Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддды
									nTotal+=DetProva(nHdlPrv,"679","MATA250",cLoteEst)
								Else
									//зддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Gera o lancamento no arquivo de prova           Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддды
									nTotal+=DetProva(nHdlPrv,"680","MATA250",cLoteEst)
								EndIf
							EndIf
						EndIf
					EndIf
				Next w
			Next i
		EndIf

		If oSqlLogDoc != Nil
			oSqlLogDoc:Destroy()
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se foi chamado somente para baixar parcialmente o empenho,             Ё
		//Ё finalizo o processamento aqui ja que a OP nao foi totalmente produzida Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If ! aBaixaComp == NIL
			lContProc := .F.
		EndIf

		If !lContProc .And. l681
			//зддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza os saldos atuais (VATU) das OP's Ё
			//юддддддддддддддддддддддддддддддддддддддддддды
			If !Empty(SD3->D3_OP) .And. cAproPri # "9"
				C2AtuComD3(aCustoTot)
			EndIf
		EndIf

		//зддддддддддддддддддддддддддддддддддд©
		//Ё Posiciona no registro da Producao Ё
		//юддддддддддддддддддддддддддддддддддды
		dbSelectArea("SD3")
		MsGoTo(nRecPai)

		If lContProc
			//зддддддддддддддддддддддддддддд©
			//Ё Pega os custos atuais da OP Ё
			//юддддддддддддддддддддддддддддды
			aCusto   := PegaC2Atu()
			If lFFOnLine
				aCustoFF := PegaC2Atu(.T.)
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza a quantidade da OP e verifica se ja' foi encerrada      Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			RecLock("SC2",.F.)
			Replace C2_QUJE  With C2_QUJE + SD3->D3_QUANT

			If lEncerraOP .And. (l681 .Or. l680)
				nQtdPerOpe := 0
				aAreaSH6  := SH6->(GetArea())

				SH6->(dbclosearea())

				dbSelectArea("SH6")
				dbSetOrder(1)
				dbGotop()
				dbSeek(xFilial("SH6")+SD3->D3_OP)

				While !Eof() .And. SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + SD3->D3_OP
					If SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + SD3->D3_OP //.And. SH6->H6_OPERAC + SH6->H6_SEQ = nOperAtual + nSeqAtual
						If SH6->H6_QTDPERD > 0
							nQtdPerOpe += SH6->H6_QTDPERD
						EndIf
					EndIf
					dbSkip()
				EndDO

				SH6->(dbclosearea())
				dbSelectArea("SH6")
				dbSetOrder(1)
				dbGotop()
				RestArea(aAreaSH6)

				RecLock("SC2",.F.)
				Replace C2_PERDA With nQtdPerOpe
			Else
				RecLock("SC2",.F.)
				Replace C2_PERDA With C2_PERDA + SD3->D3_PERDA
			EndIf

			If (lProdTot .And. (!l681 .And. !l680) ) .Or.;
			   (lProdTot .And. (l681 .Or. l680) .And. A680UltOper() .And. SH6->H6_QTDPROD>0) .Or.;
			    lEncerraOP
				Replace C2_DATRF With dEmissao
				dbSelectArea("SHD")
				dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
				While !Eof() .And. HD_OP == SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
					RecLock("SHD",.F.)
					Replace HD_DATRF With dEmissao
					dbSkip()
				End
				dbSelectArea("SC2")
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Soma o custo das requisicoes de materiais com apropriacao direta Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			For nX := 1 To nTamArrCus
				aCusto[nX]   := aCusto[nX]   + aCustoD[nX]
				If lFFOnLine
					aCustoFF[nX] := aCustoFF[nX] + aCustoFFD[nX]
				EndIf
			Next nX
			If !lProdTot .And. cBxProp == "S"
				For nX := 1 To nTamArrCus
					aValApr[nX]  := aCustoI[nX]   + aCusto[nX]
					aCusto[nX]   := aCusto[nX]    - aCusto[nX]
					If lFFOnLine
						aValAprFF[nX]:= aCustoFFI[nX] + aCustoFF[nX]
						aCustoFF[nX] := aCustoFF[nX]  - aCustoFF[nX]
					EndIf
				Next nX
				Replace C2_VATU1   With aCusto[01]  ,C2_VATU2   With aCusto[02],;
				C2_VATU3   With aCusto[03]  ,C2_VATU4   With aCusto[04],;
				C2_VATU5   With aCusto[05]
				If lFFOnLine
					Replace C2_VFIMFF1 With aCustoFF[01],C2_VFIMFF2 With aCustoFF[02],;
					C2_VFIMFF3 With aCustoFF[03],C2_VFIMFF4 With aCustoFF[04],;
					C2_VFIMFF5 With aCustoFF[05]
				EndIf
			Else
				For nX := 1 To nTamArrCus
					aValApr[nX]  := aCusto[nX]   + aCustoI[nX]
					aValAprFF[nX]:= aCustoFF[nX] + aCustoFFI[nX]
				Next nX
				Replace C2_VATU1   With 0,C2_VATU2   With 0,C2_VATU3   With 0,;
				C2_VATU4   With 0,C2_VATU5   With 0
				If lFFOnLine
					Replace C2_VFIMFF1 With 0,C2_VFIMFF2 With 0,C2_VFIMFF3 With 0,;
					C2_VFIMFF4 With 0,C2_VFIMFF5 With 0
				EndIf
			EndIf
			aCusto[01] := aValApr[01] + C2_APRATU1
			aCusto[02] := aValApr[02] + C2_APRATU2
			aCusto[03] := aValApr[03] + C2_APRATU3
			aCusto[04] := aValApr[04] + C2_APRATU4
			aCusto[05] := aValApr[05] + C2_APRATU5
			If lFFOnLine
				aCustoFF[01] := aValAprFF[01] + C2_APFIFF1
				aCustoFF[02] := aValAprFF[02] + C2_APFIFF2
				aCustoFF[03] := aValAprFF[03] + C2_APFIFF3
				aCustoFF[04] := aValAprFF[04] + C2_APFIFF4
				aCustoFF[05] := aValAprFF[05] + C2_APFIFF5
			EndIf

			Replace C2_APRATU1 With aCusto[01],C2_APRATU2 With aCusto[02],;
			C2_APRATU3 With aCusto[03],C2_APRATU4 With aCusto[04],;
			C2_APRATU5 With aCusto[05]

			If lFFOnLine
				Replace C2_APFIFF1 With aCustoFF[01],C2_APFIFF2 With aCustoFF[02],;
				C2_APFIFF3 With aCustoFF[03],C2_APFIFF4 With aCustoFF[04],;
				C2_APFIFF5 With aCustoFF[05]
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza movimento do Pai                    Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддды
			RecLock("SD3",.F.)
			Replace D3_CUSTO1 With aValApr[01],D3_CUSTO2 With aValApr[02],;
			D3_CUSTO3 With aValApr[03],D3_CUSTO4 With aValApr[04],;
			D3_CUSTO5 With aValApr[05]

			//здддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Pega o custo da movimentacao               Ё
			//юдддддддддддддддддддддддддддддддддддддддддддды
			aCusto := PegaCusD3()
			//здддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza arquivo de saldos em estoque do Pai Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea("SB2")
			If !SB2->(DbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL))
				CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
			EndIf
			if !SB2->(DBRLock()) .and. (l250Auto .OR. l681Auto .OR.l680Auto ) .and. (cPcpPend == '2' .OR. cPcpPend == '3'.OR. cPcpPend == '4') // VERIFICA se o produto estА locado em outro processamento ( respeitar parБmetro cPcpPend)
				lRet := .F.
				return lRet
			endif
			If lProdTot
				GravaB2Pre("-",(SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)) + SD3->D3_QUANT + If(lPerdInf,0,SD3->D3_PERDA),SC2->C2_TPOP)
			Else
				GravaB2Pre("-",If((SD3->D3_QUANT + If(lPerdInf,0,SD3->D3_PERDA))<0,0,Max(0,Min((SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA) + SD3->D3_QUANT + If(lPerdInf,0,SD3->D3_PERDA)), SD3->D3_QUANT + If(lPerdInf,0,SD3->D3_PERDA)))),SC2->C2_TPOP)
			EndIf
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza o saldo atual (VATU) com os dados do SD3     Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			//A250Atu
			
			////DMANSMARTSQUAD1-26905
			lAtuLog := .T.
			If l250Auto .OR. l681Auto .OR.l680Auto
				lAtuLog := .F.
			EndIf

			B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,cLotePrd,cSubLotePrd,,@aValAprFF,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,lAtuLog)

			//-- Realiza a Distribui┤фo Autom═tica atravez do parametro MV_DISTAUT
			If lFoiProCQ .And. Localiza(SD3->D3_COD) .And. !Empty(GetMV("MV_DISTAUT"))
				A100Distri(SD3->D3_COD, SD3->D3_LOCAL, SD3->D3_NUMSEQ, SD3->D3_DOC, NIL, NIL, NIL, NIL, NIL, SD3->D3_QUANT,SD3->D3_LOTECTL,SD3->D3_NUMLOTE)
			EndIf

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza Rastro no SD7 quando for Producao p/CQ       Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Rastro(SD3->D3_COD) .And. lEnvCQProd .And. SD3->D3_CF == 'PR0' .And. ;
			SD3->D3_FILIAL + SD3->D3_COD + SD3->D3_NUMSEQ == SD7->D7_FILIAL + SD7->D7_PRODUTO + SD7->D7_NUMSEQ
				Begin Transaction
					RecLock('SD7', .F.)
					Replace SD7->D7_LOTECTL With SD3->D3_LOTECTL
					Replace SD7->D7_NUMLOTE With SD3->D3_NUMLOTE
					SD7->(MsUnlock())
				End Transaction
			EndIf

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁLibera Pedido de Venda no Faturamento caso OP seja amarrada a pedido   Ё
			//Ёde venda, nao utilize localizacao fisica e seu TM libere PV            Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea("SC6")
			dbSetOrder(1)
			If dbSeek(xFilial("SC6")+SC2->C2_PEDIDO+SC2->C2_ITEMPV)
				If !Localiza(SD3->D3_COD,.T.) .And. (SD3->D3_LOCAL != cCQ) .And. ;
				(SF5->F5_LIBPVPR == "S") .And. (!Empty(SC2->C2_PEDIDO) .And. ;
				!Empty(SC2->C2_ITEMPV)) .And. Empty(SC6->C6_QTDRESE)

					nQtdaLib:=(SC6->C6_QTDVEN - SC6->C6_QTDEMP - SC6->C6_QTDENT)

					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//ЁVerifica se deve considerar o lote apontado na liberacao do pedido de  Ё
					//Ёvenda, e nao SLDPORLOTE(Utilizando FIFO).Usado somente se F5_LIBPVPR=S Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If (MV_PAR06 == 2) .And. Rastro(SD3->D3_COD)
						/*
						[01] Lote de Controle
						[02] Sub-Lote
						[03] Localizacao
						[04] Numero de Serie
						[05] Quantidade
						[06] Quantidade 2aUM
						[07] Data de Validade
						[08] Registro do SB2
						[09] Registro do SBF
						[10] Array com Registros do SB8 e qtd
						[11] Local
						[12] Potencia
						[13] Prioridade do endereco (BF_PRIOR)
						*/
						dbSelectArea("SB2")
						MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
						if !SB2->(DBRLock()) .and. (l250Auto .OR. l681Auto .OR.l680Auto ) .and. (cPcpPend == '2' .OR. cPcpPend == '3'.OR. cPcpPend == '4') // VERIFICA se o produto estА locado em outro processamento ( respeitar parБmetro cPcpPend)
							lRet := .F.
							return lRet
						endif
						aAdd(aEmpPronto,{ SD3->D3_LOTECTL,SD3->D3_NUMLOTE,SD3->D3_LOCALIZ,SD3->D3_NUMSERI,If(lLibPed .Or. (SC2->C2_QUJE<= SC6->C6_QTDVEN),Min(SD3->D3_QUANT,nQtdAlib),SD3->D3_QUANT),ConvUm(SD3->D3_COD,nQtdaLib,0,2),Ctod(""),SB2->(RecNo()),"",NIL,SD3->D3_LOCAL,0})
					EndIf

					//Lock no SC5 e SC6 antes da chamada da funcao MaLibDoFat para buscar saldo correto
					SC5->(dbSeek(xFilial("SC5")+SC6->C6_NUM))
					SC5->(Reclock("SC5"))
					SC6->(Reclock("SC6"))

					//Realiza liberacao correspondente ao apontamento recem incluido
					nLibFat := If(lLibPed .Or. (SC2->C2_QUJE == SC6->C6_QTDVEN) .And. SC2->C2_QUJE == SD3->D3_QUANT,Min(SD3->D3_QUANT,nQtdAlib),SD3->D3_QUANT)
					If ExistBlock ("A250LIB")
						nLibFat := ExecBlock("A250LIB",.F.,.F.,{nLibFat})
					EndIf
					If MaLibDoFat(SC6->(Recno()),nLibFat,.F.,.F.,.T.,.T.,NIL,NIL,NIL,NIL,aEmpPronto) > 0
						cNoLib := SC9->C9_SEQUEN
					Endif

					//Grava a sequencia incluida na tabela HW7 para utilizar no estorno
					If !EMPTY(cNoLib) .And. TableInDic("HW7")
						RecLock('HW7', .T.)
							HW7->HW7_FILIAL := xFilial("HW7")
							HW7->HW7_SEQSD3 := SD3->D3_NUMSEQ
							HW7->HW7_PEDIDO := SC9->C9_PEDIDO
							HW7->HW7_ITEM   := SC9->C9_ITEM
							HW7->HW7_SEQUEN := SC9->C9_SEQUEN
							HW7->HW7_PRODUT := SC9->C9_PRODUTO
						HW7->(MsUnlock())
					EndIf

					//Prepara aEmpPronto para reavaliacoes de liberacoes anteriores
					aEmpPronto := {}

					If nQtdaLib <> SC2->C2_QUANT

						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё O alias e passado no xFilial para garantir a abertura do SC9          Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

						cAliasQry := GetNextAlias()
						IF oSqlLogDoc == nil
							cQuery := "SELECT R_E_C_N_O_ SC9RECNO FROM " + RetSqlName( "SC9" ) + " "
							cQuery += "WHERE "
							cQuery += "C9_FILIAL='" + SC9->( xFilial( "SC9" ) ) + "' AND "
							cQuery += "C9_PEDIDO = ? AND "
							cQuery += "C9_ITEM = ? AND "
							cQuery += "C9_SEQUEN <> ? AND "
							cQuery += "C9_BLEST<>'10' AND C9_BLCRED<>'10' AND C9_BLEST<>'  ' AND "
							cQuery += "C9_BLEST<>'ZZ' AND C9_BLCRED<>'ZZ' AND C9_BLEST<>'  ' AND "
							cQuery += "D_E_L_E_T_=' '"

							cQuery := ChangeQuery( cQuery )
							oSqlLogDoc := FWPreparedStatement():New(cQuery)

						EndIf
						oSqlLogDoc:SetString(1, SC6->C6_NUM  )
						oSqlLogDoc:SetString(2, SC6->C6_ITEM  )
						oSqlLogDoc:SetString(3, cNoLib  )

						cQuery := oSqlLogDoc:GetFixQuery()
						dbUseArea( .T., "TOPCONN", TcgenQry( ,,cQuery ), cAliasQry, .F., .T. )
						TcSetField( cAliasQry, "SC9RECNO", "N", 10, 0 )
						While !(cAliasQry)->(Eof())
							dbSelectArea("SC9")
							SC9->(MsGoto((cAliasQry)->SC9RECNO))

							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Efetua a liberacao do PV                                              Ё
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							If mv_par05 == 1 .And. SC9->C9_QTDLIB <= SC2->C2_QUJE
								a450Grava( 1, .F., .T., .F. )
							ElseIf mv_par05 == 2
								aAdd(aEmpPronto,{IIf(Empty(SC9->C9_LOTECTL),SD3->D3_LOTECTL,SC9->C9_LOTECTL),SC9->C9_NUMLOTE,"","",SC9->C9_QTDLIB,SC9->C9_QTDLIB2,Ctod(""),SB2->(RecNo()),"",NIL,SC9->C9_LOCAL,0})
								a460Estorna()
							EndIf

							dbSelectArea(cAliasQry)
							(cAliasQry)->(dbSkip())
						EndDo
						For nLoop := 1 To Len(aEmpPronto)
							MaLibDoFat(SC6->(Recno()),aEmpPronto[nLoop,5],.F.,.F.,.T.,.T.,NIL,NIL,NIL,NIL,If(Rastro(SC6->C6_PRODUTO),{aEmpPronto[nLoop]},{}))
						Next nLoop
						//UnLock no SC5 e SC6 depois da chamada da funcao MaLibDoFat
						SC5->(MsUnlock())
						SC6->(MsUnlock())
					EndIf
					nAchou:=ASCAN(aPedidos,SC2->C2_PEDIDO)
					If nAchou == 0
						AADD(aPedidos,SC2->C2_PEDIDO)
					EndIf
				EndIf
			EndIf
			If oSqlLogDoc != Nil
				oSqlLogDoc:Destroy()
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Pesquisa se esta OP e' a OP original de algum      Ё
			//Ё empenho. Caso seja, grava o numero do lote e se    Ё
			//Ё necessario quebra o empenho em 2, gerando outro    Ё
			//Ё empenho com a diferenca da quantidade.             Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Rastro(SD3->D3_COD)
				dbSelectArea("SD4")
				dbSetOrder(4)
				//dbSetOrder(2)
				If dbSeek(xFilial("SD4")+SD3->D3_OP)
					Do While !Eof() .And. D4_FILIAL+D4_OPORIG == xFilial("SD4")+SD3->D3_OP

						If !fRetParPrd(SD3->D3_OP) 
							If lProdAut .And. (Localiza(SD3->D3_COD,.T.)) .And. A250OpFilha(If(l250, M->D3_OP, SH6->H6_OP))
								dbSkip()
								Loop
							EndIf
						ENDIF

						If !l680 .And. !l681 .And. lBlockSD4
							lExeAtuEmp:=ExecBlock("A250ATSD4",.F.,.F.)
							lExeAtuEmp:=If(ValType(lExeatuEmp)=="L",lExeAtuEmp,.F.)
						EndIf
						
						If Empty(IF(RASTRO(D4_COD,"S"),D4_NUMLOTE,D4_LOTECTL)) .And. (lProdAut .Or. lExeAtuEmp)
							Reclock("SD4",.F.)

							If !(fRetParPrd(SD3->D3_OP) .And. A250OpFilha(If(l250, M->D3_OP, SH6->H6_OP)) .And. SD3->D3_OP == M->D3_OP )
								Replace D4_NUMLOTE With SD3->D3_NUMLOTE
								Replace D4_LOTECTL With SD3->D3_LOTECTL
								Replace D4_DTVALID With SD3->D3_DTVALID
								Replace D4_POTENCI With SD3->D3_POTENCI
								If SD3->D3_QUANT < SD4->D4_QUANT .And. (cBxProp == "S" .And. cReqAut == "A")
									nQtdSD4Dif:=SD4->D4_QUANT - SD3->D3_QUANT
									nQtSD4Dif2:=SD4->D4_QTSEGUM - SD3->D3_QTSEGUM
									Replace D4_QUANT	With SD3->D3_QUANT
									Replace D4_QTSEGUM 	With SD3->D3_QTSEGUM
									//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Ativa flag para criar empenho da diferenca apos baixar    Ё
									//Ё empenho corrente.                                         Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									lCriaDif := (GetMV("MV_CRIADIF")=="S")
									//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Retira do empenho no SB2 a diferenca                      Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									If !lCriaDif
										dbSelectArea("SB2")
										MsSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL)
										If EOF()
											CriaSB2(SD4->D4_COD,SD4->D4_LOCAL)
										EndIf
										if !SB2->(DBRLock()) .and. (l250Auto .OR. l681Auto .OR.l680Auto ) .and. ( cPcpPend == '2' .OR. cPcpPend == '3'.OR. cPcpPend == '4') // VERIFICA se o produto estА locado em outro processamento ( respeitar parБmetro cPcpPend)
											lRet := .F.
											return lRet
										endif
										Replace B2_QEMP  With B2_QEMP  - nQtdSD4Dif
										Replace B2_QEMP2 With B2_QEMP2 - nQtSD4Dif2
										SB2->(MsUnlock())

										dbSelectArea("SD4")
									EndIf
									//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Salva a integridade dos campos de Bancos de Dados         Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									If Len(aCriaDIF[Len(aCriaDIF)]) > 4095
										AADD(aCriaDIF,{})
									EndIf
									aCamposDif:={}
								
									FOR i := 1 TO FCount()
										If Alltrim(FieldName(i)) == "D4_QUANT"
											AADD(aCamposDif,nQtdSD4Dif)
										ElseIf Alltrim(FieldName(i)) == "D4_QTSEGUM"
											AADD(aCamposDif,nQtSD4Dif2)
										ElseIf Alltrim(FieldName(i)) == "D4_QTDEORI"
											AADD(aCamposDif,nQtdSD4Dif)
										ElseIf Alltrim(FieldName(i)) $ "D4_NUMLOTE/D4_LOTECTL/D4_DTVALID/D4_POTENCI"
											AADD(aCamposDif,CriaVar(FieldName(i)))
										Else
											AADD(aCamposDif,FieldGet(i))
										EndIf
									NEXT i
									AADD(aCriaDIF[Len(aCriaDIF)],{SD4->(Recno()),nQtdSD4Dif,aCamposDif})
								EndIf
							ENDIF

							GravaEmp(	SD4->D4_COD,;
							SD4->D4_LOCAL,;
							SD4->D4_QUANT,;
							SD4->D4_QTSEGUM,;
							SD4->D4_LOTECTL,;
							SD4->D4_NUMLOTE,;
							NIL,;
							NIL,;
							SD4->D4_OP,;
							SD4->D4_TRT,;
							NIL,;
							NIL,;
							"SC2",;
							SD4->D4_OPORIG,;
							NIL,;
							@aTravas,;
							.F.,;
							NIL,;
							.F.,;
							.F.,;
							NIL,;
							.T.,;
							.T.,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							SD3->D3_EMISSAO)

                            //здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Grava o D3_TRT de acordo com D4_TRT                      Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							RecLock('SD3',.F.)
							SD3->D3_TRT := SD4->D4_TRT
							SD3->(MsUNlock())				

							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Remove travas dos registros utilizados                  Ё
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							MaDesTrava(aTravas)
							Exit
						EndIf
						dbSelectArea("SD4")
						dbSkip()
					EndDo
				EndIf
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Grava os lancamentos nas contas orcamentarias SIGAPCO    Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If SD3->D3_TM <= "500"
				PcoDetLan("000152","01","MATA250")
			Else
				PcoDetLan("000152","02","MATA250")
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se o custo medio e' calculado On-Line               Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If cCusMed == "O"
				// Grava os registros que estarЦo com o cСdigo do documento contabil relacionado (Correlativo)
				If ( UsaSeqCor() ) .AND. Type("aCtbDia") == "A"
					aAdd(aCtbDia,{"SD3",SD3->(RECNO()),"","D3_NODIA","D3_DIACTB"})
				Else
					aCtbDia := {}
				EndIF
				If SubStr(SD3->D3_CF,3,1) != "2"
					If SD3->D3_TM <= "500"
						//зддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Gera o lancamento no arquivo de prova           Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддды
						nTotal+=DetProva(nHdlPrv,"668","MATA250",cLoteEst)
					Else
						//зддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Gera o lancamento no arquivo de prova           Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддды
						nTotal+=DetProva(nHdlPrv,"666","MATA250",cLoteEst)
					EndIf
				Else
					If SD3->D3_TM <= "500"
						//зддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Gera o lancamento no arquivo de prova           Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддды
						nTotal+=DetProva(nHdlPrv,"679","MATA250",cLoteEst)
					Else
						//зддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Gera o lancamento no arquivo de prova           Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддды
						nTotal+=DetProva(nHdlPrv,"680","MATA250",cLoteEst)
					EndIf
				EndIf
			EndIf

			If lIntNewMRP
				A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Caso  a producao seja total e o parametro de digitacao de    Ё
			//Ё requisicoes estiver "D", encerra a OP.                       Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lProdTot .And. (cReqAut == "D" .Or. SF5->F5_ATUEMP == "N")
				A250End(.F., .T., @aMRPxJson)
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Chama integraГЦo com novo MRP                                Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lIntNewMRP .And. lIntLocal
				MATA650INT("INSERT", aMRPxJson[1])
				aSize(aMRPxJson[1], 0)
				FreeObj(aMRPxJson[2])
				aMRPxJson[2] := Nil
				If lDelTBMRP
					_lNewMRP := Nil
				EndIf
			EndIf

			dbSelectArea("SD3")

			/*
			Issue: DMANSMARTSQUAD1-13239
			Ticket: 5661790
			Foi alinhado com a equipe de Custos sobre o rateio no Encerramento da OP
			e o rateio nЦo deve ser feito no MATA250.
			Por esse motivo estamos retirando o rateio do MATA250. Qualquer dЗvida referente ao processo
			de Custos deve ser tratado com a equipe de Custos.
			O alinhamento com a equipe de Custos estА na issue DMANSMARTSQUAD1-13239.
			*/
			/*
			If lProdTot

				dbSelectArea("SC2")
				Replace C2_DATRF With dEmissao
				dbSelectArea("SHD")
				dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
				While !Eof() .And. HD_OP == SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
					RecLock("SHD",.F.)
					Replace HD_DATRF With dEmissao
					dbSkip()
				End
				dbSelectArea("SC2")


				//здддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza Valores Rateados                  Ё
				//юдддддддддддддддддддддддддддддддддддддддддддды
				If nProdProp == 3
					aAreaSD3En := SD3->(GETAREA())
					aAreaSC2En := SC2->(GETAREA())

					DbSelectArea("SC2")
					SC2->(DbSetOrder(1))
					SC2->(dbGoTop())
					SC2->(dbSeek(xFilial("SC2")+cNumOP))

					//Busca valor total das requisiГУes
					nCusto := 0
					DbSelectArea("SD3")
					SD3->(DbSetOrder(1))
					SD3->(dbGoTop())
					SD3->(dbSeek(xFilial("SD3")+cNumOP))
					While !Eof() .And. SD3->D3_FILIAL+SD3->D3_OP == xFilial("SD3")+cNumOP
						If (SD3->D3_CF $ "PR0/PR1") .Or. SD3->D3_ESTORNO == "S"
							SD3->(dbSkip())
							loop
						EndIf

						If SD3->D3_CUSTO1 > 0
							nCusto += SD3->D3_CUSTO1
						EndIf
						SD3->(dbSkip())
					EndDo

					//Rateia o valor total das requisiГУes entre todas produГУes
					//Busca valor total das requisiГУes
					If nCusto > 0
						DbSelectArea("SD3")
						SD3->(DbSetOrder(1))
						SD3->(dbGoTop())
						SD3->(dbSeek(xFilial("SD3")+cNumOP))
						While !Eof() .And. SD3->D3_FILIAL+SD3->D3_OP == xFilial("SD3")+cNumOP
							If (!(SD3->D3_CF $ "PR0/PR1")) .Or. SD3->D3_ESTORNO == "S"
								SD3->(dbSkip())
								loop
							EndIf

							SD3->(Reclock("SD3",.F.))
							Replace SD3->D3_CUSTO1  With (nCusto * (SD3->D3_QUANT/SC2->C2_QUJE))
							SD3->(MsUNlock())

							SD3->(dbSkip())
						EndDo
					EndIf

					SD3->(RestArea(aAreaSD3En))
					SC2->(RestArea(aAreaSC2En))
				EndIf
			EndIf
			*/

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Integracao com o ACD - Impressao das Etiquetas dos PA's no  	   Ё
			//Ё apontamento da producao e baixa da requisicao do D4_EMPROC		   Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lIntACD .And. FindFunction("CBSD3250I")
				CBSD3250I()
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Pontos de Entrada 										     Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			ElseIf lSD3250ITE
				ExecTemplate("SD3250I",.F.,.F.)
			EndIf

			//SIGAACD - Atualiza endereco/n. serie na etiqueta
			If lFoiProCQ .And. Localiza(SD3->D3_COD) .And. !Empty(GetMV("MV_DISTAUT")) .And. UsaCB0("01")
				CBOPDistAut(SD3->D3_COD,SD3->D3_OP,SD3->D3_NUMSEQ)
			EndIf

			If lSD3250I
				ExecBlock("SD3250I",.F.,.F.)
			EndIf

			Set(3, nDecAnt)
		EndIf
	EndIf
Return .T.

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250DesAtuЁ Autor Ё Claudinei M. Benzi    Ё Data Ё 23/06/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de estorno das atualizacoes (SD3,SB2,SB3,SC2,...) Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250/MATA680                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250DesAtu(lLiberOP, aBaixaSGF, aCtbDia, lOnlyComp, cOrdemPai, aMRPxJson)
	Static lSD3250E
	Static lEstProd

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Tamanho do array dos custos. Esta variavel foi criada para   Ё
	//Ё tornar mais facil a atualizacao do programa da Wiily Dresser.Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local aArea:=GetArea()
	Local nTamArrCus := 5
	Local nQuant:=0,cMes,nRecPai:=0,aRegistros:={{}},nX,nY,nz,nQuantPorig:=0
	Local nQuantOrig:=0,nQuant2um:=0,nRegSD4:=0,nDif:=0,nBaixa:=0
	Local aCustoI[nTamArrCus],aCustoD[nTamArrCus],aC2Vatu[nTamArrCus],aCusto[nTamArrCus],aCustoTot[nTamArrCus]
	Local bCampo     := {|nCPO| Field(nCPO) }
	Local cLocProc   := GetMvNNR('MV_LOCPROC','99')
	Local cNumSeq    :="",cOP:="",cOpOrig:=""
	Local nRecSD3    := SD3->(Recno())
	Local cLocCQ     := GetMvNNR('MV_CQ','98')
	Local cSeekSD7   :=""
	Local cSeekSD4   :=""
	Local cCompSD4   :=""
	Local lGeraDEV   := .F. // Flag criado para item negativo da estrutura
	Local aAreaSH6   := {}
	Local aAreaAnt   := {}
	Local cOperSH6   := ''
	Local nTamSX1    := Len(SX1->X1_GRUPO)
	Local lConsReal  := .F.
	Local L250Status := .T.
	Local cQuery     := ""
	Local cAliasD3   := ""
	Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local lWmsSD3    := IIf(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local a
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas qdo usa localizacao fisica              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local cSeek:="",cCompara:=""
	Local nSaldo:=0
	Local nPosEst:=0
	Local lContinua  := .F.
	Local lFinaliza	 := .F.
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas para ajuste do b2_salped                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local	nQtdC2:=0,nQtdD3:=0,nQtde:=0

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas para ajuste de lote/sublote SD4         Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lLLoteD4   := .F.
	Local lEstAuto   := .T.
	Local lnMovEst   := .F.
	Local lUsaB8Emp  := .F.

	Local lBlqApon   := SC2->(ColumnPos("C2_BLQAPON"))
	Local lVldTpArr  := Iif(Type("aAtuSD3") == "A",.T.,.F.)
	Local ld3kLimp	 := Findfunction('MatLimpD3K')
	Local cPerBlk    := ""

	Local lDelTBMRP  := _lNewMRP == NIL
	Local lIntLocal  := aMRPxJson == NIL
	Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)

	Local lBxComp    := .F.
	Local nIndPerAnt := 0
	Local nQtdAjtPer := 0

	Local cAliasQry := GetNextAlias()
	Local cCQ		:= GetMvNNR('MV_CQ','98')
	
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel utilizada para controlar qdo deve liberar OP para   Ё
	//Ё producao apos estorno de apontamento parcial.                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	lLiberOP:=IIF(lLiberOP==NIL,.F.,lLiberOP)

	Default aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP
	Default lOnlyComp  := .F.
	Default aCtbDia    := {}
	Default cOrdemPai  := Nil
	Default lAbreOP    := .T.

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(SD3->D3_OP) )

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se eh producao automatica e requisicao automatica para Ё
	//Ё permitir atualizar a varivel que permitira ou nao limpar o lote Ё
	//Ё Atencao: Valido somente para estorno, e considerando que a per- Ё
	//Ё          gunte nao foi alterada pelo operador                   Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lProdAut .And. A250ReqAut(GetMV("MV_REQAUT")) == "A"
		SX1->( DbSetOrder(1) )
		If SX1->( MsSeek(PADR("MTA650",nTamSX1)+"08")  .And. SX1->X1_PRESEL == 2 )
			lLLoteD4 := .T.
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada SD3250E            Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lSD3250E == NIL
		lSD3250E := ExistBlock("SD3250E")
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se estorna todos os movimentos ou somente a producao   Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lEstProd == NIL
		lEstProd := GetMV("MV_ESTPROD") == 1
	EndIf

	If Type("aRotAuto") <> "U"
		If aScan(aRotAuto,{|x| x[1] == "ABREOP"})>0
			nPosEst:=aScan(aRotAuto,{|x| x[1] == "ABREOP"})
			If aRotAuto[nPosEst][2]<>"S"
				lEstAuto:=.F.
			Endif
		Endif
	Endif

	AFILL(aCustoI,0)
	AFILL(aCustoD,0)
	AFILL(aC2Vatu,0)
	AFILL(aCusto,0)
	AFILL(aCustoTot,0)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o custo medio e' calculado On-Line               Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If cCusMed == "O"
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se necessario cria o cabecalho do arquivo de prova           Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lCriaHeader
			lCriaHeader := .F.
			nHdlPrv := HeadProva(cLoteEst,"MATA250",Subs(cUsuario,7,6),@cArquivo)
			If nHdlPrv <= 0
				dbSelectArea("SD3")
				lFinaliza := .T. // O Return final eh .T.
			EndIf
		EndIf
	EndIf

	SF5->(MsSeek(xFilial("SF5")+SD3->D3_TM))
	If !lFinaliza
		If !lOnlyComp
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Inicializa a gravacao dos lancamentos do SIGAPCO          Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			PcoINILan("000152")

			//здддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Variavel para gravar demanda no mes corretoЁ
			//юдддддддддддддддддддддддддддддддддддддддддддды
			cMes := "B3_Q"+StrZero(Month(dDataBase),2)

			If aBaixaSGF == NIL

				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza o campo D3_ESTORNO                        Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				RecLock("SD3",.F.)
				Replace D3_ESTORNO With "S"
				If Type("aRotAuto") <> "U"
					If (nPos := aScan(aRotAuto,{|x| x[1] == "ABREOP"})) > 0
						If aRotAuto[nPos][2] == Nil
							Replace D3_ESTORNO With " "
						EndIf
					EndIf
				Endif
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Salva a integridade dos campos de Bancos de Dados            Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				FOR nX := 1 TO FCount()
					If !("B1_DESC" $ Field(nX))
						M->&(EVAL(bCampo,nX)) := FieldGet(nX)
					EndIf
				NEXT nX

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Cria o registro de estorno com mesmos dados do original      Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				RecLock("SD3",.T.)
				For nX := 1 TO FCount()
					If !("B1_DESC" $ Field(nX))
						FieldPut(nX,M->&(EVAL(bCampo,nX)))
					EndIf
				Next nX
				Replace D3_TM With "999",D3_CF With "ER0"
				If SD3->(FieldPos("D3_PERBLK")) > 0
					cPerBlk := D3_PERBLK
					Replace D3_PERBLK With PADR(Nil,tamSX3('D3_PERBLK')[1])
				EndIf
				Replace D3_CHAVE With SubStr(D3_CF,2,1)+IIF(D3_CF=="DE4","9","0")

				SD3->(MsUnLock())
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Estorna Amarracao com producoes de terceiros MATA037    	   Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If ld3kLimp
					MatLimpD3K(D3_COD,D3_NUMSEQ)
				EndIF
				nRecPai := RecNo()

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//ЁEstorna CQ (Deleta os Registros no SD7)                         Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If alltrim(SD3->D3_LOCAL) == alltrim(cLocCQ)
					SD7->(dbSetOrder(3))
					If SD7->(dbSeek(xFilial('SD7')+SD3->D3_COD+SD3->D3_NUMSEQ, .F.)) .And. SD7->D7_ORIGLAN == 'PR'
						cSeekSD7 := xFilial('SD7')+SD7->D7_NUMERO+SD7->D7_PRODUTO
						dbSelectArea('SD7')
						dbSetOrder(1)
						dbSeek(cSeekSD7, .F.)
						Do While !Eof() .And. cSeekSD7 == D7_FILIAL + D7_NUMERO + D7_PRODUTO
							RecLock('SD7', .F.)
							dbDelete()
							MsUnlock()
							dbSkip()
						EndDo
						dbSelectArea('SD3')
					EndIf
				EndIf

				//Estorna liberaГЦo do pedido
				If TableInDic("HW7")
					dbSelectArea("SC6")
					dbSetOrder(1)
					If dbSeek(xFilial("SC6")+SC2->C2_PEDIDO+SC2->C2_ITEMPV)
						If !Localiza(SD3->D3_COD,.T.) .And. (SD3->D3_LOCAL != cCQ) .And. ;
							(SF5->F5_LIBPVPR == "S") .And. (!Empty(SC2->C2_PEDIDO) .And. ;
							!Empty(SC2->C2_ITEMPV)) .And. Empty(SC6->C6_QTDRESE)
				
							//Lock no SC5 e SC6 antes da chamada da funcao a460Estorna para buscar saldo correto
							SC5->(dbSeek(xFilial("SC5")+SC6->C6_NUM))
							SC5->(Reclock("SC5"))
							SC6->(Reclock("SC6"))
				
							cQuery := " SELECT SC9.R_E_C_N_O_ SC9RECNO "
							cQuery += "   FROM " + RetSqlName( "SC9" ) + " SC9, " + RetSqlName( "HW7" ) + " HW7 "
						    cQuery += "  WHERE SC9.C9_FILIAL  = '" + xFilial('SC2') + "' " 
							cQuery += "    AND SC9.C9_PEDIDO  = '" + SC6->C6_NUM + "' " 
							cQuery += "    AND SC9.C9_ITEM    = '" + SC6->C6_ITEM + "' " 					
						    cQuery += "    AND SC9.D_E_L_E_T_ = ' '"
							cQuery += "    AND HW7.HW7_FILIAL = '" + xFilial('HW7') + "' " 
							cQuery += "    AND HW7.HW7_SEQSD3 = '" +  SD3->D3_NUMSEQ + "' " 
							cQuery += "    AND HW7.HW7_PEDIDO = SC9.C9_PEDIDO "
							cQuery += "    AND HW7.HW7_ITEM   = SC9.C9_ITEM "
							cQuery += "    AND HW7.HW7_SEQUEN = SC9.C9_SEQUEN "
							cQuery += "    AND HW7.HW7_PRODUT = SC9.C9_PRODUTO "
							cQuery += "    AND HW7.D_E_L_E_T_ = ' ' "

							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
							cQuery := ChangeQuery( cQuery )

							If !(cAliasQry)->(Eof())									
								dbSelectArea("SC9")
								SC9->(MsGoto((cAliasQry)->SC9RECNO))

								a460Estorna()
							EndIf
	
							//UnLock no SC5 e SC6 depois da chamada da funcao MaLibDoFat
							SC5->(MsUnlock())
							SC6->(MsUnlock())
						EndIf
					EndIf
				EndIf
	
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//ЁEstorna Lotes                                                   Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Rastro(SD3->D3_COD)
					dbSelectArea("SD4")
					dbSetOrder(4)
					// VERIFICA SE JA EXISTE UM REGISTRO SEM LOTE
					nRegSD4:=0
					dbSeek(xFilial("SD4")+SD3->D3_OP+CriaVar("D4_LOTECTL")+CriaVar("D4_NUMLOTE"))
					While !Eof() .And. D4_FILIAL+D4_OPORIG+D4_LOTECTL+D4_NUMLOTE == xFilial("SD4")+SD3->D3_OP+CriaVar("D4_LOTECTL")+CriaVar("D4_NUMLOTE")
						If SD3->D3_TRT == D4_TRT
							nRegSD4:=Recno()
							Exit
						EndIf
						dbSkip()
					End
					
					// VERIFICA SE JA EXISTE UM REGISTRO PARA O LOTE E QUANTIDADE
					lExistQtd := .F.
					If fRetParPrd(SD3->D3_OP) 
						dbSeek(xFilial("SD4")+SD3->D3_OP+SD3->D3_LOTECTL+SD3->D3_NUMLOTE)
						While !Eof() .And. D4_FILIAL+D4_OPORIG+D4_LOTECTL+D4_NUMLOTE == xFilial("SD4")+SD3->D3_OP+SD3->D3_LOTECTL+SD3->D3_NUMLOTE
							If SD3->D3_TRT == SD4->D4_TRT .And. SD3->D3_QUANT == SD4->D4_QTDEORI
								lExistQtd := .T.
								RecLock("SD4",.F.)
								cOPOrig := SD4->D4_OPORIG
								nQuant	 :=SD4->D4_QUANT
								nQuantOrig:=SD4->D4_QTDEORI
								nQuant2UM :=SD4->D4_QTSEGUM
								// CASO NAO ENCONTRE OUTRO REGISTRO SEM LOTE MUDA OS DADOS DO REGISTRO CORRENTE
								If nRegSD4 == 0
									Replace	D4_NUMLOTE With CriaVar("D4_NUMLOTE"),;
									D4_LOTECTL With CriaVar("D4_LOTECTL"),;
									D4_DTVALID With CriaVar("D4_DTVALID"),;
									D4_POTENCI With Criavar("D4_POTENCI")
									MsUnlock()
								Else
									// APAGA O MOVIMENTO EM QUESTAO
									dbDelete()
									MsUnlock()
									// ALTERA OS DADOS DO REGISTRO JA EXISTENTE
									MsGoto(nRegSD4)
									RecLock("SD4",.F.)
									Replace D4_QUANT With D4_QUANT + nQuant
									Replace D4_QTDEORI With D4_QTDEORI + nQuantOrig
									Replace D4_QTSEGUM With D4_QTSEGUM + nQuant2um
									MsUnlock()
								EndIf
								Exit
							EndIf
							dbSkip()
						End
					ENDIF

					If !lExistQtd
						dbSeek(xFilial("SD4")+SD3->D3_OP+SD3->D3_LOTECTL+SD3->D3_NUMLOTE)
						While !Eof() .And. D4_FILIAL+D4_OPORIG+D4_LOTECTL+D4_NUMLOTE == xFilial("SD4")+SD3->D3_OP+SD3->D3_LOTECTL+SD3->D3_NUMLOTE
							If SD3->D3_TRT == D4_TRT
								RecLock("SD4",.F.)
								cOPOrig := SD4->D4_OPORIG
								nQuant	 :=SD4->D4_QUANT
								nQuantOrig:=SD4->D4_QTDEORI
								nQuant2UM :=SD4->D4_QTSEGUM
								// CASO NAO ENCONTRE OUTRO REGISTRO SEM LOTE MUDA OS DADOS DO REGISTRO CORRENTE
								If nRegSD4 == 0
									Replace	D4_NUMLOTE With CriaVar("D4_NUMLOTE"),;
									D4_LOTECTL With CriaVar("D4_LOTECTL"),;
									D4_DTVALID With CriaVar("D4_DTVALID"),;
									D4_POTENCI With Criavar("D4_POTENCI")
									MsUnlock()
								Else
									// APAGA O MOVIMENTO EM QUESTAO
									dbDelete()
									MsUnlock()
									// ALTERA OS DADOS DO REGISTRO JA EXISTENTE
									MsGoto(nRegSD4)
									RecLock("SD4",.F.)
									Replace D4_QUANT With D4_QUANT + nQuant
									Replace D4_QTDEORI With D4_QTDEORI + nQuantOrig
									Replace D4_QTSEGUM With D4_QTSEGUM + nQuant2um
									MsUnlock()
								EndIf
								Exit
							EndIf
							dbSkip()
						End
					EndIf 
					dbSelectArea("SD3")
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Pega o custo da movimentacao               Ё
				//юдддддддддддддддддддддддддддддддддддддддддддды
				aCusto := PegaCusD3()

				//здддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza arquivo de saldos em estoque do Pai Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддды
				dbSelectArea("SC2")
				dbSetOrder(1)
				If (lContinua := dbSeek(xFilial("SC2")+Alltrim(SD3->D3_OP)))
					dbSelectArea("SB2")
					If !SB2->(DbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL))
						CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
					EndIf

					If SC2->(C2_QUJE > C2_QUANT)
						nQtde := Max(0,SD3->D3_QUANT-(SC2->C2_QUJE-SC2->C2_QUANT))
					Else
						nQtdC2:= Min(SC2->C2_QUANT,SC2->C2_QUJE)+If(lPerdInf,0,SC2->C2_PERDA)
						//nQtdD3:= Min(SD3->D3_QUANT + If(lPerdInf,0,SD3->D3_PERDA), SC2->C2_QUANT - (SC2->C2_QUJE - SD3->(D3_QUANT+If(lPerdInf,0,D3_PERDA))))
						nQtdD3:= Min(((SD3->D3_QUANT + If(lPerdInf,0,SD3->D3_PERDA))- SD3->D3_QTGANHO - SD3->D3_QTMAIOR), SC2->C2_QUANT - (SC2->C2_QUJE - SD3->(D3_QUANT+If(lPerdInf,0,D3_PERDA))))
						nQtde := Min(nQtdC2,nQtdD3)
					EndIf
					L250Status := A250Status(Alltrim(SD3->D3_OP), SD3->D3_NUMSEQ)
					If(labreOP, GravaB2Pre("+",nQtde,SC2->C2_TPOP), .F.)
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Atualiza os arquivos do SIGAPMS                              Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					// utiliza a requisiГЦo automАtica de produto?
					If GetNewPar("MV_PMSPREQ", "1") == "1" .And. !Localiza(SD3->D3_COD,.T.)
						A250PmsReq(Alltrim(SD3->D3_OP),2)
					EndIf
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Estorna SBC caso o MV_DIGIPER estja igual a "S"       Ё
					//Ё e exista perda de OP.                                 Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If !Empty(SD3->D3_PERDA)
						A250EstSBC(SD3->D3_OP,SD3->D3_NUMSEQ)
					EndIf

					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Atualiza o saldo atual (VATU) com os dados do SD3     Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If lProdAut .And. !Empty(cOrdemPai)
						If cOrdemPai == SD3->D3_OP
							lUsaB8Emp := .F.
						Else
							lUsaB8Emp := .T.
						EndIf
					Else
						lUsaB8Emp := .F.
					EndIf
					
					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Gera devolucoes automaticas                Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					nDif:=SC2->C2_QUANT-If(lPerdInf,0,SC2->C2_PERDA)-SC2->C2_QUJE
					RecLock("SC2",.F.)
					Replace C2_QUJE  With C2_QUJE  - SD3->D3_QUANT
					Replace C2_PERDA With C2_PERDA - SD3->D3_PERDA
					If lBlqApon
						Replace C2_BLQAPON With '2'
					EndIf
					IF !EMPTY(SC2->C2_DATRF)
						lLiberOP:= .T.
					EndIf
					
					If  lAbreOp 
						// Caso tenha quantidade pendente no campo B2_SALPEDI
						If nDif > 0 .And. !Empty(SC2->C2_DATRF)
							GravaB2Pre("+",nDif,SC2->C2_TPOP)
						EndIf
						dbSelectArea("SC2")
						Replace C2_DATRF With Ctod("  /  /  ")
						If C2_STATUS == "S"
							dbSelectArea("SHD")
							dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
							While !Eof() .And. HD_FILIAL+HD_OP == xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
								RecLock("SHD",.F.)
								Replace HD_DATRF With Ctod("  /  /  ")
								dbSkip()
							End
							dbSelectArea("SC2")
						EndIf
						If SD3->D3_PARCTOT # "T"
							dbSelectArea("SD3")
							dbSetOrder(1)
							nRecSD3:=Recno()
							dbSeek(xFilial("SD3")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
							While !Eof() .And. D3_FILIAL+D3_OP == xFilial("SD3")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
								If D3_ESTORNO # "S"
									RecLock("SD3",.F.)
									Replace D3_PARCTOT With "P"
									MsUnlock()
								EndIf
								dbSkip()
							EndDo
							MsGoto(nRecSD3)
							dbSelectArea("SC2")
						EndIf
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Retorna o Status das Producoes Mod.II para "Parcial" Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If l681 .And. SH6->H6_PT == 'P'
							aAreaAnt   := GetArea()
							aAreaSH6   := SH6->(GetArea())
							cOperSH6   := SH6->H6_OPERAC
							dbSelectArea('SH6')
							dbSetOrder(3) //-- H6_FILIAL+H6_PRODUTO+H6_OP+H6_OPERAC+H6_LOTECTL+H6_NUMLOTE
							If dbSeek(cSeekH6:=xFilial('SH6')+SC2->C2_PRODUTO+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD+cOperSH6, .F.)
								Do While !Eof() .And. cSeekH6 == H6_FILIAL+H6_PRODUTO+H6_OP+H6_OPERAC
									If !(H6_PT=='P') //-- Existe somente 1 Producao Totalizada por Operacao
										RecLock('SH6', .F.)
										Replace H6_PT With 'P'
										MsUnlock()
										Exit
									EndIf
									dbSkip()
								EndDo
							EndIf
							RestArea(aAreaSH6)
							RestArea(aAreaAnt)
						EndIf
					EndIf

					B2AtuComD3(aCusto,,,,,.T.,,,,,,,,,,,,,,,,,,Empty(cOPOrig),,,,,,,,,,,lUsaB8Emp)

				EndIf
				If lIntNewMRP
					A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
				EndIf
			EndIf

			If !lContinua .And. aBaixaSGF # NIL
				dbSelectArea("SC2")
				dbSetOrder(1)
				If (lContinua := dbSeek(xFilial("SC2")+Alltrim(SH6->H6_OP)))
					dbSelectArea("SB2")
					MsSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL)
					If EOF()
						CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
					EndIf
				EndIf

				If IsInCallStack("MATA680") .Or. IsInCallStack("MATA681")
					dbSelectArea("SBC")
					If SBC->(FieldPos("BC_IDENSH6")) > 0
						If SuperGetMv("MV_DIGIPER")== "S"
							lnMovEst := .F.
							dbSelectArea("SD3")
							dbSetOrder(1)
							dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)
							Do While !Eof() .And. SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD == xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO .And. SD3->D3_IDENT == SH6->H6_IDENT
								If !SD3->D3_ESTORNO == "S"
									lnMovEst := .T.
								EndIf
								dbSkip()
							EndDo

							If lnMovEst == .F.
								dbSelectArea("SBC")
								dbSetOrder(1)
								dbGotop()
								If dbSeek(xFilial("SBC")+SH6->H6_OP)
									Do While !Eof() .And. SBC->BC_FILIAL+SBC->BC_OP == xFilial("SBC")+SH6->H6_OP
										If SBC->BC_FILIAL+SBC->BC_OP+SBC->BC_IDENSH6 == xFilial("SBC")+SH6->H6_OP+SH6->H6_IDENT
											A250EstSBC(SH6->H6_OP,SBC->BC_NUMSEQ)
										EndIf
										dbSkip()
									EndDo
								EndIF
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Pega o numero do registro de cada requisicao automatica gerada Ё
		//Ё para poder gerar uma devolucao                                 Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lEstProd .And. (lContinua .Or. lOnlyComp)
			If lOnlyComp
				//здддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Variavel para gravar demanda no mes corretoЁ
				//юдддддддддддддддддддддддддддддддддддддддддддды
				cMes := "B3_Q"+StrZero(Month(dDataBase),2)
			EndIf

			dbSelectArea("SD3")

			If (IsInCallStack("MATI681") .Or. (l681 .And. AllTrim(SH6->H6_OBSERVA)=="TOTVSMES")) .And. PCPIntgPPI()
				SOE->(dbSeek(xFilial("SOE")+"SC2"))
				If SOE->(FieldPos("OE_VAR1")) > 0 .And. (AllTrim(SOE->OE_VAR1) == "2" .Or. AllTrim(SOE->OE_VAR1) == "3")
					lConsReal := .T.
				EndIf
			EndIf

			If lConsReal .Or. lOnlyComp
				cQuery := " SELECT R_E_C_N_O_ D3REC "
				cQuery +=   " FROM " + RetSqlName("SD3") + " SD3 "
				cQuery +=  " WHERE SD3.D3_FILIAL  = '" + xFilial("SD3") + "' "
				cQuery +=    " AND SD3.D_E_L_E_T_ = ' ' "
				cQuery +=    " AND SD3.D3_IDENT   = '" + SH6->H6_IDENT + "' "
				cQuery +=    " AND SD3.D3_OP      = '" + SH6->H6_OP + "' "

				cQuery := ChangeQuery(cQuery)

				cAliasD3 := GetNextAlias()

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasD3,.T.,.T.)

				While (cAliasD3)->(!Eof())
					SD3->(dbGoTo((cAliasD3)->(D3REC)))

					If !(Subs(SD3->D3_CF,1,1) $ "RD") .Or. SD3->D3_ESTORNO == "S"
						(cAliasD3)->(dbSkip())
						Loop
					EndIf

					If Len(aRegistros[Len(aRegistros)]) > 4095
						AADD(aRegistros,{})
					EndIf
					AADD(aRegistros[Len(aRegistros)],{SD3->(RecNo()),Subs(SD3->D3_CF,1,1),SD3->D3_NUMSEQ,SD3->D3_COD,SD3->D3_QUANT})

					(cAliasD3)->(dbSkip())
				EndDo
				(cAliasD3)->(dbCloseArea())
			Else
				If aBaixaSGF # NIL
					cNumSeq:=SH6->H6_IDENT
					cOp:=Alltrim(SH6->H6_OP)
					dbSelectArea("SD3")
					dbSetOrder(4)
					dbSeek(cSeek := xFilial("SD3")+cNumSeq)
				Else
					cNumSeq:=SD3->D3_NUMSEQ
					cOp:=Alltrim(SD3->D3_OP)
					dbSelectArea("SD3")
					dbSetOrder(4)
					dbSeek(cSeek := xFilial("SD3")+cNumSeq)
				EndIf

				While !Eof() .And. D3_FILIAL + D3_NUMSEQ == cSeek
					If !(Subs(D3_CF,1,1) $ "RD") .Or. D3_ESTORNO == "S" .Or. Alltrim(D3_OP) # cOp
						dbSkip()
						Loop
					EndIf
					If aBaixaSGF # NIL .And. aScan(aBaixaSGF, {|z| SD3->(D3_COD + D3_TRT) == z[1] + z[2]}) == 0
						dbSkip()
						Loop
					EndIf
					If Len(aRegistros[Len(aRegistros)]) > 4095
						AADD(aRegistros,{})
					EndIf
					AADD(aRegistros[Len(aRegistros)],{RecNo(),Subs(D3_CF,1,1),D3_NUMSEQ,D3_COD,D3_QUANT})
					dbSkip()
				EndDo
			EndIf

			For nX := 1 To Len(aRegistros)
				For nz:=1 to Len(aRegistros[nx])
					dbSelectArea("SD3")
					MsGoTo(aRegistros[nX,nz,1])

					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Posiciona na tabela SB1                    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					SB1->(dbSetorder(1))
					SB1->(MsSeek(xFilial("SB1")+SD3->D3_COD))

					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Grava o Flag de estorno                    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					RecLock("SD3",.F.)
					Replace D3_ESTORNO With "S"
					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Grava o Flag de estorno                    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					If lContinua .And. ld3kLimp
						MatLimpD3K(aRegistros[nX,nz,4],aRegistros[nX,nz,3])
					EndIf
					If SD3->(FieldPos("D3_PERBLK")) > 0
						//Se nЦo estiver em Lock, trava para alteraГЦo novamente
						If aScan(SD3->(DBRLockList()), {|x| x == SD3->(RECNO()) }) == 0
							RecLock("SD3",.F.)
						EndIf
						Replace D3_PERBLK With cPerBlk
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Salva a integridade dos campos de Bancos de Dados            Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					FOR nY := 1 TO FCount()
						M->&(EVAL(bCampo,nY)) := FieldGet(nY)
					NEXT nY
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Cria o registro de estorno com mesmos dados do original      Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					lGeraDev:=.F.
					RecLock("SD3",.T.)
					For nY := 1 TO FCount()
						FieldPut(nY,M->&(EVAL(bCampo,nY)))
					Next nY

					If aRegistros[nx,nz,2] == "R" .And. lEstAuto
						Replace D3_TM With "499",D3_CF With "DE"+SubStr(M->D3_CF,3,1)
						Replace D3_CHAVE With SubStr(D3_CF,2,1)+IIF(D3_CF=="DE4","9","0")
						Replace D3_USUARIO With CUSERNAME
						nQuant := SD3->D3_QUANT
					Else
						Replace D3_TM With "999",D3_CF With "RE"+SubStr(M->D3_CF,3,1)
						Replace D3_CHAVE With SubStr(D3_CF,2,1)+IIF(D3_CF=="DE4","9","0")
						Replace D3_USUARIO With CUSERNAME
						nQuant := - SD3->D3_QUANT
					EndIf

					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Grava o Flag de estorno                    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					If ld3kLimp
						MatLimpD3K(aRegistros[nX,nz,4],aRegistros[nX,nz,3])
					EndIf
					aRegistros[nX,nz,1]:=Recno()

					If lVldTpArr
						aAdd(aAtuSD3,aRegistros[nX,nz,1])
					EndIf

					If IsProdCoPR(SD3->D3_COD,SD3->D3_OP,SD3->D3_TRT) //-- Item negativo desconsidera lote pois empenho nao te
						cSeekSD4   :=xFilial("SD4")+SD3->D3_COD+SD3->D3_OP+SD3->D3_TRT
						cCompSD4   :="D4_FILIAL+D4_COD+D4_OP+D4_TRT"
					Else
						cSeekSD4   :=xFilial("SD4")+SD3->D3_COD+SD3->D3_OP+SD3->D3_TRT+IF(!Empty(SD3->D3_LOTECTL),SD3->D3_LOTECTL+SD3->D3_NUMLOTE,"")
						cCompSD4   :="D4_FILIAL+D4_COD+D4_OP+D4_TRT"+IF(!Empty(SD3->D3_LOTECTL),"+D4_LOTECTL+D4_NUMLOTE","")
					EndIf

					// VERIFICA SE JA EXISTE UM REGISTRO PARA O LOTE E QUANTIDADE
					lExistQtd := .F.
					If fRetParPrd(SD3->D3_OP) 
						nQuantOrig := nQuant - SD3->D3_QTMAIOR
						dbSelectArea("SD4")
						dbSetOrder(1)                                                                                                    
						dbSeek(cSeekSD4)
						While !Eof() .And. cSeekSD4 == &(cCompSD4)
							If nQuantOrig == SD4->D4_QTDEORI
								If (Empty(SD3->D3_LOTECTL) .And. Empty(SD4->D4_LOTECTL)) .Or.;//verificar se o lote da d3 nao tiver valor na d4 tbm nao deve ter
									(!Empty(SD3->D3_LOTECTL) .And. !Empty(SD4->D4_LOTECTL))
									lExistQtd := .T.
									Exit
								EndIf 
							EndIf
							dbSkip()
						End
					ENDIF

					nIndPerAnt := 0
					If IsInCallStack("MATA680") .Or. IsInCallStack("MATA681")
						lBxComp := fCompOper(SD3->D3_OP)

						If lBxComp //OperaГЦo x Componente
							If SH6->H6_PERDANT > 0
								nIndPerAnt := SH6->H6_PERDANT / SC2->C2_QUANT
							EndIf
						EndIf
					EndIf
					
					dbSelectArea("SD4")
					dbSetOrder(1)
					dbSeek(cSeekSD4)
					If Eof()   // Versao Anterior a 1.17
						cSeekSD4:=xFilial("SD4")+SD3->D3_COD+SD3->D3_OP
						cCompSD4:="D4_FILIAL+D4_COD+D4_OP"
						dbSeek(cSeekSD4)
					EndIf
					If !Eof() .AND. lAbreOp													
						nQuantOrig := nQuant - SD3->D3_QTMAIOR
						While !Eof() .And. cSeekSD4 == &(cCompSD4) .And. (nQuantOrig > 0 .Or. nQuantOrig < 0)
							// Verifica o local do apontamento
							If (D4_LOCAL == SD3->D3_LOCAL .Or. (D4_QTDEORI < 0 .And. SD3->D3_LOCAL == cLocCQ)) .And.; //-- Item negativo (coproduto) pode ter ido para CQ
								((D4_QTDEORI > 0 .And. (D4_QTDEORI-D4_QUANT) > 0) .Or. D4_QTDEORI < 0) .And.;
								(!lExistQtd .Or. (lExistQtd .And. nQuantOrig == D4_QTDEORI ))

								RecLock("SD4",.F.)
								//-- Verifica se deve limpar o lote eou nao
								If QtdComp(SD4->D4_QUANT) > QtdComp(0)
									lLLoteD4 := .F.
								EndIf

								If D4_QTDEORI > 0
									lGeraDev:=.F.
									// Verifica a quantidade na potencia maxima atraves do SD5
									If PotencLote(SD4->D4_COD) .And. Empty(SD4->D4_LOTECTL+SD4->D4_NUMLOTE)
										SD5->(dbSetOrder(3))
										SD5->(dbSeek(xFilial("SD5")+SD3->D3_NUMSEQ+SD3->D3_COD+SD3->D3_LOCAL))
										nQuantPOrig := 0
										While !SD5->(Eof()) .And. SD5->(D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL) == xFilial("SD5")+SD3->D3_NUMSEQ+SD3->D3_COD+SD3->D3_LOCAL
											If SD5->D5_ESTORNO # "S"
												// Prevencao contra informacao incompleta no SD5
												If Empty(SD5->D5_POTENCI)
													SB8->(dbSetOrder(3))
													If Rastro(SD5->D5_PRODUTO,"L")
														SB8->(dbSeek(xFilial("SB8")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_LOTECTL))
													ElseIf Rastro(SD5->D5_PRODUTO,"S")
														SB8->(dbSeek(xFilial("SB8")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_LOTECTL+SD5->D5_NUMLOTE))
													EndIf
												EndIf
												nQuantPOrig += A250PotMax(SD5->D5_PRODUTO,If(Empty(SD5->D5_POTENCI),SB8->B8_POTENCI,SD5->D5_POTENCI),SD5->D5_QUANT,nDecSD4)
											EndIf
											SD5->(dbSkip())
										End
										nBaixa:=Min(D4_QTDEORI-D4_QUANT,nQuantPOrig)
										nBaixa:=Min(nBaixa,nQuantOrig)
										nQuantOrig-=nBaixa
										Replace D4_QUANT With D4_QUANT + Min(D4_QTDEORI-D4_QUANT,nBaixa)
									Else
										nBaixa:=Min(D4_QTDEORI-D4_QUANT,nQuantOrig)
										nQuantOrig-=nBaixa
										Replace D4_QUANT With D4_QUANT + Min(D4_QTDEORI-D4_QUANT,nBaixa)
									EndIf
								Else
									nBaixa:=Max(D4_QTDEORI-D4_QUANT,nQuantOrig)
									nQuantOrig-=nBaixa
									lGeraDev:=.T.
									Replace D4_QUANT With D4_QUANT + Max(D4_QTDEORI-D4_QUANT,nBaixa)
									nQuantOrig:=0
								EndIf
								Replace D4_QTSEGUM With IIf(SB1->B1_CONV == 0 , D4_QTSEGUM + SD3->D3_QTSEGUM, ConvUm(SD4->D4_COD,SD4->D4_QUANT,SD3->D3_QTSEGUM,2) )
								MsUnlock()
							EndIf						
							SD4->(dbSkip())
						End
					EndIf
					
					//-- Se item negativo (coproduto) que foi para CQ, deleta SD7
					If lGeraDev .And. AllTrim(SD3->D3_LOCAL) == alltrim(cLocCQ)
						SD7->(dbSetOrder(3))
						If SD7->(dbSeek(xFilial('SD7')+SD3->D3_COD+SD3->D3_NUMSEQ, .F.)) .And. SD7->D7_ORIGLAN == 'PR'
							cSeekSD7 := xFilial('SD7')+SD7->D7_NUMERO+SD7->D7_PRODUTO
							SD7->(dbSetOrder(1))
							SD7->(dbSeek(cSeekSD7,.F.))
							While !SD7->(Eof()) .And. cSeekSD7 == SD7->(D7_FILIAL+D7_NUMERO+D7_PRODUTO)
								RecLock('SD7', .F.)
								SD7->(dbDelete())
								SD7->(MsUnlock())
								SD7->(dbSkip())
							End
						EndIf
					EndIf

					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Reposiciona o SD4 no primeiro registro da  Ё
					//Ё chave para ser usado no MOVELOTE.          Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					dbSelectArea("SD4")
					dbSetOrder(1)
					dbSeek(cSeekSD4)

					If aBaixaSGF == NIL .Or. aScan(aBaixaSGF, {|z| SD3->(D3_COD + D3_TRT) == z[1] + z[2]}) > 0
						//здддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Pega o custo da movimentacao               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддды
						aCusto := PegaCusD3()
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Acumula os totais requisitados para atualizar OP              Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						For a := 1 to Len(aCusto)
							aCustoTot[a] += aCusto[a]
						Next a
						//здддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza arquivo de saldos em estoque do Pai Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SB2")
						MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
						If EOF()
							CriaSB2(SD3->D3_COD,SD3->D3_LOCAL)
						EndIf
						RecLock("SB2",.F.)
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza o saldo atual (VATU) com os dados do SD3     Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If lProdAut .And. !(lWmsNew .And. IntWms(SD3->D3_COD)) .And. lAbreOp
							lUsaB8Emp := .T.
						Else
							lUsaB8Emp := .F.
						EndIf						
						
						B2AtuComD3(aCusto,,,lAbreOp,lGeraDev,,!lLLoteD4,,,,,,,,,,,,,,,,,,,,,,,,,,,,lUsaB8Emp)

						If IsInCallStack("MATA680") .Or. IsInCallStack("MATA681")
							If lBxComp //OperaГЦo x Componente																				
								IF !lPerdInf .And. SH6->H6_PERDANT > 0 .And. (SD4->D4_QTDEORI > SD4->D4_QUANT)
									If nIndPerAnt > 0
										nQtdAjtPer := (SD4->D4_QTDEORI * nIndPerAnt)
										Reclock("SD4",.F.)
											Replace SD4->D4_QUANT With SD4->D4_QUANT + nQtdAjtPer
										MsUnLock()

										fDesAtB8BF(nQtdAjtPer)
									EndIf
								EndIf										
							EndIf
						EndIf

						// Estorna a baixa das requisiГУes no WMS, bem como empenho SDC e SB8
						If lWmsNew .And. IntWms(SD3->D3_COD)
							WmsEstReq(SD3->(Recno()))
						EndIf

						If Substr(SD3->D3_CF,3,1) # "9"
							If SD3->D3_LOCAL == cLocProc
								For nY := 1 To nTamArrCus
									aCustoD[nY] += If(lGeraDev,aCusto[ny]*-1,aCusto[ny])
								Next nY
							Else
								For nY := 1 To nTamArrCus
									aCustoD[nY] += If(lGeraDev,aCusto[ny]*-1,aCusto[ny])
								Next nY
							EndIf
						EndIf
					EndIf
					If aRegistros[nx,nz,2] == "R"
						//здддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza arquivo de demandas               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SB3")
						MsSeek(xFilial("SB3")+SD3->D3_COD)
						If !Found()
							RecLock("SB3",.T.)
							Replace B3_FILIAL With xFilial("SB3"), B3_COD With SD3->D3_COD
						Else
							RecLock("SB3",.F.)
						EndIf
						Replace &(cMes) With &(cMes) - nQuant
						MsUnlock()
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Grava os lancamentos nas contas orcamentarias SIGAPCO    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If SD3->D3_TM <= "500"
						PcoDetLan("000152","01","MATA250")
					Else
						PcoDetLan("000152","02","MATA250")
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Verifica se o custo medio e' calculado On-Line               Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If cCusMed == "O"
						// Grava os registros que estarЦo com o cСdigo do documento contabil relacionado (Correlativo)
						If ( UsaSeqCor() ) .AND. Type("aCtbDia") == "A"
							aAdd(aCtbDia,{"SD3",SD3->(RECNO()),"","D3_NODIA","D3_DIACTB"})
						Else
							aCtbDia := {}
						EndIF
						If SubStr(SD3->D3_CF,3,1) != "2"
							If SD3->D3_TM <= "500"
								//зддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Gera o lancamento no arquivo de prova           Ё
								//юддддддддддддддддддддддддддддддддддддддддддддддддды
								nTotal+=DetProva(nHdlPrv,"668","MATA250",cLoteEst)
							Else
								//зддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Gera o lancamento no arquivo de prova           Ё
								//юддддддддддддддддддддддддддддддддддддддддддддддддды
								nTotal+=DetProva(nHdlPrv,"666","MATA250",cLoteEst)
							EndIf
						Else
							If SD3->D3_TM <= "500"
								//зддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Gera o lancamento no arquivo de prova           Ё
								//юддддддддддддддддддддддддддддддддддддддддддддддддды
								nTotal+=DetProva(nHdlPrv,"679","MATA250",cLoteEst)
							Else
								//зддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Gera o lancamento no arquivo de prova           Ё
								//юддддддддддддддддддддддддддддддддддддддддддддддддды
								nTotal+=DetProva(nHdlPrv,"680","MATA250",cLoteEst)
							EndIf
						EndIf
					EndIf
				Next nz
			Next nX
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Pega o custo da movimentacao               Ё
		//юдддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea("SD3")
		MsGoTo(nRecPai)

		If aBaixaSGF == NIL
			aCusto := PegaCusD3()

			//зддддддддддддддддддддддддддддд©
			//Ё Pega os custos atuais da OP Ё
			//юддддддддддддддддддддддддддддды
			aC2Vatu := PegaC2Atu()

			//здддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza arquivo de OP                     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддды
			For nX := 1 To nTamArrCus
				aC2Vatu[nX] := aC2Vatu[nX]+(aCusto[nX]-aCustoD[nX]-aCustoI[nX])
			Next nX

			RecLock("SC2",.F.)
			Replace C2_VATU1 With aC2Vatu[01],C2_VATU2 With aC2Vatu[02],;
			C2_VATU3 With aC2Vatu[03],C2_VATU4 With aC2Vatu[04],;
			C2_VATU5 With aC2Vatu[05]

			aCusto[01] := C2_APRATU1 - aCusto[01]
			aCusto[02] := C2_APRATU2 - aCusto[02]
			aCusto[03] := C2_APRATU3 - aCusto[03]
			aCusto[04] := C2_APRATU4 - aCusto[04]
			aCusto[05] := C2_APRATU5 - aCusto[05]

			Replace C2_APRATU1 With aCusto[01],C2_APRATU2 With aCusto[02],;
			C2_APRATU3 With aCusto[03],C2_APRATU4 With aCusto[04],;
			C2_APRATU5 With aCusto[05]
			MsUnlock()
		Else
			//зддддддддддддддддддддддддддддд©
			//Ё Pega os custos atuais da OP Ё
			//юддддддддддддддддддддддддддддды
			aC2Vatu := PegaC2Atu()

			//здддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza arquivo de OP                     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддды
			For nX := 1 To nTamArrCus
				aC2Vatu[nX] := aC2Vatu[nX] - aCustoTot[nX]
			Next nX

			RecLock("SC2",.F.)
			Replace C2_VATU1 With aC2Vatu[01],C2_VATU2 With aC2Vatu[02],;
			C2_VATU3 With aC2Vatu[03],C2_VATU4 With aC2Vatu[04],;
			C2_VATU5 With aC2Vatu[05]
			MsUnlock()

			If lIntNewMRP
				A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
			EndIf
		EndIf

		A250Nutri(SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))

		dbSelectArea("SD3")
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Grava os lancamentos nas contas orcamentarias SIGAPCO    Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If SD3->D3_TM <= "500"
			PcoDetLan("000152","01","MATA250")
		Else
			PcoDetLan("000152","02","MATA250")
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o custo medio e' calculado On-Line               Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If cCusMed == "O"

			If lVldTpArr
				aAdd(aAtuSD3,SD3->(Recno()))
			EndIf

			// Grava os registros que estarЦo com o cСdigo do documento contabil relacionado (Correlativo)
			If ( UsaSeqCor() ) .AND. Type("aCtbDia") == "A"
				aAdd(aCtbDia,{"SD3",SD3->(RECNO()),"","D3_NODIA","D3_DIACTB"})
			Else
				aCtbDia := {}
			EndIF

			If SubStr(SD3->D3_CF,3,1) != "2"
				If SD3->D3_TM <= "500"
					//зддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Gera o lancamento no arquivo de prova           Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддды
					nTotal+=DetProva(nHdlPrv,"668","MATA250",cLoteEst)
				Else
					//зддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Gera o lancamento no arquivo de prova           Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддды
					nTotal+=DetProva(nHdlPrv,"666","MATA250",cLoteEst)
				EndIf
			Else
				If SD3->D3_TM <= "500"
					//зддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Gera o lancamento no arquivo de prova           Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддды
					nTotal+=DetProva(nHdlPrv,"679","MATA250",cLoteEst)
				Else
					//зддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Gera o lancamento no arquivo de prova           Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддды
					nTotal+=DetProva(nHdlPrv,"680","MATA250",cLoteEst)
				EndIf
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Chama integraГЦo com novo MRP                                Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lIntNewMRP .And. lIntLocal
			If Len(aMRPxJson[1]) > 0
				MATA650INT("INSERT", aMRPxJson[1])
				aSize(aMRPxJson[1], 0)
				FreeObj(aMRPxJson[2])
				aMRPxJson[2] := Nil
			EndIf
			If lDelTBMRP
				_lNewMRP := Nil
			EndIf
		EndIf

		// Desfaz a integraГЦo da ordem de serviГo do WMS
		If !lWmsSD3 .And. IntWms(SD3->D3_COD) .And. !Empty(SD3->D3_SERVIC)
			WmsDelOP(nRecSD3)
		EndIf

		If lSD3250E
			ExecBlock("SD3250E",.F.,.F.)
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Finaliza a gravacao dos lancamentos do SIGAPCO            Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		PcoFinLan("000152")
	EndIf
	RestArea(aArea)
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250IniOP Ё Autor Ё Eveli Morasco         Ё Data Ё 07/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa que inicializa alguns campos a partir da OP       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250IniOP()
	LOCAL nEndereco,nEnd1,nEnd2,nTam,nDec
	LOCAL aAreaSD3:={}, cAliasOld
	LOCAL nTamOp
	LOCAL cNumOp
	LOCAL cProdRef
	LOCAL lReferencia := .F.
	LOCAL lBaixa      := .F.
	LOCAL lRet        := .T.
	LOCAL lContinua   := .T.
	LOCAL lAtuCampo   := .T.
	LOCAL nPos        := 0
	Local lIntSFC     := IntegraSFC() .And. !IsInCallStack("AUTO681")
	Local nPrapont    := GetNewPar("MV_PRAPONT",2)
	Local cLocCQ	:= GetMvNNR('MV_CQ','98')
	Local cMay
	Local aTam	:= {}
	Local lWmsSD3   := IIf(!(Type('lExecWms')=='U'), lExecWms, .F.)
	
	If Type("cA240End ") == "U"
		Private cA240End := CriaVar('DB_LOCALIZ')
	EndIf


	If Type("l250Auto") == "U"
		Private l250Auto := .F.
	EndIf

	cNumOP := M->D3_OP
	If l250
		lRet := fAchoOP(cNumOP) .and.  a250VldOP()
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Checa arquivo de controle de geracao de OPs intermediarias     Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		lRet := lRet .And. A650OpBatch(cNumOP,.T.,l250Auto)

		//-- Impede apontamento de OP integrada ao Chao de Fabrica
		If lRet .And. lIntSFC
			CYQ->(dbSetOrder(1))
						lRet := !CYQ->(dbSeek(xFilial("CYQ")+M->D3_OP))
			If !lRet
				Aviso(STR0035,STR0117,{"OK"}) //-- Esta OP И movimentada somente atravИs do mСdulo ChЦo de FАbrica.
			EndIf
		EndIf

		If lRet
			nTamOp   	:= Len(Alltrim(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD))
			cNumOp   	:= If( Len(Alltrim(M->D3_OP))==nTamOp.Or.(!Empty(M->D3_COD) .And. !MatGrdPrrf(M->D3_COD)),M->D3_OP,Alltrim(M->D3_OP))
			cProdRef	:= M->D3_COD
			If MatGrdPrrf(@cProdRef)
				lReferencia := .T.
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Monta o AcolsGrade e o AheadGrade para este item     Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If IsAtNewGrd()
					oGrade:MontaGrade(1,cProdRef,.T.,,lReferencia)
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	EndIf

	If lContinua
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+cNumOp)

		If EOF()
			If !l185
				M->D3_COD := Criavar("D3_COD",.F.)
			EndIf
			lRet 		:= .F.
			lContinua   := .F.
		ElseIf SC2->C2_TPOP == "P"
			If !l185
				M->D3_COD :=  Criavar("D3_COD",.F.)
			EndIf
			Help(" ",1,"NOPPREVIST")
			lRet 		:= .F.
			lContinua   := .F.
		EndIf
	EndIf
	If lContinua
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o produto digitado e' uma referencia de Grade     Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If !lReferencia
			If !Empty(SC2->C2_DATRF) .And. !l240 .and. !l241 .And. !l185
				M->D3_COD :=  Criavar("D3_COD",.F.)
				Help(" ",1,"A250ENCERR")
				lRet 		:= .F.
				lContinua	:= .F.
			EndIf
		Else
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Varre os itens da grade, para verificar se todos os itens ja foram ou nao produzidosЁ
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			Do While !EOF() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN+If(Len(Alltrim(M->D3_OP))==nTamOp,C2_ITEMGRD,"")  == xFilial("SC2")+Alltrim(M->D3_OP)
				If !Empty(SC2->C2_DATRF)
					dbSkip()
					loop
				Else
					lBaixa := .T.
					Exit
				EndIf
			EndDo
			If !lBaixa
				If !l185
					M->D3_COD :=  Criavar("D3_COD",.F.)
				EndIf
				Help(" ",1,"A250ENCERR")
				lRet 		:= .F.
				lContinua   := .F.
			EndIf
		EndIf
	EndIf
	If lContinua .And. (l240 .OR. l241)
		If !EMPTY(C2_DATRF)
			Help(" ",1,"MA240OPENC")
			lRet 		:= .F.
			lContinua 	:= .F.
		Else
			If l240
				//-- Se devolucao de item negativo (coproduto) e CQ configurado, gatilha armazem de CQ
				If M->D3_TM <= '500' .And. IsProdCoPR(M->D3_COD,M->D3_OP,M->D3_TRT) .And. fEnvCQProd(M->D3_COD,M->D3_TM,.F.,.T.)
					M->D3_LOCAL := cLocCQ
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "D3_LOCAL" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := cLocCQ
					EndIf
				ElseIf Empty(M->D3_LOCAL)
					M->D3_LOCAL := C2_LOCAL
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "D3_LOCAL" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := C2_LOCAL
					EndIf
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//| Produtos de apropriacao indireta, quando ja possuem saldo no armazem de processo |
				//| a baixa e automatica pela producao, quando ainda nao possuem saldo no armazem de |
				//| de processo devera ser feita requisicao manual do armazem padrao.                |
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If A260ApropI(M->D3_COD,M->D3_TM)
					Help("",1,"MA241IND")
					lRet 		:= .F.
					lContinua   := .F.
				EndIf
			ElseIf l241
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//| Produtos de apropriacao indireta, quando ja possuem saldo no armazem de processo |
				//| a baixa e automatica pela producao, quando ainda nao possuem saldo no armazem de |
				//| de processo devera ser feita requisicao manual do armazem padrao.                |
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If A260ApropI(GdFieldGet('D3_COD',n),If(Type("cTm")<>"U",cTm,""))
					Help("",1,"MA241IND")
					lRet 		:= .F.
					lContinua   := .F.
				EndIf
				//-- Se devolucao de item negativo (coproduto) e CQ configurado, gatilha armazem de CQ
				If cTm <= '500' .And. IsProdCoPR(aCols[n,nPosCod],M->D3_OP,aCols[n,nPosTRT]) .And. fEnvCQProd(aCols[n,nPosCod],cTm,.F.,.T.)
					aCols[n,nPosLocal]:= cLocCQ
				ElseIf Empty(aCols[n,nPosLocal])
					aCols[n,nPosLocal]:=C2_LOCAL
				EndIf
			EndIf
			If lContinua
				lRet 		:= .T.
				lContinua   := .F.
			EndIf
		EndIf
	EndIf

	If lContinua .And. !l242
		M->D3_UM := C2_UM
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "D3_UM" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := C2_UM
		EndIf

		If Len(Alltrim(M->D3_OP)) == nTamOp
			M->D3_COD := C2_PRODUTO

			If !lWmsSD3 .And. IntWms(M->D3_COD) .And. FindFunction('WmsSerEndPr')
				WmsSerEndPr(M->D3_COD,@M->D3_SERVIC,@cA240End)
			EndIf

			nEndereco := Ascan(aGets,{ |x| Subs(x,9,6) == "D3_COD" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := C2_PRODUTO
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Imprime a descricao do produto para conferencia                Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		cOldArea:=Alias()
		nOldOrdem:=IndexOrd()
		nOldNum:=Recno()

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se for produto referencia, nao deve preencher os campos abaixo Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea("SB1")
		MsSeek(xFilial("SB1")+M->D3_COD)
		If Len(Alltrim(M->D3_OP)) == nTamOp
			M->D3_DESCRI := SB1->B1_DESC
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "D3_DESCRI" } )
			If nEndereco > 0
				IF fTemLetra(Subs(aGets[nEndereco],1,2))
					nPosicao := nEndereco
				ELSE
					nPosicao := SuperVal(Subs(aGets[nEndereco],1,2))
				ENDIF
				aTela[nPosicao][SuperVal(Subs(aGets[nEndereco],3,1))*2] := SB1->B1_DESC
			EndIf

			If Rastro(M->D3_COD)
				If funname() = "AGRA840" .AND. Type("M->NP9_DTVAL") <> "C"
					M->D3_DTVALID	 := M->NP9_DTVAL
				Else
					M->D3_DTVALID	:= dDataBase + B1_PRVALID
				EndIf
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "D3_DTVALID" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->D3_DTVALID)
				EndIf
			EndIf
		Else
			M->D3_DESCRI := " "
		EndIf

		dbSelectArea(cOldArea)
		dbSetOrder(nOldOrdem)
		MsGoto(nOldNum)

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Caso utilize coletor de dados nao preenche valor               Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If Type("l250Auto") == "L" .And. l250Auto
			nPos := aScan(aRotAuto,{|x| x[1] == "D3_QUANT"})
			If nPos > 0
				lAtuCampo := .F.
			Endif
		Endif

		If Type("l250Auto") == "U" .Or. (Type("l250Auto") == "L" .And. !l250Auto) .Or. lAtuCampo .And. Len(Alltrim(M->D3_OP)) == nTamOp
			M->D3_QUANT := C2_QUANT - C2_QUJE - If(lPerdInf,0,C2_PERDA)
			lAtuCampo   := .T.
		EndIf
		If M->D3_QUANT < 0
			M->D3_QUANT := 0
		EndIf
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "D3_QUANT" } )
		If nEndereco > 0

			If IsAlpha(Subs(aGets[nEndereco],1,2))
				nEnd1 := Val(RetAsc(Subs(aGets[nEndereco],1,2), 2, .F.))
			Else
				nEnd1 := Val(Subs(aGets[nEndereco],1,2))
			EndIf

			nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
			nTam  := Len(aTela[nEnd1][nEnd2])
			nDec  := nTam-Rat(".",aTela[nEnd1][nEnd2])
			If nTam == nDec
				nDec := 0
			EndIf
			aTela[nEnd1][nEnd2] := Transform(C2_QUANT-C2_QUJE-If(lPerdInf,0,C2_PERDA),PesqPictQT("D3_QUANT"))
		EndIf

		M->D3_CC      := C2_CC
		M->D3_CLVL    := C2_CLVL
		M->D3_ITEMCTA := C2_ITEMCTA

		nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "D3_CC" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := C2_CC
		EndIf

		dbSelectArea("SB1")
		MsSeek(xFilial("SB1")+M->D3_COD)
		If Empty(M->D3_LOCAL) .Or. l250
			If funname() <> "AGRA840"  // Se retirar vai dar problema no modulo SIGAAGR
				M->D3_LOCAL := SC2->C2_LOCAL
			EndIf
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "D3_LOCAL" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SC2->C2_LOCAL
			EndIf
		EndIf

		//-- Envia o Produto Produzido para o CQ
		If !lReferencia .And. lRet
			If (fEnvCQProd(M->D3_COD, M->D3_TM,.F.) .And. !Empty(D3_QUANT) .And. nPrapont == 1) .Or. (nPrapont == 2 .And. SB1->B1_NUMCQPR > 0)
				aTam := TamSx3("D3_LOCAL")
				M->D3_LOCAL := GetMvNNR('MV_CQ','98')
				lEnvCQProd := .T.
			EndIf
		EndIf

		M->D3_CONTA := B1_CONTA
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "D3_CONTA" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B1_CONTA
		EndIf

		M->D3_GRUPO := B1_GRUPO
		M->D3_TIPO  := B1_TIPO
		If lUsaSegUm .and. !lReferencia
			A240SegUm()
		Else
			M->D3_SEGUM := B1_SEGUM
		EndIf
		//здддддддддддддддддддддддддддддддддд©
		//ЁCaso for rotina automatica        Ё
		//юдддддддддддддддддддддддддддддддддды
		If Type("l250Auto") == "L" .And. l250Auto
			nPos := aScan(aRotAuto,{|x| x[1] == "D3_PARCTOT"})
			If nPos > 0
				lAtuCampo := .F.
			Endif
		Endif
		If lReferencia
			M->D3_PARCTOT := " "
			a250Insere("D3_QUANT",oGrade:EmptyGrd("D3_QUANT"))
		ElseIf ( Type("l250Auto") == "U" .Or. lAtuCampo)
			M->D3_PARCTOT := "T"
			lAtuCampo := .T.
		ElseIf M->D3_QUANT >= SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)
			M->D3_PARCTOT := "T"
		Else
			M->D3_PARCTOT := "P"
		EndIf

		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "D3_PARCTOT" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := "T"
		EndIf

		//-- SС preenche o campo D3_DOC se este nЦo possuir inicializador padrЦo, ou se estiver sem nenhum valor.
		//If Empty(GetSX3Cache("D3_DOC","X3_RELACAO")) .Or. Empty(M->D3_DOC)
		If (Empty(GetSX3Cache("D3_DOC","X3_RELACAO")) .And. Type("l250Auto") == "L" .And. !l250Auto  ) .Or. Empty(M->D3_DOC)
			cAliasOld:=Alias()
			dbSelectArea("SD3")
			aAreaSD3:=GetArea()
			dbSetOrder(2)
			If dbSeek(xFilial("SD3")+Padr(M->D3_OP,Len(M->D3_DOC)))
				M->D3_DOC := NextNumero("SD3",2,"D3_DOC",.T.)
				M->D3_DOC := A261RetINV(M->D3_DOC)
			Else
				M->D3_DOC := Padr(M->D3_OP,Len(M->D3_DOC))
			EndIf

			//Verifica sequencia de documento
			dbSeek(xFilial("SD3")+M->D3_DOC)
			cMay := "SD3"+Alltrim(xFilial("SD3"))+M->D3_DOC
			While SD3->(D3_FILIAL+D3_DOC)==xFilial("SD3")+M->D3_DOC .Or. !MayIUseCode(cMay)
				If SD3->(D3_FILIAL+D3_DOC)==xFilial("SD3")+M->D3_DOC
					If D3_ESTORNO # "S"
						M->D3_DOC := Soma1(M->D3_DOC)
					EndIf
					SD3->(dbSkip())
				Else
					M->D3_DOC := Soma1(M->D3_DOC)
				EndIf
				cMay := "SD3"+Alltrim(xFilial("SD3"))+M->D3_DOC
			EndDo

			RestArea(aAreaSD3)
			dbSelectArea(cAliasOld)
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,6) == "D3_DOC" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->D3_DOC
			EndIf
		EndIf
	EndIf
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250TM    Ё Autor Ё Eveli Morasco         Ё Data Ё 14/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa que verifica o TM digitado                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250TM
	LOCAL cVar
	LOCAL lRet := .T.
	cVar := &(ReadVar())
	dbSelectArea("SF5")
	MsSeek(xFilial("SF5")+cVar)
	If F5_TIPO != "P"
		Help(" ",1,"A250TM")
		lRet := .F.
	EndIf

	If F5_TIPO == "P"
		If fEnvCQProd(M->D3_COD, M->D3_TM, .F.)
			aTam := TamSx3("D3_LOCAL")
			M->D3_LOCAL := GetMvNNR('MV_CQ','98')
		EndIf
	EndIf

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250TudoOkЁ Autor Ё Marcos Bregantim      Ё Data Ё 05/10/94 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa que faz consistencias apos a digitacao da tela    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250TudoOk()

	Static l250ITOK

	Local aAreaSC2  := ''
	Local aErros	:= {}
	Local aNewSal	:= {}
	Local aReqsOk	:= {}
	Local aSaldo	:= {}
	Local aTamSX3	:= {}
	Local aValGrade	:= {}
	Local cAliasQry := ""
	Local cBxProp	:= GetMv("MV_BXPROP" )
	Local cCQ		:= GetMvNNR('MV_CQ','98')
	Local cESTNEG	:= GetMv("MV_ESTNEG" )
	Local cIndNeg	:= SuperGetMv("MV_INDNEG",.F.,'E')
	Local cLinha,cColuna
	Local cLOCPROC	:= SuperGetMv("MV_LOCPROC",.F.,'99')
	Local cMascara	:= GetMv("MV_MASCGRD")
	Local cMens,cQuant
	Local cParcTot  := ''
	Local cPicB2QATU:= PesqPictQT("B2_QATU")
	Local cQuery    := ""
	Local cReqAut	:= A250ReqAut(GetMv("MV_REQAUT"))
	Local lAchou	:= .F.
	Local lApoProd  := .F.
	Local lAtuEmp	:= .T.
	Local lBackRet	:= .T.
	Local lBaixa	:= .F.
	Local lDCLNew	:= SuperGetMV("MV_DCLNEW",.F.,.F.)
	Local lErrBlqMov:= .F.
	Local lErrInvent:= .F.
	Local lErrLote	:= .F.
	Local lErrSaldo	:= .F.
	Local lErrSld	:= .F.
	Local lFifoEnd  := SuperGetMV("MV_FIFOEND",.F.,.T.)  //aceita fifo na req. de endereГo.
	Local lOk		:= .F.
	Local lProdAut	:= GetMv("MV_PRODAUT") .And. l250
	Local lQtMaior  := .F.
	Local lReferencia:= MatGrdPrrf(M->D3_COD)
	Local lRet		:= .T.
	Local lRetApProd:= .T.
	Local lSemSaldo	:= .F.
	Local lSldEmp   := .F.
	Local lUsaLote  := IIF(GetMV("MV_RASTRO")== "S",.T.,.F.)
	Local lValdSep  := SuperGetMV("MV_VALDSEP",.F.,.F.)
	Local lValOpSusp:= GetNewPar("MV_OPSUSP",.T.)
	Local lWmsSD3   := IIf(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local nAux      := 1
	Local nColuna   := 0
	Local nDecSD3,nDecSD4
	Local nExcede 	:= 0
	Local nI        := 0
	Local nIndex    := 0
	Local nIndice	:= 1
	Local nLinha    := 0
	Local nPercPrM	:= 0
	Local nPerda    := 0
	Local nProduz	:= 0
	Local nQtdGanho := 0
	Local nQtdMaior := 0
	Local nQuant    := 0
	Local nTamB1_COD:= TamSX3("B1_COD")[1]
	Local nTamCol	:= Val(Substr(cMascara,7,2))
	Local nTamLin	:= Val(Substr(cMascara,4,2))
	Local nTamRef	:= Val(Substr(cMascara,1,2))
	Local nX        := 0
	Local oDlg	    := nil
	Local oQtdGanho := nil
	Local oQtdMaior := nil
	
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё MV_GANHOPR - Parametro utilizado para verificar se NAO permite o conceito   Ё
	//|              de "Ganho de Producao" na inclusao do apontamento de Producao. |
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lGanhoProd := SuperGetMV("MV_GANHOPR",.F.,.T.)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё MV_PERCPRM - Parametro utilizado para verificar o percentual de "ProduГЦo a  maior"|
	//|              permitido no sistema											       |
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lProdMaior := SuperGetMV("MV_PERCPRM",.F., 0) > 0

	// Valida se a ordem jА foi apontada no MATA680/MATA681
	lRet := a250VerApo()

	IF lRet .And. !Empty(M->D3_EMISSAO)
	    lRet := a250ConsDtOp(M->D3_EMISSAO,M->D3_OP)
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida a existencia de saldo de empenhos para OP quando utiliza requisicao  |
	//Ё manual e a OP esta sendo encerrada.											|
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	if lRet
		If !l250Auto
			lRet := a250ChkEmp(M->D3_OP)
		EndIf
	EndIf

	If ( !l250Auto )
		If Empty(M->D3_OP) .And. FindFunction("a113ApoPro")
			lApoProd := A113TipApo(M->D3_COD)
			If lApoProd
				lRetApProd := A113Perda(M->D3_PERDA)
				If lRetApProd
					lRetApProd := a113ApoPro(M->D3_COD, M->D3_QUANT, aAcho)
					aArray113 := a113RetArray()
					lProc113 := .T.
				Endif
				Return lRetApProd
			EndIf
		EndIf
	EndIf

	If lRet .And. !Empty(M->D3_OP) .And. FindFunction("A113BlqApo")
		lRet := A113BlqApo(M->D3_OP)
	EndIf

	fRetPrdAut(M->D3_OP, 'S')
	fRetParPrd(M->D3_OP, 'S')

	//Valida ProduГЦo AutomАtica por OP - C2_PRODAUT -- Michele
	If lRet // .And. !lProdaut
		lRet := fValPrdAut(M->D3_OP) 
	EndIf 

	If lRet
		lProdaut := IIF( lProdaut, .T., fRetPrdAut(M->D3_OP) )
		fRetParPrd(M->D3_OP)
	EndIf 

	if lValdSep .And. cEstNeg == 'N' .And. lRet
		dbSelectArea("CB8")
		dbSetOrder(6)
		MsSeek(xFilial("CB8")+M->D3_OP)

		dbSelectArea("CB7")
		dbSetOrder(1)
		MsSeek(xFilial("CB7")+CB8->CB8_ORDSEP)

		If CB7->CB7_STATUS == '0' .Or. CB7->CB7_STATUS == '1'
			If IsInCallStack('T_ACDV020') .Or. IsInCallStack('T_ACDV020') .Or. IsInCallStack('T_ACDV020')
				lRet := VTYesNo(STR0125, STR0126)
			Else
				lRet := MsgYesNo(STR0125, STR0126)
			EndIf
		EndIf
	EndIf

	If lRet .And. !lWmsSD3 .And. IntWms(M->D3_COD)
		lRet := WMS250SEA(M->D3_SERVIC, @cA240End, M->D3_COD, M->D3_OP, M->D3_LOCAL, M->D3_DOC, l250, l250Auto)
	EndIf

	//здддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica se tem permissao de armazem  |
	//юдддддддддддддддддддддддддддддддддддддды
	If lRet
		lRet := MaAvalPerm(3,{M->D3_LOCAL,M->D3_COD})
	EndIf

	//-- Validacao para nao permitir producoes com quantidade zerada
	If lRet .And. QtdComp(M->D3_QUANT) == QtdComp(0) .And. QtdComp(M->D3_PERDA) == QtdComp(0)
		Aviso('MATA25003',STR0098,{'Ok'}) //"NЦo e permitido produГУes com quantidade zerada e com perda zerada"
		lRet := .F.
	EndIf

	//-- Validacao para a numeracao do documento
	If lRet
		lRet := A240Doc(M->D3_DOC)
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica se o usuario tem permissao de inclusao. Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet
		lRet := MaAvalPerm(1,{M->D3_COD,"MTA250",3})
		If !lRet
			Help(,,1,'SEMPERM')
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica calendАrio contАbil                Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet
		lRet := (CtbValiDt(Nil,M->D3_EMISSAO,,Nil ,Nil ,{"EST001"}))
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida se hА empenhos com lote e sem endereГo      Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	/*if lUsaLote == .T. .And. cReqAut == "A"
		If lRet
			lRet := a250Empsed()
		endif
	endif */

	If lRet
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Armazena o Local do CQ Origem.                      Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		cLocCQOrig := M->D3_LOCAL

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o ponto de ENTRADA A250ITOK existe.     Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		l250ITOK := IF(l250ITOK==NIL,ExistBlock("A250ITOK"),l250ITOK)

		aTamSX3:=TamSX3("D3_QUANT")
		nDecSD3:=aTamSX3[2]
		aTamSX3:=TamSX3("D4_QUANT")
		nDecSD4:=aTamSX3[2]

		//здддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se producao atualiza empenho.     Ё
		//Ё Caso nao atualize, n└o verifica saldo em   Ё
		//Ё estoque.                                   Ё
		//юдддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea("SF5")
		If MsSeek(xFilial("SF5")+M->D3_TM) .And. SF5->F5_ATUEMP != "S"
			lAtuEmp:=.F.
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verificar data do ultimo fechamento em SX6.                  Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If dDataFec >= M->D3_EMISSAO
			Help ( " ", 1, "FECHTO" )
			lRet:=.F.
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o apontamento e total e se existem requisicoes com data de      |
	//Ё emissao maior que a data do apontamento										|
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

	If lRet .And. M->D3_PARCTOT == "T" .And. A250VerReq(M->D3_OP, M->D3_EMISSAO)
		Help(" ",1,"A250NOPRT")
		lRet := .F.
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o produto est═ sendo inventariado.      Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. BlqInvent(M->D3_COD,M->D3_LOCAL)
		Help(" ",1,"BLQINVENT",,M->D3_COD+STR0048+M->D3_LOCAL,1,11) //" Almox: "
		lRet:=.F.
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Analisa se o tipo do armazem permite a movimentacao |
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. AvalBlqLoc(M->D3_COD,M->D3_LOCAL,Nil,,,,,,,M->D3_OP)
		lRet:=.F.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Se a OP estiver em branco ele deve dar uma mensagem de Ё
	//Ё que este registro nao sera' gravado.                   Ё
	//Ё Este campo nao pode ficar obrigatorio porque ele e'    Ё
	//Ё utilizado nas movimentacoes internas                   Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. Empty(M->D3_OP)
		Help(" ",1,"MA250NAOGR")
		lRet:=.F.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se a Ordem de Producao foi suspensa           Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. lValOpSusp .And. !Empty(M->D3_OP) .And.;
		IIf(FindFunction("NGREGRAEST"),NGREGRAEST(M->D3_OP,M->D3_COD),.T.) // Verifica se nЦo И produto MANUTENCAO
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)))
			If SC2->C2_STATUS == 'U'
				Help(' ',1,"A250OPSUSP")
				lRet := .F.
			EndIf
		Endif
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o Produto foi alterado                     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. !Empty(M->D3_OP) .And. !Empty(M->D3_COD)
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)))
			If SC2->C2_PRODUTO <> M->D3_COD
				Help(' ',1,"A250PRDDIF")
				lRet := .F.
			EndIf
		Endif
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//| Valida campo chave Inspecao de Processos com Apontamento   |
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .AND. FindFunction("QIPGNSD3")
		lRet := QIPGNSD3()
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se a Ordem de Producao nao foi encerrada por outra estacao  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. !lReferencia
		If !SC2->(dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)))
			HELP(" ",1,"A250NAOOP")
			lRet:=.F.
		EndIf
		If  !Empty(SC2->C2_DATRF)
			Help(" ",1,"A250ENCERR")
			lRet:=.F.
		EndIf
		If !lGanhoProd .And. !lProdMaior
			If (M->D3_QUANT + If(lPerdInf,0,M->D3_PERDA)) > (SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA))
				Help(" ",1,"A250GANHPR")
				lRet := .F.
			EndIf
		EndIf
	ElseIf lRet
		If QtdComp(M->D3_QUANT+M->D3_PERDA,.T.) == QtdComp(0,.T.)
			Help(" ",1,"QUANTVAZIO")
			lRet := .F.
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Varre os itens da grade, para verificar se todos os itens ja foram ou nao produzidosЁ
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		SC2->(dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)))
		aAreaSC2:= GetArea()
		Do While !EOF() .And. SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN == xFilial("SC2")+Alltrim(M->D3_OP)
			If !Empty(SC2->C2_DATRF)
				SC2->(dbSkip())
				loop
			Else
				If !lGanhoProd
					If (M->D3_QUANT + If(lPerdInf,0,M->D3_PERDA)) > (SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA))
						Help(" ",1,"A250GANHPR")
						lRet := .F.
					EndIf
				EndIf
				lBaixa := .T.
				Exit
			EndIf
		EndDo
		RestArea(aAreaSC2)
		If !lBaixa
			Help(" ",1,"A250ENCERR")
			lRet := .F.
		EndIF
	EndIf

	If lRet .And. lReferencia .And. If(IsAtNewGrd(),oGrade:EmptyGrd("D3_PARCTOT"),Len(aColsPT) == 0)
		Help(" ",1,"A250PARTOT")
		lRet := .F.
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida produtos bloqueados(Produtos Acabados)		Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. SB1->B1_MSBLQL $ "1"
		Aviso("A250BLOQ",STR0015+ " ''" +AllTrim(SB1->B1_COD)+ "'' " +STR0075,{"OK"})   //Produto bloqueado
		lRet := .F.
	Endif

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Bloqueia a OP durante o apontamento                    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. SuperGetMV("MV_BLQOPAP",.F.,"N") == "S"
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)))
			If !SC2->(SimpleLock())
				HELP(" ",1,"A250JAPON")
				lRet := .F.
			EndIf
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida produtos bloqueados							Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. A250BloqPR0(M->D3_OP)
		lRet := .F.
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Executa o ponto de ENTRADA A250ITOK                 Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. l250ITOK
		ExecBlock("A250ITOK",.F.,.F.,lAtuEmp)
	EndIf
	//ддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд//
	//Consiste amarraГЦo da Conta ContАbil X Centro de Custo		//
	//дддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд//
	If lRet
		If !CtbAmarra(M->D3_CONTA,M->D3_CC,M->D3_ITEMCTA,M->D3_CLVL)
			lRet:= .F.
		EndIf
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё A funcao A250Estoq() verifica se o param. MV_ESTNEG    Ё
	//Ё e igual a "N" e nao deixa nenhum item do empenho ficar Ё
	//Ё com saldo negativo. Verifica tambem o param. MV_RASTRO Ё
	//Ё se e igual a "S" e nao deixa nenhum item do empenho    Ё
	//Ё ser utilizado sem saldo por lote.                      Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. lAtuEmp
		aSaldo := {}
		aNewSal:= {}
		aErros := {}
		aReqsOk:= {}

		If !l250Auto
			//Verifica a necessidade de prorporcionalizaГЦo dos empenhos SD4  //Everton
			lRet := a250Maior(M->D3_OP, M->D3_QUANT, M->D3_PERDA, @nQtdGanho, @nQtdMaior, @nPercPrM, "SD3")
			M->D3_QTMAIOR := nQtdMaior
			M->D3_QTGANHO := nQtdGanho
		Else
			lExistePM := .F.
			If l250Auto
				If M->D3_QTMAIOR > 0
					lRet := a250Maior(M->D3_OP, M->D3_QUANT, M->D3_PERDA, @nQtdGanho, @nQtdMaior, @nPercPrM, "SD3")
					lExistePM := .T.
				EndIf
			EndIf
		EndIf
		If !lProdAut
			SF5->(dbSetOrder(1))
			If SF5->(dbSeek(xFilial("SF5")+M->D3_TM)) .And. SF5->F5_ATUEMP == "S"
				If !lReferencia
					if lRet = .T.
						A250Estoq(M->D3_QUANT+If(lPerdInf,0,M->D3_PERDA) - nQtdGanho,M->D3_PARCTOT,M->D3_COD,Alltrim(M->D3_OP),@aSaldo,@aReqsOK, , ,nPercPrM)
					endif
				Else
					dbSelectArea("SC2")
					dbSetOrder(1)
					dbSeek(xFilial("SC2")+Alltrim(M->D3_OP))

					Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN == xFilial("SC2")+Alltrim(M->D3_OP)
						If !Empty(SC2->C2_DATRF)
							dbSkip()
							Loop
						EndIf
						lAchou := .F.

						If IsAtNewGrd()
							cLinha	:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+1,oGrade:TamLin())
							cColuna	:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+oGrade:TamLin()+1,oGrade:TamCol())

							For nLinha := 1  To Len(oGrade:aColsGrade[nAux])
								For nColuna := 2 To Len(oGrade:aHeadGrade[nAux])
									If oGrade:GetNameLinha(nLinha)==cLinha .And. oGrade:GetNameColuna(nColuna) == cColuna .And.;
									!Empty(oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna))
										lAchou		:= .T.
										aAreaSC2	:= SC2->(GetArea())
										nPerda		:= oGrade:aColsFieldByName("D3_PERDA"	,nAux,nLinha,nColuna)
										nQuant		:= oGrade:aColsFieldByName("D3_QUANT"	,nAux,nLinha,nColuna)
										cParcTot	:= oGrade:aColsFieldByName("D3_PARCTOT"	,nAux,nLinha,nColuna)
										A250Estoq(nQuant+If(lPerdInf,0,nPerda),cParcTot,SC2->C2_PRODUTO,(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD),@aSaldo,@aReqsOK)
										RestArea(aAreaSC2)
										Exit
									EndIf
								Next nColuna
								If lAchou
									Exit
								EndIf
							Next nLinha
						Else
							For nLinha := 1  To Len(aColsGrade[nAux])
								For nColuna := 2 To Len(aHeader)
									If aColsGrade[nAux][nLinha][1]==Substr(SC2->C2_PRODUTO,nTamRef+1,nTamLin) .And. aHeadGrade[nAux][nColuna][1]== Substr(SC2->C2_PRODUTO,nTamRef+nTamLin+1,nTamCol) .And.;
									aColsGrade[nAux][nLinha][nColuna][1] != 0
										lAchou := .T.
										aAreaSC2 := SC2->(GetArea())
										nPerda := If(Len(aQtdPerda)>0, aQtdPerda[nLinha][nColuna], 0)
										nQuant := aColsGrade[nAux][nLinha][nColuna][1]
										cParcTot := aColsPT[nLinha][nColuna]
										A250Estoq(nQuant+If(lPerdInf,0,nPerda),cParcTot,SC2->C2_PRODUTO,(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD),@aSaldo,@aReqsOK)
										RestArea(aAreaSC2)
										Exit
									EndIf
								Next nColuna
								If lAchou
									Exit
								EndIf
							Next nLinha
						EndIf
						dbSelectArea("SC2")
						dbSkip()
					EndDo
				EndIf
			EndIf
		Else
			If fRetParPrd(M->D3_OP)
				aProdAuto := {}
				aEmpSaldo := {}
				aEmpQtNec := {}
			ENDIF
			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Proporcionaliza de acordo com a qtde da OP Pai     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			If !lReferencia
				If M->D3_PARCTOT == "P" .And. cBxProp == "S"
					nIndice := Min(1,(M->D3_QUANT + If(lPerdInf, 0, M->D3_PERDA)) / (SC2->C2_QUANT - SC2->C2_QUJE))
				EndIf
				aNeed := {}
				A250CalInd(M->D3_OP,nIndice)
				LotesSD4(nIndice,Alltrim(M->D3_OP),0,NIL,.T.,@aSaldo,@aReqsOk,NIL, NIL, nPercPrM)
			Else				
				dbSelectArea("SC2")
				dbSetOrder(1)
				dbSeek(xFilial("SC2")+Alltrim(M->D3_OP))
				aArea := GetArea()
				Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN == xFilial("SC2")+Alltrim(M->D3_OP)
					If !Empty(SC2->C2_DATRF)
						dbSkip()
						Loop
					EndIf

					lAchou := .F.
					If IsAtNewGrd()
						cLinha	:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+1,oGrade:TamLin())
						cColuna	:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+oGrade:TamLin()+1,oGrade:TamCol())

						For nLinha := 1  To Len(oGrade:aColsGrade[nAux])
							For nColuna := 2 To Len(oGrade:aHeadGrade[nAux])
								If oGrade:GetNameLinha(nLinha)==cLinha .And. oGrade:GetNameColuna(nColuna) == cColuna .And.;
								!Empty(oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna))
									aAreaSC2:= SC2->(GetArea())
									nPerda	:= oGrade:aColsFieldByName("D3_PERDA"	,nAux,nLinha,nColuna)
									nQuant	:= oGrade:aColsFieldByName("D3_QUANT"	,nAux,nLinha,nColuna)
									cParcTot:= oGrade:aColsFieldByName("D3_PARCTOT"	,nAux,nLinha,nColuna)
									If cParcTot == "P" .And. cBxProp == "S"
										If lPerdInf
											nIndice := Min(1,nQuant / (SC2->C2_QUANT - SC2->C2_QUJE))
										Else
											nIndice := Min(1,(nQuant + nPerda) / (SC2->C2_QUANT - SC2->C2_QUJE))
										EndIf
									Else
										nIndice := 1
									EndIf
									aNeed := {}
									A250CalInd(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,nIndice)
									LotesSD4(nIndice,C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,0,NIL,.T.,@aSaldo,@aReqsOk,nQuant,cParcTot)
									RestArea(aAreaSC2)
									Exit
								EndIf
							Next nColuna
							If lAchou
								Exit
							EndIf
						Next nLinha
					Else
						For nLinha := 1  To Len(aColsGrade[nAux])
							For nColuna := 2 To Len(aHeader)
								If aColsGrade[nAux][nLinha][1]==Substr(SC2->C2_PRODUTO,nTamRef+1,nTamLin) .And. aHeadGrade[nAux][nColuna][1]== Substr(SC2->C2_PRODUTO,nTamRef+nTamLin+1,nTamCol) .And.;
								aColsGrade[nAux][nLinha][nColuna][1] != 0
									aAreaSC2 := SC2->(GetArea())
									nPerda := If(Len(aQtdPerda)>0, aQtdPerda[nLinha][nColuna], 0)
									nQuant := aColsGrade[nAux][nLinha][nColuna][1]
									cParcTot := aColsPT[nLinha][nColuna]
									If aColsPT[nLinha][nColuna]== "P" .And. cBxProp == "S"
										If lPerdInf
											nIndice := Min(1,nQuant / (SC2->C2_QUANT - SC2->C2_QUJE))
										Else
											nIndice := Min(1,(nQuant + nPerda)/ (SC2->C2_QUANT - SC2->C2_QUJE))
										EndIf
									Else
										nIndice := 1
									EndIf
									aNeed := {}
									A250CalInd(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,nIndice)
									LotesSD4(nIndice,C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,0,NIL,.T.,@aSaldo,@aReqsOk,nQuant,cParcTot)
									RestArea(aAreaSC2)
									Exit
								EndIf
							Next nColuna
							If lAchou
								Exit
							EndIf
						Next nLinha
					EndIf
					dbSelectArea("SC2")
					dbSkip()
				EndDo
				RestArea(aArea)
			EndIf
		EndIf

		//validaГУes de numero de serie.
		For nIndex := 1 To Len(aReqsOk)
			If Localiza(aReqsOk[nIndex][1])

				lVldEndereco := .T.
				cSolucao := ""

				cAliasQry  := GetNextAlias()

				cQuery := " SELECT D4_OP, D4_PRODUTO, D4_LOCAL, DC_PRODUTO, SUM(DC_QUANT) ENDERECADO, DC_NUMSERI "
				cQuery += " FROM " + RetSqlName("SD4") + " SD4 "
				cQuery += " LEFT JOIN " + RetSqlName("SDC") + " SDC "
				cQuery += "                     ON (SDC.DC_FILIAL = SD4.D4_FILIAL AND"
				cQuery += "							SDC.DC_OP = SD4.D4_OP AND"
				cQuery += "							SDC.DC_PRODUTO = SD4.D4_COD AND"
				cQuery += "							SDC.DC_LOCAL = SD4.D4_LOCAL AND"
				cQuery += "							SDC.DC_LOTECTL = SD4.D4_LOTECTL AND"
				cQuery += "							SDC.D_E_L_E_T_ = ' ')"
				cQuery += " WHERE SD4.D4_OP = '" + SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN + "' AND "
				cQuery += " SD4.D4_FILIAL = '" + xFilial('SD4') + "' AND "
				cQuery += " SD4.D4_COD = '" + aReqsOk[nIndex][1] + "' AND "
				cQuery += " SD4.D4_LOCAL = '" + aReqsOk[nIndex][2] + "' AND "
				cQuery += " (SDC.DC_PRODUTO <> '' OR SDC.DC_PRODUTO IS NOT NULL) AND "
				cQuery += " SD4.D_E_L_E_T_ = ' ' "
				cQuery += " GROUP BY D4_OP, D4_PRODUTO, D4_LOCAL,   DC_PRODUTO, DC_NUMSERI"

				dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasQry, .T., .F. )

				While (cAliasQry)->(!Eof())
					//valida se o fifo de endereГo И automatico
					Do Case
						Case !lFifoEnd

								Do case
									//impede quantidade fracionada na requisiГЦo de produto com controle de endereГo
									Case (Int((cAliasQry)->(ENDERECADO)) - (cAliasQry)->(ENDERECADO) ) <> 0 .AND. !Empty((cAliasQry)->(DC_NUMSERI))
										//Quando parametro MV_FIFOEND estiver desativado (.F.), quantidade empenhada de ## deve ser um numero inteiro."
										cSolucao := STR0138+ cValToChar((cAliasQry)->(ENDERECADO)) +STR0139
										lVldEndereco := .F.
										Exit
									//impede quantidade empenhada diferente da quantidade requisitada.
									Case ((cAliasQry)->(ENDERECADO) <> QtdComp(aReqsOk[nIndex][3]))
										//"Informar o endereГo para o empenho da Ordem de ProduГЦo."
										cSolucao := STR0140+ SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN
										lVldEndereco := .F.
										Exit
								EndCase

							//impede quantidade fracionada na requisiГЦo de produto com controle de endereГo
						Case (Int(QtdComp(aReqsOk[nIndex][3])) - QtdComp(aReqsOk[nIndex][3])) <> 0 .AND. !Empty((cAliasQry)->(DC_NUMSERI))
							//"Quantidade da RequisiГЦo deve ser numero inteiro, favor verificar o campo Tipo Dec. OP no cadastro de Produto."
							cSolucao := STR0141
							lVldEndereco := .F.
							Exit
					EndCase
					(cAliasQry)->(DbSkip())
				EndDo

				//fecho a tabela
				(cAliasQry)->(DbCloseArea())

				//verifica se validou
				If !lVldEndereco
					//"NЦo И possivel realizar a requisiГЦo automАtica. O produto : ##  possui controle de endereГamento com numero de serie e nЦo atende os requisitos para essa operaГЦo."
					HELP(' ',1,"ATENCцO",, STR0136+aReqsOk[nIndex][1]+STR0137,2, 0,,,,,, {cSolucao})
					Return .F.
				EndIf
			EndIf
		Next nIndex

		If Len(aSaldo) > 0

			/*For ni := 1 to Len(aSaldo)
				ConOut( 'MICHELE INICIO')
				ConOut( 'ARRAY A SALDO')
				ConOut( aSaldo[ni,1]) // Produto
				ConOut( aSaldo[ni,2]) // Local
				ConOut( aSaldo[ni,3]) // Saldo SB2
				ConOut( aSaldo[ni,4]) // Saldo SB8
				ConOut( aSaldo[ni,5]) // Saldo SBF
				ConOut( aSaldo[ni,6])
				ConOut( aSaldo[ni,7])
			End*/

			If ExistBlock("MT250SAL")
				aNewSal := ExecBlock("MT250SAL",.F.,.F.,{aSaldo})
				If ValType(aNewSal) == "A"
					aSaldo := aNewSal
				EndIf
			EndIf

			If cIndNeg == "E"
				cIndNeg := cEstNeg
			EndIf

			lSemSaldo := .F.
			aErros := {}
			For ni := 1 to Len(aSaldo)
				If BlqInvent(aSaldo[ni,1],aSaldo[ni,2])
					cMens:=OemToAnsi(STR0034)	//"Bloqueado p/ Invent═rio"
					cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
					lErrInvent:=.T.
					AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens,aSaldo[ni][7],aSaldo[ni][8]})
				ElseIf AvalBlqLoc(aSaldo[ni,1],aSaldo[ni,2],Nil,.F.,,,,,,M->D3_OP)
					cMens:=OemToAnsi(STR0101)	// "Bloqueado p/ Armazem"
					cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
					lErrBlqMov:=.T.
					AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens,aSaldo[ni][7],aSaldo[ni][8]})
				ElseIf ( (QtdComp(aSaldo[ni][3],.T.) < QtdComp(0,.T.) .Or. QtdComp(aSaldo[ni][4],.T.) < QtdComp(0,.T.);
							.Or. QtdComp(aSaldo[ni][5],.T.) < QtdComp(0,.T.));
						.And. (cESTNEG = "N" .Or. Rastro(aSaldo[ni][1]) .Or. Localiza(aSaldo[ni][1])))

					If fRetParPrd(M->D3_OP)
						If QtdComp(aSaldo[ni][5],.T.) < QtdComp(0,.T.)
							cMens:=OemToAnsi(STR0040)	//"Sem Saldo por Localizacao"
							cQuant:=Transform(aSaldo[ni][5],cPicB2QATU)
							lErrLocaliz:=.T.
						ElseIf QtdComp(aSaldo[ni][4],.T.) < QtdComp(0,.T.)
							cMens:=OemToAnsi(STR0012)	//"Sem Saldo por Lote"
							cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
							lErrLote:=.T.
						ElseIf QtdComp(aSaldo[ni][3],.T.) < QtdComp(0,.T.)
							cMens:=OemToAnsi(STR0013)	//"Sem Saldo em Estoque"
							cQuant:=Transform(aSaldo[ni][3],cPicB2QATU)
							lErrSaldo:=.T.						
						EndIf
						lSemSaldo := .T.
						AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens,aSaldo[ni][7],aSaldo[ni][8]})
					ELSE
						If QtdComp(aSaldo[ni][3]) != QtdComp(aSaldo[ni][4]) .And. Rastro(aSaldo[ni][1])
							cMens:=OemToAnsi(STR0011)	//"Dif. Saldo em Estoque/Lote"
							If QtdCOmp(aSaldo[ni][3]) < QtdComp(aSaldo[ni][4])
								cQuant:=Transform(aSaldo[ni][3],cPicB2QATU)
							Else
								cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
							EndIf
							lErrLote:=.T.;lErrSaldo:=.T.
						ElseIf QtdComp(aSaldo[ni][5],.T.) < QtdComp(0,.T.)
							cMens:=OemToAnsi(STR0040)	//"Sem Saldo por Localizacao"
							cQuant:=Transform(aSaldo[ni][5],cPicB2QATU)
							lErrLocaliz:=.T.
						ElseIf QtdComp(aSaldo[ni][4],.T.) < QtdComp(0,.T.)
							cMens:=OemToAnsi(STR0012)	//"Sem Saldo por Lote"
							cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
							lErrLote:=.T.
						ElseIf QtdComp(aSaldo[ni][3],.T.) < QtdComp(0,.T.)
							cMens:=OemToAnsi(STR0013)	//"Sem Saldo em Estoque"
							cQuant:=Transform(aSaldo[ni][3],cPicB2QATU)
							lErrSaldo:=.T.
						EndIf
						lSemSaldo := .T.
						AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens,aSaldo[ni][7],aSaldo[ni][8]})
					ENDIF
				ElseIf ( (QtdComp(aSaldo[ni][3],.T.) < QtdComp(0,.T.) .Or. QtdComp(aSaldo[ni][4],.T.) < QtdComp(0,.T.) .Or. QtdComp(aSaldo[ni][5],.T.) < QtdComp(0,.T.));
					 .And. A260ApropI(aSaldo[ni][1]) .And. aSaldo[ni][2] == cLOCPROC;
					 .And. (cIndNeg = "N" .Or. Rastro(aSaldo[ni][1]) .Or. Localiza(aSaldo[ni][1])))

				If QtdComp(aSaldo[ni][3]) != QtdComp(aSaldo[ni][4]) .And. Rastro(aSaldo[ni][1])
					cMens:=OemToAnsi(STR0011)	//"Dif. Saldo em Estoque/Lote"
					If QtdCOmp(aSaldo[ni][3]) < QtdComp(aSaldo[ni][4])
						cQuant:=Transform(aSaldo[ni][3],cPicB2QATU)
					Else
						cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
					EndIf
					lErrLote:=.T.;lErrSaldo:=.T.
					ElseIf QtdComp(aSaldo[ni][5],.T.) < QtdComp(0,.T.)
						cMens:=OemToAnsi(STR0040)	//"Sem Saldo por Localizacao"
						cQuant:=Transform(aSaldo[ni][5],cPicB2QATU)
						lErrLocaliz:=.T.
					ElseIf QtdComp(aSaldo[ni][4],.T.) < QtdComp(0,.T.)
						cMens:=OemToAnsi(STR0012)	//"Sem Saldo por Lote"
						cQuant:=Transform(aSaldo[ni][4],cPicB2QATU)
						lErrLote:=.T.
					ElseIf QtdComp(aSaldo[ni][3],.T.) < QtdComp(0,.T.)
						cMens:=OemToAnsi(STR0013)	//"Sem Saldo em Estoque"
						cQuant:=Transform(aSaldo[ni][3],cPicB2QATU)
						lErrSaldo:=.T.
					EndIf

					lSemSaldo := .T.
					AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens,aSaldo[ni][7],aSaldo[ni][8]})

				Endif

				If !SldBlqSB2(aSaldo[ni,1],aSaldo[ni,2],,.F.)
					cMens     := OemToAnsi(STR0059)	//"Saldo Indisponivel Neste Armazem"
					cQuant    := Transform(SB2->B2_QATU,cPicB2QATU)
					lErrSld   := .T.
					lSemSaldo := .T.
					AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens,aSaldo[ni][7],aSaldo[ni][8]})
				EndIf

			Next

			If lSemSaldo .Or. lErrInvent .Or. lErrBlqMov
				If lErrInvent
					Help(" ",1,"MA250INVENT")
				EndIf
				If lErrLote
					Help(" ",1,"MA240NEGLT")
				EndIf
				If lErrSaldo
					Help(" ",1,"MA240NEGAT")
				EndIf
				If lErrSld
					Help(" ",1,"SLDBLQSB2")
				EndIf
				If (Type("l250Auto")<>"L" .or. !l250Auto)
					MTA250TELA(aErros)
				Else
					autogrlog(STR0014)			   					//"Itens Sem Sld / Bloqs. / Empenhos Pendentes"
					autogrlog(	PadR(OemToAnsi(STR0015),nTamB1_COD)+" "+;	//Produto
								PadR(OemToAnsi(STR0016),07)+" "+;			//Armazem
								PadL(OemToAnsi(STR0017),20)+" "+;			//Saldo
								OemToAnsi(STR0018))							//Ocorrencia
					For nX:= 1 to len(aErros)
						autogrlog(PadR(aErros[nx,1],nTamB1_COD)+" "+;
								  PadR(aErros[nx,2],07)+" "+;
								  Transform(aErros[nx,3],cPicB2QATU)+" "+;
								  aErros[nx,4])
					Next
				EndIf
				lRet := .F.
			EndIf
		EndIf
	Else
		If lRet
			If ExistBlock("MT250QMG")
				lQtMaior := ExecBlock("MT250QMG", .F., .F.)
				If ValType(lQtMaior) # "L"
					lQtMaior := .F.
				EndIf
			EndIf

			If lQtMaior
				If !l250Auto
					lRet := a250Maior(M->D3_OP, M->D3_QUANT, M->D3_PERDA, @nQtdGanho, @nQtdMaior, @nPercPrM, "SD3")
					M->D3_QTMAIOR := nQtdMaior
					M->D3_QTGANHO := nQtdGanho
				Else
					lExistePM := .F.
					If M->D3_QTMAIOR > 0
						lRet := a250Maior(M->D3_OP, M->D3_QUANT, M->D3_PERDA, @nQtdGanho, @nQtdMaior, @nPercPrM, "SD3")
						lExistePM := .T.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Se a quantidade informada for menor que a da OP e      Ё
	//Ё mesmo assim for informado 'T' Total, somente sera'     Ё
	//Ё permitida se for informada a Perda, para zerar o saldo Ё
	//Ё da OP.                                                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. !lReferencia
		If lRet .And. M->D3_PARCTOT=='T' .and.;
		M->D3_QUANT + If(lPerdInf,0,M->D3_PERDA) < SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)
			Help(" ",1,"MA250PERDA")
			lRet := .F.
		EndIf
	ElseIf lRet
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+Alltrim(M->D3_OP))

		Do While ! Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN == xFilial("SC2")+Alltrim(M->D3_OP) .And. lRet
			If !Empty(SC2->C2_DATRF)
				dbSkip()
				Loop
			EndIf
			lAchou := .F.

			If IsAtNewGrd()
				cLinha	:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+1,oGrade:TamLin())
				cColuna	:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+oGrade:TamLin()+1,oGrade:TamCol())

				For nLinha := 1  To Len(oGrade:aColsGrade[nAux])
					For nColuna := 2 To Len(oGrade:aHeadGrade[nAux])
						If oGrade:GetNameLinha(nLinha)==cLinha .And. oGrade:GetNameColuna(nColuna) == cColuna .And.;
						!Empty(oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)) .And. oGrade:aColsFieldByName("D3_PARCTOT"	,nAux,nLinha,nColuna)$"PT"
							nPerda := oGrade:aColsFieldByName("D3_PERDA",nAux,nLinha,nColuna)
							If oGrade:aColsFieldByName("D3_PARCTOT"	,nAux,nLinha,nColuna)=='T' .and.;
							oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna) + If(lPerdInf,0,nPerda) < SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)
								Help(" ",1,"MA250PERDA")
								lRet := .F.
							EndIf
							lAchou := .T.
							Exit
						EndIf
					Next nColuna
					If lAchou
						Exit
					EndIf
				Next nLinha
			Else
				For nLinha := 1  To Len(aColsGrade[nAux])
					For nColuna := 2 To Len(aHeader)
						If aColsGrade[nAux][nLinha][1]==Substr(SC2->C2_PRODUTO,nTamRef+1,nTamLin) .And. aHeadGrade[nAux][nColuna][1]== Substr(SC2->C2_PRODUTO,nTamRef+nTamLin+1,nTamCol) .And.;
						aColsGrade[nAux][nLinha][nColuna][1] != 0 .And. aColsPT[nLinha][nColuna]$"PT"
							nPerda := If(Len(aQtdPerda)>0, aQtdPerda[nLinha][nColuna], 0)
							If aColsPT[nLinha][nColuna]=='T' .and.;
							aColsGrade[nAux][nLinha][nColuna][1] + If(lPerdInf,0,nPerda) < SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)
								Help(" ",1,"MA250PERDA")
								lRet := .F.
							EndIf
							lAchou := .T.
							Exit
						EndIf
					Next nColuna
					If lAchou
						Exit
					EndIf
				Next nLinha
			EndIf
			dbSelectArea("SC2")
			dbSkip()
		EndDo

	EndIf

	//-- Envia o Produto Produzido para o CQ
	If lRet .And. !lReferencia
		lEnvCQProd := .F.
		If Empty(M->D3_QUANT) .And. cCQ == M->D3_LOCAL
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Quando for producao com 100% de perda e produto possuir   Ё
			//Ё skip-lote de CQ, devera voltar o local da producao para   Ё
			//Ё o armazem da OP, pois nao havera saldo para analise do CQ Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			M->D3_LOCAL := SC2->C2_LOCAL
		ElseIf fEnvCQProd(M->D3_COD, M->D3_TM, .F.)
			aTam := TamSx3("D3_LOCAL")
			M->D3_LOCAL := cCQ
			lEnvCQProd := .T.
		Else
			fEnvCQProd(M->D3_COD, M->D3_TM, .T.)
		EndIf
	EndIf

	If lRet .and. lDCLNew
		lRet := DCLMT250TO()
	Else
		If lRet .And. ExistTemplate('MT250TOK')
			lBackRet:=lRet
			lRet := ExecTemplate('MT250TOK', .F., .F.,lRet)
			If ValType(lRet) # "L"
				lRet:=lBackRet
			Else
				lRet := (lRet .and. lBackRet)
			EndIf
		EndIf
	EndIf

	If lRet .And. ExistBlock('MT250TOK')
		lBackRet:=lRet
		lRet := ExecBlock('MT250TOK', .F., .F.,lRet)
		If ValType(lRet) # "L"
			lRet:=lBackRet
		Else
			lRet := (lRet .and. lBackRet)
		EndIf
	EndIf

	If lRet
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Grava no SC2 os Itens Informados na Grade                    Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lGrade .And. lReferencia .And. If(IsAtNewGrd(), Len(oGrade:aColsGrade[nAux]) > 0, Len(aCols) > 0 )
			aValGrade := Ma650GraGr("SD3","A250",.F.)
			M->D3_COD:=	 aValGrade[1]
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,6) == "D3_COD" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->D3_COD
			EndIf
			M->D3_OP:=	Substr(M->D3_OP,1,11)+aValGrade[2]
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "D3_OP" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->D3_OP
			EndIf
		EndIf
	EndIf

    //APT - PENDENTE
	//    se for rotina automАtica e estiver setado para somente gravar apontamento como pendente quando der erro,
	//		entЦo deve-se retornar .T. e salvar a tabela de apontamento pendente
	if !lRet .AND. l250Auto .AND. (cPcpPend == '2' .OR. cPcpPend == '4')
		aAdd(aRotAuto,{"GRAVA","4",NIL})
	endif

	/*/se for rotina automАtica, e estiver setado para SEMPRE gravar apontamento como pendente,
		 entЦo basta salvar a tabela de apontamento pendente e dar um return
	   esta gravaГЦo И feita neste momento pois anteriormente jА foram feitas as validaГУes necessАrias */
	if  l250Auto .AND. cPcpPend == '3'
	   	aAdd(aRotAuto,{"GRAVA","3",NIL})
		If lret
            lRet:= .f.
        Endif

	endif

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250Estoq Ё Autor Ё Marcos Bregantim      Ё Data Ё 28/09/94 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa que verifica a Qtd. em estoque dos empenhos da Op Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Estoq(nQuantBx,cParcTot,cProduto,cOP,aSaldo,aReqsOk, aBaixaComp,aChkBaixaC, nParPercPrM)

	Static lA250FilD4
	Static lA250ChkEn

	Local cAlias	:= Alias()
	Local cReqAut	:= A250ReqAut(GetMv("MV_REQAUT"))
	Local cDevAut	:= A250DevAut(SuperGetMV("MV_DEVAUT",.F.,cReqAut))
	Local cEstNeg	:= GetMV("MV_ESTNEG"	)
	Local cBxProp	:= GetMv("MV_BXPROP"	)
	Local cLocProc	:= GetMvNNR('MV_LOCPROC','99')
	Local cIndNeg	:= GetMV("MV_INDNEG"	)
	Local aTamSX3	:= {}
	Local aArray	:= {}
	Local nIndice	:= 1
	Local nSaldo	:= 0
	Local i		  	:= 0
	Local z			:= 0
	Local w			:= 0
	Local z         := 0
	Local xi		:= 0
	Local zi		:= 0
	Local nOrdem, nRec,nOrdSB8, nRecSB8
	Local nElem, cApropri, nQtdUsada
	Local nDecSD3, nDecSD4

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas para baixa "INTELIGENTE" do empenho     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local aArraySD4   := {{}}
	Local aArrayAux   := {{}}
	Local aASaldo     := {}
	Local aBaixLote   := {}
	Local aConsumo    := {}
	Local aProdsSD4   := {{}}
	Local cAliasSB8   := 'SB8'
	Local cCodPrd     := ""
	Local cDValSD4    := Replicate('z', Len(DtoS(SD4->D4_DTVALID)))
	Local cEndCheck   := ''
	Local cLocalCons  := ""
	Local cLote       := ""
	Local cLoteSD4    := Replicate('z', Len(SD4->D4_LOTECTL))
	Local cOpCons     := ""
	Local cOPOrigSD4  := Replicate('z', Len(SD4->D4_OPORIG))
	Local cProdBxSD4  := ''
	Local cQuery      := ''
	Local cSLoteSD4   := Replicate('z', Len(SD4->D4_NUMLOTE))
	Local cTrtBxSD4   := ''
	Local dEmissao    := If(l250, M->D3_EMISSAO, dDataBase)
	Local lA250QtBx   := ExistBlock("A250QTBX")
	Local lBaixa2     := .F. 
	Local lBxComp     := .F.
	Local lConsidera  := .F.
	Local lConsRegD4  := .T.
	Local lConsumo    := .F.
	Local lEmpPrev    := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
	Local lFirst      := .F.
	Local lIncremen   := .F.
	Local lLote2      := .F. 
	Local lRetParPrd  := .F.
	Local lSeekSDC    := .T.
	Local lWmsNew     := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local nAchouSD4   := 0
	Local nBaixaBx2SD4:= 0
	Local nBaixaBxSD4 := 0
	Local nI          := 0
	Local nPercPrM	  := 0
	Local nPos        := 0
	Local nPos2       := 0 
	Local nPosItems   := 0
	Local nQtdBxPE    := 0
	Local nQtdCons    := 0
	Local nQtdGanho   := If(l250, M->D3_QTGANHO, M->H6_QTGANHO)
	Local nQtdMaior   := If(l250, M->D3_QTMAIOR, M->H6_QTMAIOR)
	Local nQtdPrdAnt  := 0
	Local nQtdProd    := If(l250, M->D3_QUANT, M->H6_QTDPROD)
	Local nQuantBx2SD4:= 0
	Local nQuantBxSD4 := 0
	Local nQuantDC    := 0
	Local nQuantDC2   := 0
	Local nQuantProd  := 0
	Local nQtd8       := 0
	Local nRecSDC     := 0
	Local nTam        := Len(cOp)
	Local oSqlLogDoc  := Nil
	Local RetRastro
	Local RetRastro2
	Local RetSB8Sald
	Local lUsaTRT	  := SuperGetMV("MV_USATRT",.F.,.T.)
	Local cTrtVazio	  := CriaVar("D4_TRT",.F.)

	Default cParcTot  := If(l250, M->D3_PARCTOT, M->H6_PT)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para definir    Ё
	//Ё endereco a ser verificado                                    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250ChkEn == NIL
		lA250ChkEn := ExistBlock("A250CHEN")
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250FilD4 == NIL
		lA250FilD4 := ExistBlock("A250FSD4")
	EndIf

	If nParPercPrM == NIL
		nParPercPrM := 0
	EndIf

	lRetBen  := IIF(lRetBen ==NIL, .F., lRetBen)
	cChaveF1 := IIF(cChaveF1==NIL, "", cChaveF1)

	aTamSX3:=TamSX3("D3_QUANT")
	nDecSD3:=aTamSX3[2]
	aTamSX3:=TamSX3("D4_QUANT")
	nDecSD4:=aTamSX3[2]

	If cIndNeg == "E"
		cIndNeg := cEstNeg
	EndIf

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(cOP) )

	If fRetParPrd(cOP) //A250Estoq
		lRetParPrd := .T.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Posiciona no arquivo de OP's                       Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
	SC2->( dbSetOrder(1) )
	SC2->( dbSeek(xFilial("SC2")+cOP) )

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Atualiza arquivo de empenhos e B2_QEMP     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддды
	If nQuantBx > 0

		lBxComp := fCompOper(cOP)

		If lA250QtBx
			nQtdBxPE := ExecBlock("A250QTBX",.F.,.F.,{cProduto,cOP,nQuantBx,SC2->C2_QUANT,cParcTot})
			If ValType(nQtdBxPE) == "N"
				nQuantBx := nQtdBxPE
			EndIf
		EndIf

		If !IsInCallStack("MATA680") .AnD. !IsInCallStack("MATA681")
			If lRetParPrd
				nIndice := Min(1,nQuantBx / SC2->C2_QUANT)
			Else				
				If cBxProp == "S" .And. cParcTot == "P"
					nIndice := Min(1,nQuantBx / SC2->C2_QUANT)
				EndIf
			EndIf 
		Else
			//Quando existe Componente x OperaГЦo nЦo deve considerar a Perda das operaГУes anteriores
        	//A perda da operaГЦo anterior jА foi requisitada na prСpria operaГЦo
        	If lPerdInf
        		nQtdPrdAnt := 0
        	Else
        		If lBxComp
        			nQtdPrdAnt := 0 
        		Else
        			nQtdPrdAnt := M->H6_PERDANT
        		EndIf
        	EndIf

			If cBxProp == "S" .And. cParcTot == "P"
				nIndice := Min(1,(nQuantBx + nQtdPrdAnt) / SC2->C2_QUANT)
			EndIf

			If cBxProp == "S" .And. cParcTot == "T" .And. GetMV("MV_BXSD4TL",.F.,.T.) == .F.
				nIndice := Min(1,nQuantBx + nQtdPrdAnt / SC2->C2_QUANT)
			EndIf
		EndIf

		If Type("l681Auto") == "L" .And. l681Auto .And. Type("aRotAuto") == "A"
			nPos := aScan(aRotAuto,{|x|Upper(AllTrim(x[1]))=="AUTCONSUMO"})
			If nPos > 0
				lConsumo := .T.
				aConsumo := aRotAuto[nPos,2]
			EndIf
		EndIf

		If lConsumo
			nPosItems := aScan(aConsumo,{|x|Upper(AllTrim(x[1]))=="AUTITEMS"})
			If nPosItems > 0 .And. Len(aConsumo[nPosItems,2]) > 0
				For nI := 1 To Len(aConsumo[nPosItems,2])
					cCodPrd     := ""
					cLocalCons  := ""
					nQtdCons    := 0
					cLote       := ""
					cOpCons     := ""
					nPos := aScan(aConsumo[nPosItems,2,nI],{|x| x[1]=="D3_COD"})
					If nPos > 0
						cCodPrd := aConsumo[nPosItems,2,nI,nPos,2]
					EndIf
					nPos := aScan(aConsumo[nPosItems,2,nI],{|x| x[1]=="D3_LOCAL"})
					If nPos > 0
						cLocal := aConsumo[nPosItems,2,nI,nPos,2]
					EndIf
					nPos := aScan(aConsumo[nPosItems,2,nI],{|x| x[1]=="D3_QUANT"})
					If nPos > 0
						nQuant := aConsumo[nPosItems,2,nI,nPos,2]
					EndIf
					nPos := aScan(aConsumo[nPosItems,2,nI],{|x| x[1]=="D3_LOTECTL"})
					If nPos > 0
						cLote := aConsumo[nPosItems,2,nI,nPos,2]
					EndIf
					nPos := aScan(aConsumo[nPosItems,2,nI],{|x| x[1]=="D3_OP"})
					If nPos > 0
						cOp := aConsumo[nPosItems,2,nI,nPos,2]
					EndIf
					//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Adiciona registro em array organizado por empenho Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддды
					If Len(aArraySD4[Len(aArraySD4)]) > 4095
						AADD(aArraySD4,{})
					EndIf
					AADD(aArraySD4[Len(aArraySD4)],{0,;			//1
					nIndice,;		//2
					cCodPrd,;		//3
					cLocalCons,;	//4
					"",;				//5
					"",;         	//6
					nQtdCons,;		//7
					"",;				//8
					cLote,;			//9
					"",;				//10
					cOpCons,;		//11
					nQtdCons,; 	//12
					nQtdCons,; 	//13
					0})				//14
				Next nI
			EndIf

		Else
			aBaixLote := {}

			dbSelectArea("SD4")
			dbSetOrder(2)
			dbSeek(xFilial("SD4")+cOp)
			While !EOF() .And. D4_FILIAL+Substr(D4_OP,1,nTam)==xFilial("SD4")+cOp
				RetRastro := Rastro(SD4->D4_COD)

				If aBaixaComp # NIL .And. (aScan(aBaixaComp, {|z| z[1] + z[2] == SD4->(D4_COD + D4_TRT)}) == 0)
					dbSkip()
					Loop
				EndIf

				If aBaixaComp == NIL .And. aChkBaixaC # NIL .And. aScan(aChkBaixaC, {|z| z[1] + z[2] == SD4->(D4_COD + D4_TRT)}) > 0
					dbSkip()
					Loop
				EndIf

				lQtLote := 1
				If a250VeQtNe(cParcTot,nQtdProd, nQtdGanho, nQtdMaior)
					If RetRastro
						lQtLote := a250QtLote(SD4->D4_OP, SD4->D4_COD, SD4->D4_TRT)
					EndIf
				EndIf

				lConsRegD4:=.T.
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If lA250FilD4
					lConsRegD4:=ExecBlock("A250FSD4",.F.,.F.,{nIndice,.F.})
					If ValType(lConsRegD4) != "L"
						lConsRegD4:=.T.
					EndIf
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Nao baixa se filtrar empenho                                       Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !lConsRegD4.Or.IsProdMod(SD4->D4_COD)
					dbSkip()
					Loop
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Nao baixa se empenho foi criado por diferen┤a. Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддды
				//If Rastro(D4_COD) .And. Empty(IF(RASTRO(D4_COD,"S"),D4_NUMLOTE,D4_LOTECTL)) .And. !Empty(D4_OPORIG) .And.  lProdAut .And. Empty(A250QuJe(D4_OPORIG))
				//	dbSkip()
				//	Loop
				//EndIf
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Se o parametro MV_REQAUT indicar que as requisicoes   Ё
				//Ё de materiais diretos sao digitadas entao ele baixara' Ё
				//Ё apenas materiais indiretos , diferentes de MOD , pois Ё
				//Ё a decisao de baixar ou nao a MOD esta' no TM pelo cam-Ё
				//Ё po F5_TRANMOD = "S".                                  Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				dbSelectArea("SB1")
				dbSeek(xFilial("SB1")+SD4->D4_COD)
				cApropri := "1"
				If B1_APROPRI == "I"
					cApropri := "2"
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica o local a ser baixado           Ё
				//юдддддддддддддддддддддддддддддддддддддддддды
				If cApropri == "2"
					cLocReq := cLocProc
				Else
					cLocReq := SD4->D4_LOCAL
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se ira gerar uma Devolucao ou   Ё
				//Ё requisicao, e analisa se o processo sera Ё
				//Ё automatico ou manual.                    Ё
				//юдддддддддддддддддддддддддддддддддддддддддды
				If (QtdComp(SD4->D4_QUANT,.T.) < QtdComp(0,.T.) .And. QtdComp(SD4->D4_QTDEORI,.T.) < QtdComp(0,.T.))
					If cDevAut == "D" .And. cApropri == "1" .And. !IsProdMod(SD4->D4_COD)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				Else
					If cReqAut == "D" .And. cApropri == "1" .And. !IsProdMod(SD4->D4_COD)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				EndIf

				nPercPrM := RetPerMIt(nParPercPrM)

				//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Adiciona registro em array totalizador por produtoЁ
				//юддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(aProdsSD4[Len(aProdsSD4)]) > 4095
					AADD(aProdsSD4,{})
				EndIf
				For i:=1 to Len(aProdsSD4)
					nAchouSD4:=ASCAN(aProdsSD4[i],{ |x| x[1] == SD4->D4_COD .And. Iif(lUsaTRT,x[3] == SD4->D4_TRT,.T.)})
					If nAchouSD4 != 0
						If !a250VeQtNe(cParcTot,nQtdProd, nQtdGanho, nQtdMaior)

							//DMANSMARTSQUAD1-20099 - Vivian - 03/02/21 - Efetuado arredondamento antes de somar no aProdsSD4 para utilizar a mesma regra de quando adiciona no array
							nQtdAux2  := A250CalcD4(SD4->D4_QTDEORI,nIndice,cParcTot,SD4->D4_QUANT)
							nQtdAux4  := A250CalcD4(SD4->D4_QTSEGUM,nIndice)
							
							aProdsSD4[i,nAchouSD4,2] += A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nQtdAux2,nDecSD4)
							aProdsSD4[i,nAchouSD4,4] += A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nQtdAux4,nDecSD4)
							Exit
						EndIf
					EndIf
				Next i
				If nAchouSD4 ==0
					nqtd := A250CalcD4(SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM),nIndice,cParcTot,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM))
					nqtd := a250QtdNec(nqtd, nQtdProd, nQtdGanho, nQtdMaior, cParcTot)

					AADD(aProdsSD4[Len(aProdsSD4)],{SD4->D4_COD,A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,nqtd,nDecSD4),Iif(lUsaTRT,SD4->D4_TRT,cTrtVazio),A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,A250CalcD4(SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM),nIndice),nDecSD4)})
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Nao baixa se quantidade estiver zerada                             Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !IsInCallStack("MATA250") .AnD. !IsInCallStack("MATA680") .AnD. !IsInCallStack("MATA681")
					If QtdComp(SD4->D4_QUANT,.T.)=QtdComp(0,.T.)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				Else
					If !lExistePM
						If QtdComp(SD4->D4_QUANT,.T.)=QtdComp(0,.T.)
							dbSelectArea("SD4")
							dbSkip()
							Loop
						EndIf
					EndIf
				EndIf

				// Retorno de beneficiamento que ja requisitou (RE5) e baixou empenhos do produto nao deve requisitar/baixar novamente
				If lRetBen .And. FindFunction("MTBuscaRE5")
					If MTBuscaRE5(cChaveF1, SD4->D4_COD, SD4->D4_OP)
						dbSelectArea("SD4")
						dbSkip()
						Loop
					EndIf
				EndIf

				//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Adiciona registro em array organizado por empenho Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(aArraySD4[Len(aArraySD4)]) > 4095
					AADD(aArraySD4,{})
				EndIf

				nQtd8 := 0
				nQtd7 := A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),nDecSD4)
				nQtd7 := a250QtdNec(nQtd7, nQtdProd, nQtdGanho, nQtdMaior, cParcTot)
				nQtd8 := nQtd7
				nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)

				If a250VeQtNe(cParcTot, nQtdProd, nQtdGanho, nQtdMaior)
					If RetRastro .And. lQtLote > 1 .And. nQtdMaior > 0
						nQtd7 := A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),nDecSD4)
					Else
						If RetRastro .And. lQtLote > 1  .And. nQtdMaior == 0
							nAchouBaix := ASCAN(aBaixLote,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT })
							If nAchouBaix == 0
								AADD(aBaixLote, {SD4->D4_COD, SD4->D4_TRT,nQtd7, 0})
							EndIf

							nAchouBaix := ASCAN(aBaixLote,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT })
							If nAchouBaix > 0
								If aBaixLote[nAchouBaix,3] - aBaixLote[nAchouBaix,4] > 0
									If SD4->D4_QUANT != 0
										If (aBaixLote[nAchouBaix,3] - aBaixLote[nAchouBaix,4]) > SD4->D4_QUANT
											nQtd7 := SD4->D4_QUANT
											nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)
										Else
											nQtd7 := aBaixLote[nAchouBaix,3] - aBaixLote[nAchouBaix,4]
											nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)
										EndIf
										aBaixLote[nAchouBaix,4] += nQtd7
									Else
										nQtd7 := 0
									EndIf
								Else
									nQtd7 := 0
								EndIf
							EndIf
						Else
							nQtd7 := A250AvalQt(nQtd7,SD4->D4_COD)
						EndIf
					EndIf
				EndIf

				AADD(aArraySD4[Len(aArraySD4)],{	SD4->(Recno()),;			//1
													nIndice,;					//2
													SD4->D4_COD,;				//3
													Alltrim(SD4->D4_LOCAL),;	//4
													SD4->D4_TRT,;				//5
													SD4->D4_OPORIG,;           	//6
													nQtd7,; 	                //7
													DTOS(SD4->D4_DTVALID),;	    //8
													SD4->D4_LOTECTL,;			//9
													SD4->D4_NUMLOTE,;			//10
													SD4->D4_OP,;				//11
													A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM),nDecSD4),; //12
													A250PotMax(SD4->D4_COD,SD4->D4_POTENCI,SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM),nDecSD4),; //13
													SD4->D4_POTENCI,; //14
													SD4->D4_QTDEORI}) //15
				
				//If ( IsInCallStack("MATA680") .OR. IsInCallStack("MATA681")) .And. nQtdMaior > 0
				If nQtdMaior > 0
					lIncremen := .F.
					DbSelectArea("SB1")
					SB1->(DbSetOrder(1))
					SB1->(dbSeek(xFilial('SB1')+SD4->D4_COD))
					If SB1->B1_TIPODEC = 'I'
						lIncremen := .T.
					EndIf 
					If lIncremen 
						lLote2 := ExistLote(SD4->D4_COD,SD4->D4_TRT,SD4->D4_OP)
						lConsidera := lIncremen .and. !lLote2
						If lConsidera
							AADD(aArrayAux[Len(aArraySD4)],{	SD4->(Recno()),;
																SD4->D4_COD,;	
																Alltrim(SD4->D4_LOCAL),;
																SD4->D4_TRT,;
																nQtd7,;
																SD4->D4_OP,;
																nQtd8})
						EndIf
					EndIf
				EndIf
				
				dbSelectArea("SD4")
				dbSkip()
			End
		EndIf

		//DMANSMARTSQUAD1-21141 - Vivian - //DMANSMARTSQUAD1-21141 - Comentado - o arredondamento serА efetuado depois que o array aProdsSD4 estiver todo alimentado 		
		For w:=1 to Len(aProdsSD4)		
			For z:=1 to Len(aProdsSD4[w])						
				If aProdsSD4[w,z,1] != ' ' .And. aProdsSD4[w,z,2] > 0
			   		aProdsSD4[w,z,2] := RetQtdArred(aProdsSD4[w,z,2],nDecSD4)				   			   		
				EndIf

				If aProdsSD4[w,z,1] != ' ' .And. aProdsSD4[w,z,4] > 0
					aProdsSD4[w,z,4] := RetQtdArred(aProdsSD4[w,z,4],nDecSD4)
				EndIf
			Next z
		Next w
        //Fim DMANSMARTSQUAD1-21141 

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Ordena array para utilizar empenhos mais "INTELIGENTES" primeiroЁ
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		For i:=1 to Len(aArraySD4)
			//-- Forca os Empenhos sem Lote/SubLote/Dt.Valid./OP Origem a ficarem por ultimo na Indexacao
			For z:=1 to Len(aArraySD4[i])
				If Rastro(aArraySD4[i,z,3]) .And. Empty(aArraySD4[i,z,9])
					If !lRetParPrd
						If Empty(aArraySD4[i,z,6])
							aArraySD4[i,z,6] := cOPOrigSD4
						EndIf
					EndIf
					aArraySD4[i,z,9] := cLoteSD4
					If Empty(aArraySD4[i,z,8])
						aArraySD4[i,z,8] := cDValSD4
					EndIf
					If Rastro(aArraySD4[i,z,3], 'S') .And. Empty(aArraySD4[i,z,10])
						aArraySD4[i,z,10] := cSLoteSD4
					EndIf
				EndIf
			Next z
			If lUsaTRT
				ASORT(aArraySD4[i],,,{ |x,y| x[3]+x[5]+x[6]+x[8]+x[9]+x[10] < y[3]+y[5]+y[6]+y[8]+y[9]+y[10]})
			Else
				ASORT(aArraySD4[i],,,{ |x,y| x[3]+x[6]+x[8]+x[9]+x[10] < y[3]+y[6]+y[8]+y[9]+y[10]})
			EndIf
			//-- Retorna os Empenhos sem Lote/SubLote/Dt.Valid./OP Origem ao formato original
			For z:=1 to Len(aArraySD4[i])
				If aArraySD4[i,z,9] == cLoteSD4
					If !lRetParPrd
						If aArraySD4[i,z,6] == cOPOrigSD4
							aArraySD4[i,z,6] := Space(Len(aArraySD4[i,z,6]))
						EndIf
					EndIf
					aArraySD4[i,z,9] := Space(Len(aArraySD4[i,z,9]))
					If aArraySD4[i,z,8] == cDValSD4
						aArraySD4[i,z,8] := Space(Len(aArraySD4[i,z,8]))
					EndIf
					If aArraySD4[i,z,10] == cSLoteSD4
						aArraySD4[i,z,10] := Space(Len(aArraySD4[i,z,10]))
					EndIf
				EndIf
			Next z
		Next i

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Percorre array para adequar atraves do indice de producao quais Ё
		//Ё empenhos serao utilizados.                                      Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		For i:=1 to Len(aArraySD4) // A250Estoq
			For z:=1 to Len(aArraySD4[i])

				//Ajusta QTD aArraySD4
				If Len(aArrayAux[i]) > 1
					aArraySD4[i,z,7] := a250AjQtd(i,z,aArraySD4,aArrayAux)
				EndIf

				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Pesquisa quantidade para este produto no empenho                Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !(aArraySD4[i,z,3] == cProdBxSD4 .And. Iif(lUsaTRT,aArraySD4[i,z,5] == cTrtBxSD4,.T.))
					For w:=1 to Len(aProdsSD4)
						nAchouSD4:=ASCAN(aProdsSD4[w],{ |x| x[1] == aArraySD4[i,z,3] .And. Iif(lUsaTRT,x[3] == aArraySD4[i,z,5],.T.)})
						If nAchouSD4 != 0
							nQuantBxSD4 := A250AvalQt(aProdsSD4[w,nAchouSD4,2],aArraySD4[i,z,3])
							nQuantBx2SD4:= A250AvalQt(aProdsSD4[w,nAchouSD4,4],aArraySD4[i,z,3])

							nQuantProd := A250AvalQt(aProdsSD4[w,nAchouSD4,2],aArraySD4[i,z,3])
							Exit
						EndIf
					Next w
					cProdBxSD4 := aArraySD4[i,z,3]
					cTrtBxSD4  := aArraySD4[i,z,5]
				EndIf
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Efetua o calculo de quanto sera baixado em cada empenho         Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

				// FunГЦo - A250Estoq - ValidaГЦo saldo
				If QtdComp(nQuantBxSD4,.T.) != QtdComp(0,.T.) .Or. (!Empty(aArraySD4[i,z,6]) .And. lRetParPrd)
					SD4->(dbGoTo(aArraySD4[i,z,1]))
					nPercPrM := RetPerMIt(nParPercPrM)

					nBaixaBxSD4:=Min(QtdComp(nQuantBxSD4),QtdComp(aArraySD4[i,z,7]))
					nBaixaBx2SD4:=Min(QtdComp(nQuantBx2SD4),QtdComp(aArraySD4[i,z,13]))
					
					If !lRetParPrd
						If QtdComp(nBaixaBxSD4) < QtdComp(aArraySD4[i,z,7]) .and. nPercPrM <= 0
							aArraySD4[i,z,2]:=nBaixaBxSD4/aArraySD4[i,z,7]
						Else
							aArraySD4[i,z,2]:=1
						EndIf
					Else
						aArraySD4[i,z,2]:=nBaixaBxSD4						
					EndIf

					nQuantBxSD4-=nBaixaBxSD4
					nQuantBx2SD4-=nBaixaBx2SD4
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Caso tenha baixado toda a quantidade necessaria, passa o indice Ё
					//Ё dos empenhos restantes para ZERO.                               Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				Else
					aArraySD4[i,z,2]:=0
				EndIf
			Next z
		Next i
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Monta Array aASaldo que soma as quantidades de produГЦo a maior       \\
		//Ё que foram separadas proporcional na SD4.                              \\ 
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды		
		If nQtdMaior > 0 
			For i:=1 to Len(aArraySD4)
				For w:= 1 to Len(aArraySD4[i])
					DbSelectArea("SB1")
					SB1->(DbSetOrder(1))
					SB1->(dbSeek(xFilial('SB1')+aArraySD4[i,w,3]))
					If SB1->B1_TIPODEC = 'I'
						lIncremen := .T.
					EndIf 
					If lIncremen 
						lLote2 := ExistLote(aArraySD4[i,w,3],aArraySD4[i,w,5],cOP)
						lConsidera := lIncremen .and. !lLote2

						If Empty(aASaldo)	
							Aadd(aASaldo,{aArraySD4[i,w,3],aArraySD4[i,w,4],aArraySD4[i,w,5],(aArraySD4[i,w,15]*nPercPrM),lConsidera})
						Else	
							nPos2 := Ascan(aASaldo,{|x| x[1] == aArraySD4[i,w,3]})
							If nPos2 > 0 
								aASaldo[nPos2][4] += (aArraySD4[i,w,15]*nPercPrM)
							else
								Aadd(aASaldo,{aArraySD4[i,w,3],aArraySD4[i,w,4],aArraySD4[i,w,5],(aArraySD4[i,w,15]*nPercPrM),lConsidera})
							EndIf 
						Endif
					EndIf
				Next w
			Next i 
		EndIf 
		//здддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Percorre array para VERIFICAR SALDO.           Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддды		
		For i:=1 to Len(aArraySD4)
			For w:= 1 to Len(aArraySD4[i])
				RetRastro2 := Rastro(aArraySD4[i,w,3])
				If aArraySD4[i,w,2] != 0
					If !lRetParPrd
						lBaixa2 := .F.
						If !Empty(aASaldo) .and. nQtdMaior > 0
							nPos2 := Ascan(aASaldo,{|x| x[1] == aArraySD4[i,w,3]})
							aASaldo[nPos2][4] := Round(aASaldo[nPos2][4],8) 
							If nPos2 > 0 
								If (aASaldo[nPos2][4] - int(aASaldo[nPos2][4])) == 0 
									lBaixa2 := .T.
									nQuantBxSD4   :=A250PotOrg(aArraySD4[i,w,3],aArraySD4[i,w,14],A250CalcD4(aArraySD4[i,w,7],aArraySD4[i,w,2],aArraySD4[i,w,3]),nDecSD4)
									nQuantBx2SD4  :=A250PotOrg(aArraySD4[i,w,3],aArraySD4[i,w,14],A250CalcD4(aArraySD4[i,w,13],aArraySD4[i,w,2],aArraySD4[i,w,3]),nDecSD4)								
								Else 
									lBaixa2 := .F.
								EndIf 
							EndIf 
						EndIf
						If !lBaixa2 
							nQuantBxSD4   :=A250PotOrg(aArraySD4[i,w,3],aArraySD4[i,w,14],A250AvalQt(A250CalcD4(aArraySD4[i,w,7],aArraySD4[i,w,2]),aArraySD4[i,w,3]),nDecSD4)
							nQuantBx2SD4  :=A250PotOrg(aArraySD4[i,w,3],aArraySD4[i,w,14],A250AvalQt(A250CalcD4(aArraySD4[i,w,13],aArraySD4[i,w,2]),aArraySD4[i,w,3]),nDecSD4)
						EndIf 
					Else
						nQuantBxSD4   :=A250PotOrg(aArraySD4[i,w,3],aArraySD4[i,w,14],A250AvalQt(A250CalcD4(aArraySD4[i,w,2],1),aArraySD4[i,w,3]),nDecSD4)
						nQuantBx2SD4  :=A250PotOrg(aArraySD4[i,w,3],aArraySD4[i,w,14],A250AvalQt(A250CalcD4(aArraySD4[i,w,2],1),aArraySD4[i,w,3]),nDecSD4)
					EndIf
					
					SB2->(dbSeek(xFilial("SB2")+aArraySD4[i,w,3]+aArraySD4[i,w,4]))
					SB1->(dbSeek(xFilial("SB1")+aArraySD4[i,w,3]))
					cApropri := If(SB1->B1_APROPRI == "I","2","1")

					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Verifica se a quantidade de casas decimais na SD4 И igual ao calculado          Ё
					//Ё Se nЦo for, serА arredondado o valor calculado com base nas casas decimais      Ё
					//Ё da SD4 para nЦo acontecer falta de saldo ao baixar os empenhos                  Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ncontador:= A250contde(nQuantBxSD4)
					if ncontador > nDecSD4
						nQuantBxSD4 := Round(nQuantBxSD4,nDecSD4)
					EndIf

					ncontador:= A250contde(nQuantBx2SD4)
					if ncontador > nDecSD4
						nQuantBx2SD4 := Round(nQuantBx2SD4,nDecSD4)
					EndIf

					//-- Verifica bloqueio de Armazem
					If A250Bloq(aArraySD4[i,w,3],aArraySD4[i,w,4],aArraySD4[i,w,11])
						AADD(aSaldo,{aArraySD4[i,w,3],aArraySD4[i,w,4],SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao),0,0,"S",aArraySD4[i,w,9],aArraySD4[i,w,10]})
					EndIf

					nElem := Ascan(aReqsOK,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4]})
					If nElem == 0
						nQtdUsada := 0
						AADD(aReqsOk,{aArraySD4[i,w,3],aArraySD4[i,w,4],nQuantBxSD4})
					Else
						nQtdUsada := aReqsOk[nElem,3]
						aReqsOk[nElem,3] += nQuantBxSD4
					EndIf
					// Verifica se material nao ┌ de apropriacao indireta
					// ou se permite qtd negativa qdo apropriacao indireta
					If (cIndNeg == "N" .And. cApropri == "2") .Or. (cEstNeg == "N" .And. cApropri == "1") .Or. RetRastro2 .Or. Localiza(aArraySD4[i,w,3],.T.)
						
						If !lRetParPrd
							If Empty(aArraySD4[i,w,9])
								nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4] .And. Empty(x[7]) })
							Else
								nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4] .And. x[7] == aArraySD4[i,w,9] })
							EndIf
						Else
							nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4] .And. Empty(x[7]) })
						EndIf
						
						If nElem == 0
							AADD(aSaldo,{aArraySD4[i,w,3],aArraySD4[i,w,4],SaldoMov(Nil,.F.,Nil,A250PARTERC()==1,Nil,Nil,Nil,dEmissao) - nQuantBxSD4 - nQtdUsada,0,0,"S",aArraySD4[i,w,9],aArraySD4[i,w,10]})
							lFirst := .T.
						Else						
							If nQuantBxSD4 <= aSaldo[nElem,3]
								aSaldo[nElem,3] -= nQuantBxSD4
							Else
								lValEst := a250EstPrd(nQuantBxSD4, aArraySD4, aSaldo[nElem,3], nDecSD4, i,w)

								If lValEst
									aSaldo[nElem,3] := 0 
								Else
									aSaldo[nElem,3] -= nQuantBxSD4
								EndIf
							EndIf

							If lRetParPrd .And. !Empty(aArraySD4[i,w,9])
								aSaldo[nElem,4] -= nQuantBxSD4
							EndIf
							lFirst := .F.							
						EndIf						
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Tratamento referente a localizacao fisica  Ё
					//юдддддддддддддддддддддддддддддддддддддддддддды
					If Localiza(aArraySD4[i,w,3],.T.)
						dbSelectArea("SDC")
						dbSetOrder(2)
						// Procura por empenho sem lotes
						If !(RetRastro2)
							cSeek:=xFilial("SDC")+aArraySD4[i,w,3]+aArraySD4[i,w,4]+aArraySD4[i,w,11]+aArraySD4[i,w,5]
							cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"
						Else
							If Rastro(aArraySD4[i,w,3],"L")
								// Procura por empenho com lote
								cSeek:=xFilial("SDC")+aArraySD4[i,w,3]+aArraySD4[i,w,4]+aArraySD4[i,w,11]+aArraySD4[i,w,5]+aArraySD4[i,w,9]
								cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL"
							Else
								// Procura por empenho com lote+sub-lote
								cSeek:=xFilial("SDC")+aArraySD4[i,w,3]+aArraySD4[i,w,4]+aArraySD4[i,w,11]+aArraySD4[i,w,5]+aArraySD4[i,w,9]+aArraySD4[i,w,10]
								cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE"
							EndIf
						EndIf
						//здддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Caso nao encontre os empenhos no SDC ou    Ё
						//Ё nao tenha quantidade suficiente empenhada, Ё
						//Ё Valida o saldo distribuido.                Ё
						//юдддддддддддддддддддддддддддддддддддддддддддды
						lSeekSDC:=dbSeek(cSeek)
						If lSeekSDC
							nRecSDC:=Recno()
							nQuantDC:=0
							nQuantDC2:=0
							Do While !Eof() .And. cSeek == &cCompara
								nQuantDC+=DC_QUANT
								nQuantDC2+=DC_QTSEGUM
								dbSkip()
							EndDo
							If nQuantDC < nQuantBxSD4
								lSeekSDC:=.F.
							EndIf
							MsGoto(nRecSDC)
						EndIf

						If !lSeekSDC

							// Executa ponto de entrada para checar endereco especifico
							If lA250ChkEn
								cEndCheck:=ExecBlock("A250CHEN",.F.,.F.,{aArraySD4,i,w})
								If ValType(cEndCheck) # "C"
									cEndCheck:=""
								EndIf

								//-- Tratamento para verificar saldo existente na tabela SBF para o Endereco a ser validado.
								If !Empty(cEndCheck) .And. ( (cIndNeg == "N" .And. cApropri == "2") .Or. (cEstNeg == "N" .And. cApropri == "1") .Or. Localiza(aArraySD4[i,w,3],.T.) )
									nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4]})
									If nElem > 0
										If lFirst
											If !(lWmsNew .And. IntWms(aArraySD4[i,w,3]))
												aSaldo[nElem,3] := SaldoSBF(aArraySD4[i,w,4],cEndCheck,aArraySD4[i,w,3],"",aArraySD4[i,w,9],aArraySD4[i,w,10],NIL,NIL,PotencLote(aArraySD4[i,w,3])) - nQuantBxSD4 - nQtdUsada
											Else
												aSaldo[nElem,3] := WmsSldD14(aArraySD4[i,w,4],cEndCheck,aArraySD4[i,w,3],"",aArraySD4[i,w,9],aArraySD4[i,w,10],.F./*lBaixaEmp*/,.T./*lProducao*/) - nQuantBxSD4 - nQtdUsada
											EndIf
										EndIf
									EndIf
								EndIf

							EndIf

							If !(lWmsNew .And. IntWms(aArraySD4[i,w,3]))
								nSaldo:=SaldoSBF(aArraySD4[i,w,4],cEndCheck,aArraySD4[i,w,3],"",aArraySD4[i,w,9],aArraySD4[i,w,10],NIL,NIL,PotencLote(aArraySD4[i,w,3]))
							Else
								nSaldo:=WmsSldD14(aArraySD4[i,w,4],cEndCheck,aArraySD4[i,w,3],"",aArraySD4[i,w,9],aArraySD4[i,w,10],.F./*lBaixaEmp*/,.T./*lProducao*/)
							EndIf

							//-- Soma o saldo empenhado para a propria OP
							nSaldo+=(SldEmpOP(aArraySD4[i,w,3],aArraySD4[i,w,4],aArraySD4[i,w,9],aArraySD4[i,w,10],cOP,,,"L")[1])

							If (nSaldo - nQuantBxSD4) < 0
								nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4]})
								If nElem == 0
									AADD(aSaldo,{aArraySD4[i,w,3],Alltrim(aArraySD4[i,w,4]),0,0,nSaldo-nQuantBxSD4,"S",,aArraySD4[i,w,9],aArraySD4[i,w,10]})
								ElseIf aSaldo[nElem,6] == "S"
									aSaldo[nElem,5] := nSaldo - nQuantBxSD4
									aSaldo[nElem,6] := "N"
								Else
									If nQuantBxSD4 <= aSaldo[nElem,5]
										aSaldo[nElem,5] -= nQuantBxSD4
									Else
										lValEst := a250EstPrd(nQuantBxSD4, aArraySD4, aSaldo[nElem,5], nDecSD4, i,w)

										If lValEst
											aSaldo[nElem,5] := 0 
										Else
											aSaldo[nElem,5] -= nQuantBxSD4
										EndIf
									EndIf
									//aSaldo[nElem,5] -= nQuantBxSD4
								EndIf
							EndIf
						EndIf
					EndIf

					If RetRastro2
						dbSelectArea("SB8")
						nOrdSB8 := IndexOrd()
						nRecSB8 := RecNo()
						nSaldo := 0
						// Caso nao preencheu o Lote no empenho e verifica potencia
						If Empty(aArraySD4[i,w,9]+aArraySD4[i,w,10])
							// Quantidade Original na potencia maxima
							nBaixaBXSD4:=A250PotMax(aArraySD4[i,w,3],aArraySD4[i,w,14],nQuantBxSD4,nDecSD4)
							SB8-> (dbSetOrder(1))
							cAliasSB8 := GetNextAlias()
							IF oSqlLogDoc == nil
								cQuery := "SELECT * FROM "+RetSqlName("SB8")+" SB8 "
								cQuery += "WHERE SB8.B8_FILIAL='"+xFilial("SB8")+"' AND "
								cQuery += "SB8.B8_PRODUTO = ?  AND "
								cQuery += "SB8.B8_LOCAL = ?  AND "
								cQuery += "SB8.B8_SALDO > 0 AND SB8.D_E_L_E_T_=' ' "
								cQuery += "ORDER BY "+SqlOrder(SB8->(IndexKey()))

								cQuery := ChangeQuery(cQuery)
								oSqlLogDoc := FWPreparedStatement():New(cQuery)

							EndIf
							oSqlLogDoc:SetString(1, aArraySD4[i,w,3]  )
							oSqlLogDoc:SetString(2, aArraySD4[i,w,4]  )

							cQuery := oSqlLogDoc:GetFixQuery()
							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8,.T.,.T.)
							aEval(SB8->(dbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSB8,x[1],x[2],x[3],x[4]),NIL)})
							dbSelectArea(cAliasSB8)
							While !(cAliasSB8)->(Eof()) .And. nBaixaBXSD4 > 0 .And. (cAliasSB8)->B8_FILIAL+(cAliasSB8)->B8_PRODUTO+(cAliasSB8)->B8_LOCAL == xFilial("SB8")+PADR(aArraySD4[i,w,3],tamSX3('B8_PRODUTO')[1])+PADR(aArraySD4[i,w,4],tamSX3('B8_LOCAL')[1])
								RetSB8Sald := SB8Saldo(,,,,cAliasSB8,lEmpPrev,,dEmissao)
								nSaldo += A250PotMax((cAliasSB8)->B8_PRODUTO,(cAliasSB8)->B8_POTENCI,RetSB8Sald,nDecSD4)
								nBaixaBXSD4 -= Min(nBaixaBxSD4,A250PotMax((cAliasSB8)->B8_PRODUTO,(cAliasSB8)->B8_POTENCI,RetSB8Sald,nDecSD4))
								dbSkip()
							EndDo
							dbCloseArea()
						Else
							SD4->(dbGoTo(aArraySD4[i,w,1]))
							nPercPrM := RetPerMIt(nParPercPrM)

							aArray:=SldPorLote(aArraySD4[i,w,3],aArraySD4[i,w,4],nQuantBxSD4,nQuantBx2SD4,aArraySD4[i,w,9],aArraySD4[i,w,10],,,,.T.,,,,,dEmissao,,aArraySD4[i,w,11],,nPercPrM,,aArraySD4[i,w,15])

							If a250VeQtN1(aArraySD4[i,w,3])
								For xi:=1 to Len(aArray)
									aArray[xi,5] := A250AvalQt(aArray[xi,5],aArraySD4[i,w,3])

									For zi:=1 to Len(aArray[xi,10])
										MsGoto(aArray[xi,10,zi,1])
										aArray[xi,10,zi,2] := A250AvalQt(aArray[xi,10,zi,2],aArraySD4[i,w,3])
									Next zi
								Next xi
							EndIf

							For xi:=1 to Len(aArray)
								dbSelectArea("SB8")
								For zi:=1 to Len(aArray[xi,10])
									MsGoto(aArray[xi,10,zi,1])
									nSaldo+=aArray[xi,10,zi,2]
								Next zi
							Next xi
							nSaldo := A250PotMax(aArraySD4[i,w,3],aArraySD4[i,w,14],nSaldo,nDecSD4)
						EndIf
						If Round(nSaldo,nDecSD4) -	A250PotMax(aArraySD4[i,w,3],aArraySD4[i,w,14],nQuantBxSD4,nDecSD4) < 0
							If Empty(aArraySD4[i,w,9])
								nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4] .And. Empty(x[7]) })
							Else
								nElem := Ascan(aSaldo,{|x| x[1] == aArraySD4[i,w,3] .And. x[2] == aArraySD4[i,w,4] .And. x[7] == aArraySD4[i,w,9] })
							EndIf

							If nElem == 0
								AADD(aSaldo,{aArraySD4[i,w,3],Alltrim(aArraySD4[i,w,4]),0,nSaldo - nQuantBxSD4,0,"S",,aArraySD4[i,w,9],aArraySD4[i,w,10]})
							ElseIf aSaldo[nElem,6] == "S"
								aSaldo[nElem,4] := Round(nSaldo,nDecSD4) - nQuantBxSD4
								aSaldo[nElem,6] := "N"
							Else
								If nQuantBxSD4 <= aSaldo[nElem,4]
									aSaldo[nElem,4] -= nQuantBxSD4
								Else
									lValEst := a250EstPrd(nQuantBxSD4, aArraySD4, aSaldo[nElem,4] , nDecSD4, i,w)

									If lValEst
										aSaldo[nElem,4] := 0								
									Else
										aSaldo[nElem,4] -= nQuantBxSD4
									EndIf
								EndIf
							EndIf
						EndIf
						dbSelectArea("SB8")
						dbSetOrder(nOrdSB8)
						MsGoto(nRecSB8)
					EndIf
				EndIf
			Next w
		Next i
	EndIf
	If oSqlLogDoc != Nil
		oSqlLogDoc:Destroy()
	EndIf
Return NIL

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250Comum Ё Autor Ё Eveli Morasco         Ё Data Ё          Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Chamada da funcao de lancamentos contabeis                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function a250Comum(aCtbDia)
	Local nX	:= 0
	Default aCtbDia	:= {}

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o custo medio e' calculado On-Line               Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If cCusMed == "O"
		If !lCriaHeader
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё mv_par01 - Se mostra e permite digitar lancamentos contabeis   Ё
			//Ё mv_par02 - Se deve aglutinar os lancamentos contabeis          Ё
			//Ё mv_par03 - Encerra todos os Itens da Grade                     Ё
			//Ё mv_par04 - Estorna todos os Itens da Grade                     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			pergunte("MTA250",.F.)

			If Type('lDigAutoAux') == "L"
				lDigita	:= lDigAutoAux
			Else
				lDigita := Iif(mv_par01 == 1,.T.,.F.)
			EndIf
			lAglutina := Iif(mv_par02 == 1,.T.,.F.)

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Se ele criou o arquivo de prova ele deve gravar o rodape'    Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If !__lAutomacao
				RodaProva(nHdlPrv,nTotal)
			EndIf

			//зддддддддддддддддддддддддддд©
			//ЁAtualiza o cСdigo de diАrioЁ
			//юддддддддддддддддддддддддддды
			If !Empty(aCtbDia)
				cCodDiario := CtbaVerdia()
				For nX := 1 to Len(aCtbDia)
					aCtbDia[nX][3] := cCodDiario
				Next nX
			EndIf

			If !__lAutomacao
				If cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
					lCriaHeader := .T.
					KeyBoard Chr(27)
					If !(aAtuSD3 == Nil) .And. ValType(aAtuSD3) == "A"
						For nX:=1 to len(aAtuSD3)
							MsGoTo(aAtuSD3[nX])
							RecLock("SD3",.F.)
							Replace D3_DTLANC With dDataBase
							MsUnLock()
						Next
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

RETURN

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁMTA250PERGЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 05/12/95 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Chamada da funcao PERGUNTE                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function MTA250PERG()
	PERGUNTE("MTA250",.T.)
Return NIL

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁMTA250TELAЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/12/95 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Chamada da listbox para caso de Erro.                      Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁParametros| aErros[nX,1] - Produto                                     Ё╠╠
╠╠Ё          | aErros[nX,2] - Local                                       Ё╠╠
╠╠Ё          | aErros[nX,3] - Saldo                                       Ё╠╠
╠╠Ё          | aErros[nX,4] - Ocorrencia                                  Ё╠╠
╠╠Ё          | aErros[nX,5] - Lote                                        Ё╠╠
╠╠Ё          | aErros[nX,6] - SubLote                                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function MTA250TELA(aErros)
	Local oDlg, oQual
	Local cCadastro := OemToAnsi(STR0014)	//"Itens Sem Sld / Bloqs. / Empenhos Pendentes"
	Local lM250Erro := ExistBlock("M250ERRO")

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё M250TELA - Ponto de entrada utilizado para customizacao da   Ё
	//|            janela de Itens sem Saldo / bloqueados.           |
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ExistBlock("M250TELA")
		ExecBlock("M250TELA",.F.,.F.,{aErros})
	Else
		DEFINE MSDIALOG oDlg TITLE cCadastro From 09,0 To 30.5,74 OF oMainWnd
		@ 0.5,0.5 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0015),OemToAnsi(STR0016),OemToAnsi(STR0017),OemToAnsi(STR0018) SIZE 250,150    //"Produto"###"Local"###"Saldo"###"Ocorr┬ncia"
		oQual:SetArray(aErros)
		oQual:bLine := {|| {aErros[oQual:nAT][1],aErros[oQual:nAT][2],aErros[oQual:nAT][3],aErros[oQual:nAT][4]}}
		oQual:lHScroll := .F.
		DEFINE SBUTTON FROM 50 ,260  TYPE 1 ACTION (oDlg:End()) ENABLE OF oDlg
		DEFINE SBUTTON FROM 65 ,260  TYPE 6 ACTION (If(lM250Erro,ExecBlock("M250ERRO",.F.,.F.,{aErros}),A250ERRO(aErros)) ) ENABLE OF oDlg
		If aErros[1][5] # Nil
			DEFINE SBUTTON FROM 80 ,260  TYPE 15 ACTION (A250BLQLOT(aErros[oQual:nAT][2],aErros[oQual:nAT][1],aErros[oQual:nAT][5],aErros[oQual:nAT][6])) ENABLE OF oDlg
		EndIf
		ACTIVATE MSDIALOG oDlg
	EndIf
Return NIL

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250DigLotЁ Autor ЁRodrigo de A. SartorioЁ Data Ё 03/12/96  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Faz digita┤└o dos Lotes que devem ser criados              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250DigLot()    	   	                                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250DigLot()
	Static lExecLot:=NIL
	LOCAL cOldAlias:=Alias(),nOrd:=IndexOrd(),nRecno:=Recno()
	LOCAL nOpca		:= 0
	LOCAL nx        := 0
	Local nPos		:= 0
	LOCAL nPosRec	:= 0
	LOCAL aBack     := {}
	LOCAL cTitulo   := ""
	LOCAL aRetExecBl:= {}
	LOCAL lExibeLt  := .T.
	Local cLinhaOk	:= ""
	Local cTudoOk	:= ""
	Local aArea := getArea()

	/*Variaveis para dimensionar a tela*/
	Local aSizeAut	:= {}
	Local aObjects 	:= {}
	Local aPosObj 	:= {}

	// Verifica se existe o P.E. para preenchimento de dados dos lotes
	lExecLot:=If(lExecLot == NIL,ExistBlock("A250PRLT"),lExecLot)

	PRIVATE oGet
	PRIVATE nUsado:=0
	PRIVATE nPosAtu:=0
	PRIVATE nPosAnt:=9999
	PRIVATE nColAnt:=9999
	PRIVATE aAlter	:= {}

	PRIVATE cTM        as character
	PRIVATE nPosCod    as numeric
	PRIVATE nPosLocal  as numeric
	PRIVATE nPosLote   as numeric
	PRIVATE nPosLotCTL as numeric
	PRIVATE nPosDValid as numeric
	PRIVATE nPosLocali as numeric

	cTM  := SD3->D3_TM

	aAlter := {"D3_LOTECTL","D3_DTVALID","D3_POTENCI"}

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Monta o aRotina para nЦo incluir linhas na GetDados          Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	For nx:=1 to Len(aRotina)
		aRotina[nx,4]:=6
	Next nx

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Monta o cabecalho da GetDados                                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If Type('aHeader')<>'A' .Or. (Type('aHeader')=='A' .And. Len(aHeader)==0)
		aTam:=TamSX3("D3_COD")
		Aadd(aHeader,{OemToAnsi(STR0015)	,"D3_COD" 	 ,PesqPict("SD3","D3_COD" ,atam[1]),aTam[1],aTam[2]	,"",USADO, "C" ,""," " })   //"Produto"
		nPosCod := len(aHeader)

		aTam:=TamSX3("D3_LOCAL")
		Aadd(aHeader,{OemToAnsi(STR0016)	,"D3_LOCAL"	 ,PesqPict("SD3","D3_LOCAL",atam[1]),aTam[1],aTam[2]	,"",USADO, "C" ,""," " })   //"Local"
		nPosLocal := len(aHeader)

		aTam:=TamSX3("D3_OP")
		Aadd(aHeader,{OemToAnsi(STR0019)	,"D3_OP"	 ,PesqPict("SD3","D3_OP",atam[1])	,aTam[1],aTam[2]	,"",USADO, "C" ,""," " })   //"OP"

		aTam:=TamSX3("D3_QUANT")
		Aadd(aHeader,{OemToAnsi(STR0020) ,"D3_QUANT"  ,PesqPictQt("D3_QUANT"  ,atam[1])	,aTam[1],aTam[2]	,"",USADO, "N" ,""," " })  //"Quantidade"

		aTam:=TamSX3("D3_LOTECTL")
		Aadd(aHeader,{OemToAnsi(STR0022)	,"D3_LOTECTL",PesqPict("SD3","D3_LOTECTL",atam[1]),aTam[1],aTam[2],GetSX3Cache("D3_NUMLOTE","X3_VALID"),USADO, "C" ,""," " })   //"Lote"
		nPosLotCTL := len(aHeader)

		aTam:=TamSX3("D3_NUMLOTE")
		Aadd(aHeader,{OemToAnsi(STR0021)	,"D3_NUMLOTE",PesqPict("SD3","D3_NUMLOTE",atam[1]),aTam[1],aTam[2],"",USADO, "C" ,""," " })   //"Sub-Lote"
		nPosLote := len(aHeader)

		aTam:=TamSX3("D3_DTVALID")
		Aadd(aHeader,{OemToAnsi(STR0023)	,"D3_DTVALID",PesqPict("SD3","D3_DTVALID",atam[1]),aTam[1],aTam[2],"M->D3_DTVALID >= dDataBase .And. A250Potenc(1)",USADO, "D" ,""," " })  //"Data de Validade"
		nPosDValid := len(aHeader)

		aTam:=TamSX3("D3_POTENCI")
		Aadd(aHeader,{OemToAnsi(STR0058)	,"D3_POTENCI",PesqPict("SD3","D3_POTENCI",atam[1]),aTam[1],aTam[2],"A250Potenc(2)",USADO, "N" ,""," " })  //"Potencia"

		nPosLocali := 0 // Posicao D3_LOCALIZ

	EndIf

	//здддддддддддддддддддддддддддд©
	//ЁWalk-Thru                   Ё
	//юдддддддддддддддддддддддддддды
	ADHeadRec("SD3",aHeader)
	nPosRec	:= Len(aHeader)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Muda a ordem do SB1/SB8 para pesquisa posterior              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	dbSelectArea("SB8")
	dbSetOrder(2)
	dbSelectArea("SB1")
	dbSetOrder(1)

	aCols := {}

	For nx:=1 to Len(aLotes)
		dbSeek(xFilial("SB1")+aLotes[nx,1])

		//AADD(aCols,{aLotes[nx,1],aLotes[nx,2],aLotes[nx,3],aLotes[nx,4],aLotes[nx,5],aLotes[nx,6],SD3->D3_EMISSAO+SB1->B1_PRVALID,Criavar("D3_POTENCI"),aLotes[nx,nPosRec-1],aLotes[nx,nPosRec],.F.})
		dbselectarea("SB8")
		SB8->(dbSetOrder(5))
		If SB8->(dbSeek(xFilial("SB8")+aLotes[nx,1]+aLotes[nx,6]))	
			aLotes[nx,7] := IIF(AllTrim(DToS(aLotes[nx,7])) == "",SB8->B8_DTVALID,SD3->D3_EMISSAO+SB1->B1_PRVALID)
		Else
			aLotes[nx,7] := IIF(AllTrim(DToS(aLotes[nx,7])) == "",SD3->D3_EMISSAO+SB1->B1_PRVALID,aLotes[nx,7])
		EndIf
					
		aLotes[nx,8] := IIF(Alltrim(aLotes[nx,8]) == "",Criavar("D3_POTENCI"),aLotes[nx,8])

		AADD(aCols,{aLotes[nx,1],;
						aLotes[nx,2],;
						aLotes[nx,3],;
						aLotes[nx,4],;
						aLotes[nx,6],;
						aLotes[nx,5],;
						aLotes[nx,7],;
						aLotes[nx,8],;
						aLotes[nx,nPosRec-1],;
						aLotes[nx,nPosRec],;
						.F.})

		// Verifica se existe o P.E. para preenchimento de dados dos lotes
		If lExecLot
			aRetExecBl:=ExecBlock("A250PRLT",.F.,.F.,{aCols[nx,6],aCols[nx,7],lExibeLt})
			// Verifica se retorno esta correto
			If ValType(aRetExecBl) == "A" .And. Len(aRetExecBl) >= 3
				If Valtype(aRetExecBl[1]) == "C"
					If !Empty(aRetExecBl[1]) .And. aRetExecBl[3] <> NIL
						If (nPos := aScan(aHeader, {|x| x[2] == 'D3_LOTECTL'})) > 0
							aCols[nx,nPos]:= aRetExecBl[1]
						EndIf	
					EndIf
				EndIf
				If Valtype(aRetExecBl[2]) == "D"
					If !Empty(aRetExecBl[2]) .And. aRetExecBl[3] <> NIL
						aCols[nx,7]:=aRetExecBl[2]
					EndIf
				EndIf
				If Valtype(aRetExecBl[3]) == "L"
					lExibeLt := aRetExecBl[3]
					nOpca := 1
				Else
					lExibeLt := .T.
				EndIf
			EndIf
		EndIf
		nUsado++
	Next nx

	aBack:=aClone(aCols)
	//зддддддддддддддддддддддддддддддддддддддд©
	//| Exibe a GetDados dos Lotes Empenhados |
	//| lExibeLt == .T. => Exibe GetDados     |
	//| lExibeLt == .F. => NAO Exibe GetDados |
	//юддддддддддддддддддддддддддддддддддддддды
	If lExibeLt .And. !l250Auto

		aSizeAut	:= MsAdvSize(,.F.,)
		AAdd( aObjects, { 200 ,  200, .T., .T. } )//Grid1
		aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 }
		aPosObj := MsObjSize( aInfo, aObjects )

		cTitulo:=OemToAnsi(STR0024)  //"CriaГЦo de Lotes na ProduГЦo"
		nOpca := 0
		DEFINE MSDIALOG oDlg TITLE ctitulo PIXEL From aSizeAut[7],0 To aSizeAut[6],aSizeAut[5] OF oMainWnd
		cLinhaOk := "AlwaysTrue()"
		cTudoOk := "AlwaysTrue()"

		oGet := MSGetDados():New(aPosObj[1,1],aPosObj[1,2],aPosObj[1,3],aPosObj[1,4],1,cLinhaOk,cTudoOk,"",.T.,aAlter)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})
	Else
		//TudoOk()
	EndIf

	If nOpca != 1
		aCols:=aClone(aBack)
	EndIf

	dbSelectArea(cOldAlias)
	dbSetOrder(nOrd)
	MsGoto(nRecno)
	restArea(aArea)

Return NIL

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250LotCtlЁ Autor ЁRodrigo de A. SartorioЁ Data Ё 03/12/96  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Faz valida┤└o dos Lotes digitados na cria┤└o               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250LotCtl()    		 	                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250LotCtl()
	Local cAlias:=Alias(),nOrder:=IndexOrd(),nRecno:=Recno(),cLote:=&(ReadVar())
	Local lRet:=.T.
	Local nPos:=0
	If !Rastro(aCols[n,1])
		Help(" ",1,"NAORASTRO")
		lRet:=.F.
	EndIf
	If lRet .And. Rastro(aCols[n,1],"S")

		//-- Acrescenta o Sub-Lote a Pesquisa
		If (nPos := aScan(aHeader, {|x| x[2] == 'D3_NUMLOTE'})) > 0
			cLote += If(!Empty(aCols[n, nPos]),aCols[n, nPos],'')
		EndIf

		dbSelectArea("SB8")
		dbSetOrder(3)
		If dbSeek(xFilial("SB8")+aCols[n,1]+aCols[n,2]+cLote)
			Help(" ",1,"A240CTLEX")
			lRet:=.F.
		EndIf
		dbSelectArea(cAlias)
		dbSetOrder(nOrder)
		MsGoTo(nRecno)
	EndIf
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250ShowF4Ё Autor ЁRodrigo de A. SartorioЁ Data Ё 17.01.02  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Consulta atraves da tecla F4                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA650                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250ShowF4()
	Local cCampo:=AllTrim(Upper(ReadVar()))
	If cCampo == "M->D3_COD" .Or. cCampo == "M->D3_QUANT"
		MaViewSB2(M->D3_COD)
	ElseIf cCampo == "M->D3_OP"
		A250ShowOp()
	EndIf
Return NIL

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250ShowOPЁ Autor ЁRodrigo de A. SartorioЁ Data Ё 24.10.96  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Consulta OP atraves da tecla F4                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA650                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250ShowOp()
	Local oDlg, nOAT
	Local nHdl		:= GetFocus()
	Local nOpt1		:= 0
	Local aArray	:= {}
	Local cAlias	:= Alias()
	Local nOrder	:= IndexOrd()
	Local nRecno	:= Recno()
	Local cPicture	:= PesqPictQt("C2_QUANT",16)
	Local nOrdSC2 	:= SC2->(IndexOrd())
	Local nTamRef	:= Len(SC2->C2_PRODUTO)
	Local cProdRef	:= M->D3_COD

	If IsAtNewGrd()
		//здддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o produto e' referencia (Grade)Ё
		//юдддддддддддддддддддддддддддддддддддддддддддды
		If MatGrdPrrf(M->D3_COD)
			nTamRef		:= oGrade:TamRef()
			cProdRef	:= Substr(M->D3_COD,1,nTamRef)
		EndIf

		dbSelectArea("SC2")
		dbSetOrder(2)
		If !__lAutomacao	
			If dbSeek(xFilial("SC2")+cProdRef)
				While !Eof() .And. C2_FILIAL+Substr(C2_PRODUTO,1, nTamRef) == xFilial("SC2")+cProdRef
					If Empty(C2_DATRF) .And. C2_TPOP # "P"
						AADD(aArray,{C2_NUM,C2_ITEM,C2_SEQUEN,C2_PRODUTO,DTOC(C2_DATPRI),DTOC(C2_DATPRF),Transform(aSC2Sld(),cPicture),C2_ITEMGRD})
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf

		If !Empty(aArray)
			DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0025) From 09,0 To 30,138 OF oMainWnd     //"OPs deste Produto"
			@ 0.5,  0 TO 16.2, 74.42 OF oDlg
			If __lPyme
				@ 1,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0026),OemToAnsi(STR0027),OemToAnsi(STR0028),OemToAnsi(STR0015),OemToAnsi(STR0045),OemToAnsi(STR0046),OemToAnsi(STR0017)  SIZE 500,133 ON DBLCLICK (nOpt1 := 1,oDlg:End())   //"Nёmero"###"Item"###"Sequ┬ncia"###"Produto"###"Dt. Prev. Inicio"###"Dt. Prev. Fim"###"Saldo"###"It. Grade"
				oQual:SetArray(aArray)
				oQual:bLine := { || {aArray[oQual:nAT][1],aArray[oQual:nAT][2],aArray[oQual:nAT][3],aArray[oQual:nAT][4],aArray[oQual:nAT][5],aArray[oQual:nAT][6],aArray[oQual:nAT][7]}}
			Else
				@ 1,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0026),OemToAnsi(STR0027),OemToAnsi(STR0028),OemToAnsi(STR0015),OemToAnsi(STR0045),OemToAnsi(STR0046),OemToAnsi(STR0017),OemToAnsi(STR0049)  SIZE 500,133 ON DBLCLICK (nOpt1 := 1,oDlg:End())   //"Nёmero"###"Item"###"Sequ┬ncia"###"Produto"###"Dt. Prev. Inicio"###"Dt. Prev. Fim"###"Saldo"###"It. Grade"
				oQual:SetArray(aArray)
				oQual:bLine := { || {aArray[oQual:nAT][1],aArray[oQual:nAT][2],aArray[oQual:nAT][3],aArray[oQual:nAT][4],aArray[oQual:nAT][5],aArray[oQual:nAT][6],aArray[oQual:nAT][7],aArray[oQual:nAT][8]}}
			EndIf
			DEFINE SBUTTON FROM 123  ,516  TYPE 1 ACTION (nOpt1 := 1,oDlg:End()) ENABLE OF oDlg
			DEFINE SBUTTON FROM 135.5,516  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
			ACTIVATE MSDIALOG oDlg VALID (nOAT := oQual:nAT, .T.)
			If nOpt1 == 1
				M->D3_OP :=aArray[nOAT][1]+aArray[nOAT][2]+aArray[nOAT][3]+aArray[nOAT][8]
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "D3_OP" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->D3_OP
				EndIf
			EndIf
			SetFocus(nHdl)
		Else
			HELP(" ",1,"A250NAOOP")
		EndIf
		dbSelectArea(cAlias)
		dbSetOrder(nOrder)
		MsGoTo(nRecno)
		SC2->(dbSetOrder(nOrdSC2))
		CheckSx3("D3_OP")
	Else
		_A250ShowOp()
	EndIf
Return NIL

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250End   Ё Autor ЁRodrigo de A. SartorioЁ Data Ё 04/09/97  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Encerra ordens de producao                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250End()      				                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA650                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250End(lEncerra, lEncMenu, aMRPxJson)

	Local aAreaAnt    := {}
	Local aTravas     := {}
	Local aLstOpDep   := {}
	Local aOpsPis     := {}

	Local lSD3250R    := ExistBlock("SD3250R")
	Local lA250ENOP   := ExistBlock("A250ENOP")
	Local lConsVenc   := GetMV('MV_LOTVENC')=='S'
	Local lPergAtuEmp := SuperGetMV("MV_PATUEMP",,"S") =="S"

	Local lAtuEmp     := .F.
	Local lRetPE      := .F.
	Local cSeek       := ''
	Local nLoop       := Nil
	Local nRecSD3
	Local nEntregSC7  := 0
	Local lExcluiAE   := IIF(GetMv("MV_DELEAE")=="S",.T.,.F.)
	Local lWmsNew     := SuperGetMv("MV_WMSNEW",.F.,.F.)

	Local lDelTBMRP   := _lNewMRP == NIL
	Local lIntLocal   := aMRPxJson == NIL
	Local lIntNewMRP  := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)

	Default aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)

	Default lEncerra  := .F.
	Default lEncMenu  := .T.
	//lEncMenu - a funГЦo A250End quando chamada no MATA681 deverА ter um tratamento diferenciado
	//de quando for chamado pelo OPCAO do MENU 'Encerrar'. Quando chamado no MATA681 deverА ser passado .F.
	//e de qualquer outra rotina .T.

	If Type("lPerdInf") == "U"
		lPerdInf := SuperGetMV("MV_PERDINF",.F.,.F.)
	EndIf

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(SD3->D3_OP) )

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Atualiza arquivo de empenhos e B2_QEMP     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддды
	dbSelectArea("SF5")
	dbSeek(xFilial("SF5")+SD3->D3_TM)
	If F5_ATUEMP == "N" .And. lPergAtuEmp .And. __cInternet#"AUTOMATICO"
		lAtuEmp:=Aviso(OemToAnsi(STR0035),OemToAnsi(STR0061),{OemToAnsi(STR0056),OemToAnsi(STR0057)},,, 2) == 1
	Else
		If l680 .Or. l681
			lAtuEmp := .F.
		Else
			lAtuEmp := If (ValType(lAtuEmpExe) == "L",lAtuEmpExe,.F.)
		EndIf
	EndIf

	Begin Transaction
		If F5_ATUEMP == "S" .Or. (lAtuEmp)
			dbSelectArea("SD4")
			dbSetOrder(2)
			dbSeek(xFilial("SD4")+SD3->D3_OP)
			While !EOF() .And. D4_FILIAL+D4_OP==xFilial("SD4")+SD3->D3_OP
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza arq. de saldos  B2_QEMP                                  Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				GravaEmp(	SD4->D4_COD,;
				SD4->D4_LOCAL,;
				SD4->D4_QUANT,;
				SD4->D4_QTSEGUM,;
				SD4->D4_LOTECTL,;
				SD4->D4_NUMLOTE,;
				NIL,;
				NIL,;
				SD4->D4_OP,;
				SD4->D4_TRT,;
				NIL,;
				NIL,;
				"SC2",;
				NIL,;
				SD4->D4_DATA,;
				@aTravas,;
				.T.,;
				NIL,;
				.T.,;
				.T.,;
				lConsVenc,;
				NIL,;
				NIL,;
				.T.)

				/*Realiza a baixa das requisiГУes no WMS se houver saldo.
				  As tabelas do WMS terЦo o saldo atualizado.
				  A tabela SDC nЦo serА movimentada/excluМda no encerramento com produГЦo parcial, jА que caso haja estorno
				  ela И necessАria para obter o endereГo. Na produГЦo total jА nЦo ocorre a exclusЦo da SDC.*/
				If lWmsNew .And. lEncerra .And. IntWms(SD4->D4_COD) .And. SD4->D4_QUANT > 0
					WmsEmpReq("SC2",SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_QUANT,/*cEndereco*/,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,/*cNumSerie*/,SD4->D4_OP,SD4->D4_TRT,/*cIdDCF*/,/*cIdUnitiz*/,.T./*lEstorno*/,.F./*lCriaSDC*/,/*lEmpD14*/,.T./*lMovQtdSDC*/,lEncerra) 
				EndIf

				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Remove travas dos registros utilizados                  Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				MaDesTrava(aTravas)
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza quantidade do SD4                              Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				RecLock("SD4",.F.)
				SD4->D4_SLDEMP	:= SD4->D4_QUANT
				SD4->D4_SLDEMP2	:= SD4->D4_QTSEGUM
				Replace D4_QUANT	With 0
				Replace D4_QTSEGUM	With 0
				MsUnlock()
				dbSkip()
			End
		EndIf

		If lDelOpSC .And. lEncMenu

			aAreaAnt := GetArea()
			aOpsPis	 := A250OpsPis(SD3->D3_OP)

			dbSelectArea('SC1')
			dbSetOrder(4)

			For nLoop := 1 to Len(aOpsPis)
				dbSelectArea("SC1")
				If dbSeek(cSeek := xFilial('SC1') + aOpsPis[nLoop], .F.)
					Do While !Eof() .And. C1_FILIAL+C1_OP == cSeek
						If SB2->(dbSeek(xFilial('SB2')+SC1->C1_PRODUTO+SC1->C1_LOCAL, .F.))
							RecLock('SB2', .F.)
							Replace B2_SALPEDI With B2_SALPEDI - (SC1->C1_QUANT-SC1->C1_QUJE)
							MsUnLock()
						EndIf

						//зддддддддддддддддддддддддддддддддд©
						//| Verifica se SC esta em cotacao. |
						//юддддддддддддддддддддддддддддддддды
						If !Empty(SC1->C1_COTACAO) .And.  SC1->C1_COTACAO <> Replicate("X",Len(SC1->C1_COTACAO)) .And. SC1->C1_IMPORT <> "S" .And. SC1->C1_QUJE == 0
							Aviso(STR0035,STR0102+AllTrim(SC1->C1_NUM)+STR0103+AllTrim(SC1->C1_ITEM)+STR0104,{'Ok'}) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra em processo de cotacao! "
							If Type("aRegsSC1") != "U"
								AADD(aRegsSC1,SC1->(Recno()))
							EndIf
							dbSkip()
							Loop
						Endif

						//зддддддддддддддддддддддддддддддддддддддд©
						//| Verifica se existe SI vinculada a SC. |
						//юддддддддддддддддддддддддддддддддддддддды
						If !Empty(SC1->C1_NUM_SI)
							Aviso(STR0035,STR0102+AllTrim(SC1->C1_NUM)+STR0103+AllTrim(SC1->C1_ITEM)+STR0105,{'Ok'}) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra em processo de importacao!
							If Type("aRegsSC1") != "U"
								AADD(aRegsSC1,SC1->(Recno()))
							EndIf
							SC1->(dbSkip())
							Loop
						Endif

						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Caso ja haja qtd no PC, iguala qtd na SC para encerra-la Ё
						//Ё senao deleta											 Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SC1->C1_QUJE > 0
							RecLock('SC1', .F.)
							Replace C1_QUANT With C1_QUJE
							Replace C1_QTSEGUM With ConvUM(SB2->B2_COD, C1_QUJE, 0, 2)
							MsUnlock()
						Else
							//зддддддддддддддддддддддддддддддддддд©
							//Ё Gerar Carta de Correcao do Pedido Ё
							//юддддддддддддддддддддддддддддддддддды
							RecLock('SC1',.F.,.T.)
							Replace C1_OBS With STR0044 //"CANCELADA PELO SISTEMA."
							dbDelete()
							MsUnLock()
						EndIf
						SC1->(dbSkip())
					EndDo
				EndIf
				dbSelectArea('SC7')
				dbSetOrder(8)
				If dbSeek(cSeek := xFilial('SC7') + aOpsPis[nLoop])
					Do While !Eof() .And. C7_FILIAL + C7_OP == cSeek
						If C7_TIPO == 2
							nEntregSC7 := SC7->C7_QUJE+SC7->C7_QTDACLA
							If SB2->(dbSeek(xFilial("SB2")+SC7->(C7_PRODUTO+C7_LOCAL),.F.))
								nEntregSC7:=SC7->C7_QUJE+SC7->C7_QTDACLA
								GravaB2Pre("-",SC7->C7_QUANT - nEntregSC7,SC7->C7_TPOP)
							EndIf
							//зддддддддддддддддддддддддддддддддддд©
							//Ё Gerar Carta de Correcao do Pedido Ё
							//юддддддддддддддддддддддддддддддддддды
							If nEntregSC7 > 0 .Or. lExcluiAE
								dbSelectArea("SC3")
								dbSetOrder(1)
								If dbSeek(xFilial("SC3")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
									RecLock("SC3",.F.)
									Replace C3_QUJE With C3_QUJE - (SC7->C7_QUANT-nEntregSC7)
									If C3_QUANT > C3_QUJE .And. C3_ENCER == "E"
										Replace C3_ENCER 	With " "
									Endif
									MsUnlock()

								EndIf
							EndIf
							dbSelectArea("SC7")
							// Caso ja haja qtd ENTREGUE no PC
							If nEntregSC7 > 0
								RecLock("SC7",.F.)
								Replace C7_QUANT With SC7->C7_QUJE+SC7->C7_QTDACLA
								Replace C7_TOTAL With SC7->C7_QUANT * SC7->C7_PRECO
								MsUnlock()
							ElseIf lExcluiAE
								// Apaga registro somente qdo nao tem quantidade entregue
								RecLock("SC7",.F.,.T.)
								Replace C7_OBS With STR0044 //"CANCELADA PELO SISTEMA."
								dbDelete()
								MsUnLock()
							EndIf
						EndIf
						SC7->(dbSkip())
					EndDo
				EndIf
			Next
			RestArea(aAreaAnt)
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Posiciona no arquivo de OP's                       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lEncMenu
			dbSelectArea("SC2")
			dbSetOrder(1)
			dbSeek(xFilial("SC2")+SD3->D3_OP)
			RecLock("SC2",.F.)
			Replace C2_DATRF With SD3->D3_EMISSAO

			If lIntNewMRP
				A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
			EndIf

			dbSelectArea("SHD")
			dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
			While !Eof() .And. HD_OP == SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
				RecLock("SHD",.F.)
				Replace HD_DATRF With SD3->D3_EMISSAO
				dbSkip()
			End
			//зддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza o campo totalizador dos empenhos Ё
			//юддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea("SB2")
			If !SB2->(DbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL))
				CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
			EndIf
			If lEncerra
				GravaB2Pre("-",(SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)),SC2->C2_TPOP)
			EndIf
		EndIf
	End Transaction

	// --- Ponto de entrada para indicar se ao encerrar uma OP, encerrar as OPs intermediarias tambem.
	If lA250ENOP .And. lEncMenu
		lRetPE := ExecBlock("A250ENOP",.F.,.F.)
		lRetPE := If(ValType(lRetPE)=="L",lRetPE,.F.)
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Caso use producao automatica, encerro      Ё
	//Ё tambem as OPs intermediarias.              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддды
	If (lProdAut .Or. lRetPE) .And. lEncMenu
		nRecSD3:= SD3->(RecNo())
		cNumOp := SubStr(SD3->D3_OP,1,8)
		cOp    := Alltrim(SD3->D3_OP)
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+cOp)
		While !Eof() .And. SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM == xFilial("SC2")+cNumOp
			If SC2->C2_GRADE == "S" .And. SC2->C2_ITEMGRD != Right(SD3->D3_OP,Len(SC2->C2_ITEMGRD))
				dbSkip()
				loop
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Lista das Ops que geram dependencia para op atualЁ
			//юдддддддддддддддддддддддддддддддддддддддддддддддддды
			aLstOpDep := A250LDepOp(SD3->D3_OP)

			//здддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se a Op possicionada esta na lista das  Ё
			//Ё Ops que geram dependencia para op atual          Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддды
			If Empty(AsCan(aLstOpDep,SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)))
				dbSelectArea("SC2")
				dbSkip()
				Loop
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se OP esta encerrada                    |
			//юдддддддддддддддддддддддддддддддддддддддддддддддддды
			If !Empty(SC2->C2_DATRF)
				dbSelectArea("SC2")
				dbSkip()
				Loop
			EndIf

			Begin Transaction
				//здддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza arquivo de empenhos e B2_QEMP     Ё
				//юдддддддддддддддддддддддддддддддддддддддддддды
				dbSelectArea("SF5")
				dbSeek(xFilial("SF5")+SD3->D3_TM)
				If F5_ATUEMP == "S" .Or. lAtuEmp
					dbSelectArea("SD4")
					dbSetOrder(2)
					dbSeek(xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
					While !EOF() .And. D4_FILIAL+D4_OP==xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza arq. de saldos  B2_QEMP                                  Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						GravaEmp(	SD4->D4_COD,;
						SD4->D4_LOCAL,;
						SD4->D4_QUANT,;
						SD4->D4_QTSEGUM,;
						SD4->D4_LOTECTL,;
						SD4->D4_NUMLOTE,;
						NIL,;
						NIL,;
						SD4->D4_OP,;
						SD4->D4_TRT,;
						NIL,;
						NIL,;
						"SC2",;
						NIL,;
						SD4->D4_DATA,;
						@aTravas,;
						.T.,;
						NIL,;
						.T.,;
						.T.,;
						lConsVenc,;
						NIL,;
						NIL,;
						.T.)

						If lWmsNew .And. lEncerra .And. IntWms(SD4->D4_COD)
							WmsEmpReq("SC2",SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_QUANT,/*cEndereco*/,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,/*cNumSerie*/,SD4->D4_OP,SD4->D4_TRT,/*cIdDCF*/,/*cIdUnitiz*/,.T./*lEstorno*/,.T./*lCriaSDC*/)
						EndIf
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Atualiza quantidade do SD4                              Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						dbSelectArea("SD4")
						RecLock("SD4",.F.)
						SD4->D4_SLDEMP	:= SD4->D4_QUANT
						SD4->D4_SLDEMP2	:= SD4->D4_QTSEGUM
						Replace D4_QUANT	With 0
						Replace D4_QTSEGUM	With 0
						MsUnlock()

						dbSkip()
					End
				EndIf
				RecLock("SC2",.F.)
				Replace C2_DATRF With SD3->D3_EMISSAO

				If lIntNewMRP
					A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
				EndIf

				dbSelectArea("SHD")
				dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
				While !Eof() .And. HD_FILIAL+HD_OP == xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
					RecLock("SHD",.F.)
					Replace HD_DATRF With SD3->D3_EMISSAO
					dbSkip()
				End
				//зддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza o campo totalizador dos empenhos Ё
				//юддддддддддддддддддддддддддддддддддддддддддды
				dbSelectArea("SB2")
				If !SB2->(DbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL))
					CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
				EndIf
				If lEncerra
					GravaB2Pre("-",(SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)),SC2->C2_TPOP)
				EndIf
			End Transaction
			dbSelectArea("SC2")
			dbSkip()
		End
		dbSelectArea("SD3")
		MsGoTo(nRecSD3)
	EndIf

	If lIntNewMRP
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Chama integraГЦo com novo MRP                                Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lIntLocal
			MATA650INT("INSERT", aMRPxJson[1])
			aSize(aMRPxJson[1], 0)
			FreeObj(aMRPxJson[2])
			aMRPxJson[2] := Nil
			If lDelTBMRP
				_lNewMRP := Nil
			EndIf
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Executa ponto de entrada ao final do encerramento da producaoЁ
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lSD3250R .And. lEncMenu
		ExecBlock("SD3250R",.F.,.F.)
	EndIf
Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250StatusЁAutorЁRodrigo de A. Sartorio Ё Data Ё 15/10/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Pergunta se apos o estorno de um apontamento de producao Ё╠╠
╠╠Ё          Ё em uma OP j═ encerrada esta deve ser liberada novamente  Ё╠╠
╠╠Ё          Ё para producao.                                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Status(cNumOP, cNumSeq)
	Local lRet := .F.
	Local cLinha1:= STR0029+cNumOp+STR0030	//"A OP "###" estА encerrada. ApСs o estorno deste "
	Local cLinha2:= STR0031	//"apontamento a OP ficarА com saldo para produzir. "
	Local cLinha3:= STR0032	//"Deseja reabrir a Ordem de Producao?"
	Local cLinha4:= STR0152 //"A Ordem de ProduГЦo serА reaberta."
	Local cAlias:=Alias()
	Local cMsg := ''
	Local nOldOrdSC2:=SC2->(IndexOrd())
	Local nOldRecSC2:=SC2->(Recno())
	Local lAponAuto := .F.

	Default lAbreOP := .T.

	If Type("lReabreOp") == "U"
		Private lReabreOp := .F.
	EndIf

	If Type("lValReabr") == "U"
		Private lValReabr := .F.
	EndIf

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(cNumOP) )
	If lProdaut
		lAponAuto := a250ApoAut(cNumOP, cNumSeq)
	EndIf

	dbSelectArea("SC2")
	dbSetOrder(1)
	If dbSeek(xFilial("SC2")+cNumOP) .And. !Empty(C2_DATRF)
		If (Type("l250Auto") == "L" .and. l250Auto) .or. (Type("l680Auto") == "L" .and. l680Auto) .or. (Type("l681Auto") == "L" .and. l681Auto)
			lRet := .T.
		Else
			If lReabreOp //.And. fRetParPrd(cNumOP)
				lRet := lValReabr
			Else
				If lAponAuto
					cMsg := cLinha1 + cLinha2 + cLinha4
					Help(NIL,NIL,'MATA250',NIL,cMsg, 1,0 )
					
					lRet := .T.

					If !lReabreOp //.And. fRetParPrd(cNumOP)
						lReabreOp := .T.
						lValReabr := lRet  
					EndIf
				Else
					TONE(3500,1)
					If !(MsgYesNo(OemToAnsi(cLinha1+cLinha2+cLinha3),OemToAnsi(STR0033)+cNumOP))		//"Estorno OP "
						lRet    := .F.
						lAbreOP := .F.
					Else 
						lRet := .T.
					EndIf 

					If !lReabreOp //.And. fRetParPrd(cNumOP)
						lReabreOp := .T.
						lValReabr := lRet  
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	dbSelectArea(cAlias)
	SC2->(dbSetOrder(nOldOrdSC2))
	SC2->(MsGoto(nOldRecSC2))
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁLotesSD4  Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 03/08/98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica o saldo em estoque dos produtos e gera os lotes   Ё╠╠
╠╠Ё          Ё utilizados na digitacao qdo utiliza producao automatica    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё LotesSD4(ExpN1,ExpC1,ExpN2,ExpA1)						  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpN1 = Indice (percentual do apontamento)                 Ё╠╠
╠╠Ё          Ё ExpC1 = Codigo da Ordem de Producao                        Ё╠╠
╠╠Ё          Ё ExpN2 = Nivel da estrutura (controle da Recursividade)     Ё╠╠
╠╠Ё          Ё ExpA1 = Array contendo os lotes/sub-lotes a serem criados  Ё╠╠
╠╠Ё          Ё ExpL1 = Validando estoque (.T.)                            Ё╠╠
╠╠Ё          Ё ExpA2 = Array utilizado no controle do saldo negativo      Ё╠╠
╠╠Ё          Ё ExpN3 = Qtde. do produto digitada na Grade                 Ё╠╠
╠╠Ё          Ё ExpC2 = Tipo de Baixa dos Itens da Grade                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function LotesSD4(nIndice,cOp,nNivel,aLotes,lEstoque,aSaldo,aReqsOk, nQuantDig, cParTot, nParPercPrM)
	Static lA250FilD4
	Static nDecSD3,nDecSD4

	Local nRegistro  := 0
	Local cOpOrig    := ""
	Local cAlias     := "SD3"
	Local nElem      := 0
	Local nRecSD3    := SD3->(Recno())
	Local cSubLote   := ""
	Local lCheckEst  := GetMV("MV_ESTNEG") == "N"
	Local lCheckLot  := GetMV("MV_RASTRO") == "S"
	Local lConsRegD4 := .T.
	Local nQuantSD4  := 0
	Local dEmissao   := If(l250, M->D3_EMISSAO, dDataBase)
	Local aTamLt     := TamSX3("D3_LOTECTL")
	Local nSaldoOpIn := 0
	Local nPercPrM	 := 0

	Local nTamOP:= Len(cOP)
	Local nTam  := Len(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)

	Local cChaveD4  := ' '
	Local cProdAnt  := ' '
	Local cLocAnt   := ' '
	Local nQtdAtu   := 0
	Local nQtdProc  := 0
	Local nQuantEst := 0

	DEFAULT lLoteACD := .F.
	DEFAULT nParPercPrM := 0

	nQuantDig := If(nQuantDig == NIL, M->D3_QUANT+If(lPerdInf,0,M->D3_PERDA), nQuantDig)
	cParTot   := If(cParTot   == NIL, M->D3_PARCTOT, cParTot)	

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250FilD4 == NIL
		lA250FilD4 := ExistBlock("A250FSD4")
	EndIf

	If nDecSD3 == NIL
		nDecSD3:=TamSX3("D3_QUANT")[2]
	EndIf
	If nDecSD4 == NIL
		nDecSD4:=TamSX3("D4_QUANT")[2]
	EndIf

	If fRetParPrd(cOp) // LotesSD4
		fCalcSaldo(cOp, nTamOP,nNivel,dEmissao)
		fCalcQtdNec(cOp, nTamOP,nNivel)

		dbSelectArea("SD4")
		dbSetOrder(2)
		SD4->(dbSeek(xFilial("SD4")+cOp))
		Do While !Eof() .And. xFilial("SD4")+cOp == SD4->D4_FILIAL+Substr(SD4->D4_OP,1,nTamOP)

			If SD4->D4_QUANT <= 0
				SD4->(dbSkip())
				loop
			ENDIF
			
			nRegistro	:= SD4->(Recno())
			cOpOrig		:= SD4->D4_OPORIG

			If Empty(cChaveD4) .Or. cChaveD4 <> SD4->D4_OP+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_TRT
				nQuantEst := fRetSldEmp(nNivel)
				nQuantNec := fRetQtdNec(nNivel)

				nQtdAtu := nQuantDig * nQuantNec
			EndIf

			cChaveD4 := SD4->D4_OP+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_TRT
			cProdAnt  := SD4->D4_COD
			cLocAnt   := SD4->D4_LOCAL

			If nQtdAtu > 0			
				If Empty(SD4->D4_LOTECTL) .And. SD4->D4_QUANT > 0 
							
					//Para o componente, local e trt, existe registro de saldo e ordem intermediaria?
					//Se existir registro de saldo e o saldo atender a qtd a apontar nЦo precisa utilizar OP intermediaria.
					If nQuantEst >= nQtdAtu						
						nQtdAtu := 0
						nRegistro	:= Recno()
						dbSelectArea("SD4")
						dbSetOrder(2)
						MsGoto(nRegistro)
						dbSkip()
						Loop
					Else
						nQtdAtu -= nQuantEst
						nQuantEst := 0
					EndIf

					If SD4->D4_QUANT >= nQtdAtu
						nQtdProc := nQtdAtu
					Else
						nQtdProc := SD4->D4_QUANT
					EndIf
				
					//Se existir saldo parcial ou nЦo existir saldo, deverА utilizar da OP intermediaria.
					If dbSeek(xFilial("SD4")+cOpOrig)
						nNivel++
						LotesSD4(0,cOpOrig,@nNivel,@aLotes,lEstoque,@aSaldo,@aReqsOk,nQtdProc, cParTot, nParPercPrM)
					EndIf
				Else
					If SD4->D4_QUANT > nQtdAtu
						nQtdAtu := 0
					Else
						nQtdAtu -= SD4->D4_QUANT
					EndIf
				EndIf

				dbSelectArea("SC2")
				dbSetOrder(1)
				If dbSeek(xFilial("SC2")+cOpOrig)									
					nQuant := nQtdProc
					If nQuant > 0 .And. Empty(SC2->C2_DATRF)
						If lEstoque
							If lCheckEst .Or. lCheckLot
								//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Checa os saldos de todos os produtos empenhados    Ё
								//Ё das Ops vinculadas a Op Pai (produto Acabado)      Ё
								//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
								nElem := Ascan(aSaldo,{|x| x[1] == SC2->C2_PRODUTO .And. x[2] == SC2->C2_LOCAL .And. Empty(x[7]) })
								If nElem == 0
									SB2-> ( dbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL ) )
									AADD(aSaldo,{SC2->C2_PRODUTO,Alltrim(SC2->C2_LOCAL),SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao)+nQuant,SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao)+nQuant,SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao)+nQuant,"N",NIL,NIL})
								Else
									aSaldo[nElem,3] += nQuant
									aSaldo[nElem,4] += nQuant
									aSaldo[nElem,5] += nQuant
								EndIf
								
								SF5->(dbSetOrder(1))
								If SF5->(dbSeek(xFilial("SF5")+M->D3_TM)) .And. SF5->F5_ATUEMP == "S"
									A250Estoq(nQuant,cParTot,SC2->C2_PRODUTO,(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD),@aSaldo,@aReqsOk,,,nParPercPrM)
								EndIf
							EndIf
						Else
							If Rastro(SC2->C2_PRODUTO,"S") .Or. Rastro(SC2->C2_PRODUTO,"L")
								cSubLote:=NextLote(SC2->C2_PRODUTO,"S")
								If l250Auto .and. !lLoteACD
									nPosLot := aScan(aRotAuto,{|x| x[1] == "D3_LOTECTL"})
									nPosVal := aScan(aRotAuto,{|x| x[1] == "D3_DTVALID"})
									nPosPot := aScan(aRotAuto,{|x| x[1] == "D3_POTENCI"})
									AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,nQuant,cSubLote,;
									IIf(nPosLot<>0,aRotAuto[nPosLot,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(nPosVal<>0,aRotAuto[nPosVal,2],CriaVar("D3_DTVALID")),IIf(nPosPot<>0,aRotAuto[nPosPot,2],CriaVar("D3_POTENCI")),"SC2",SC2->(Recno())})
								Else
									AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,nQuant,cSubLote,;
									IIf(lLoteACD,aRotAuto[8,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(lLoteACD,aRotAuto[9,2],CriaVar("D3_DTVALID")),CriaVar("D3_POTENCI"),"SC2",SC2->(Recno())})
								Endif
							EndIf
						EndIf
					EndIf
					nQtdAtu -= nQuant
				EndIf 
			EndIf
			
			dbSelectArea("SD4")
			dbSetOrder(2)
			MsGoto(nRegistro)
			SD4->(dbSkip())
		EndDo
	Else
		dbSelectArea("SD4")
		dbSetOrder(2)
		dbSeek(xFilial("SD4")+cOp)
		Do While !Eof() .And. xFilial("SD4")+cOp == D4_FILIAL+Substr(D4_OP,1,nTamOP)
			nRegistro	:= Recno()
			lConsRegD4	:= .T.
			cOpOrig		:= SD4->D4_OPORIG
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lA250FilD4
				lConsRegD4:=ExecBlock("A250FSD4",.F.,.F.,{nIndice,!lEstoque})
				If ValType(lConsRegD4) != "L"
					lConsRegD4:=.T.
				EndIf
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se empenho deve ser considerado           Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			nQuantSD4:=SD4->D4_QUANT
			nPercPrM := RetPerMIt(nParPercPrM)

			If lConsRegD4 .And. Empty(D4_LOTECTL) .And. ( D4_QUANT > 0 .Or. nPercPrM > 0)
				If dbSeek(xFilial("SD4")+cOpOrig)
					nNivel++
					//ler todos empenhos do produto e recalcular nindice
					nIndice := A250Indice(cOpOrig, nIndice)
					LotesSD4(nIndice,cOpOrig,@nNivel,@aLotes,lEstoque,@aSaldo,@aReqsOk,nQuantDig, cParTot, nParPercPrM)
				EndIf
				dbSelectArea("SC2")
				dbSetOrder(1)
				If dbSeek(xFilial("SC2")+cOpOrig)
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Verifica o saldo da OP filha e determina o quanto  Ё
					//Ё deve ser produzido em relacao ao saldo proporcionalЁ
					//Ё Se o saldo for menor que o saldo proporcional,     Ё
					//Ё nao produz a OP filha.                             Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					nSaldo     := SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)
					If nSaldo < 0
						nSaldo  := 0
						nIndice := 1
					EndIF

					nSaldoOpIn := SC2->C2_QUANT

					If nIndice == 1
						nQuant  := nSaldo + (nSaldoOpIn * nPercPrM)
					Else
						nSaldoProp := Round(nSaldo * nIndice,nDecSD3)
						If nSaldo  >=  nSaldoProp
							nQuant  := nSaldoProp
						Else
							nQuant := 0
						EndIf
					EndIf
					If nQuant > 0 .And. Empty(SC2->C2_DATRF)
						If lEstoque
							If lCheckEst .Or. lCheckLot
								//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Checa os saldos de todos os produtos empenhados    Ё
								//Ё das Ops vinculadas a Op Pai (produto Acabado)      Ё
								//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
								nElem := Ascan(aSaldo,{|x| x[1] == SC2->C2_PRODUTO .And. x[2] == SC2->C2_LOCAL .And. Empty(x[7]) })
								If nElem == 0
									SB2-> ( dbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL ) )
									AADD(aSaldo,{SC2->C2_PRODUTO,Alltrim(SC2->C2_LOCAL),SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao)+nQuant,SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao)+nQuant,SaldoMov(Nil,.F.,Nil,Nil,Nil,Nil,Nil,dEmissao)+nQuant,"N",NIL,NIL})
								Else
									aSaldo[nElem,3] += nQuant
									aSaldo[nElem,4] += nQuant
									aSaldo[nElem,5] += nQuant
								EndIf
								SF5->(dbSetOrder(1))
								If SF5->(dbSeek(xFilial("SF5")+M->D3_TM)) .And. SF5->F5_ATUEMP == "S"
									A250Estoq(nQuant,cParTot,SC2->C2_PRODUTO,(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD),@aSaldo,@aReqsOk,,,nParPercPrM)
								EndIf
							EndIf
						Else
							If Rastro(SC2->C2_PRODUTO,"S") .Or. Rastro(SC2->C2_PRODUTO,"L")
								cSubLote:=NextLote(SC2->C2_PRODUTO,"S")
								//AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,MIN(nQuant,nQuantSD4),cSubLote,;
								//	IIf(lLoteACD,aRotAuto[8,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(lLoteACD,aRotAuto[8,2],CriaVar("D3_DTVALID")),CriaVar("D3_POTENCI"),"SC2",SC2->(Recno())})
								If l250Auto .and. !lLoteACD
									nPosLot := aScan(aRotAuto,{|x| x[1] == "D3_LOTECTL"})
									nPosVal := aScan(aRotAuto,{|x| x[1] == "D3_DTVALID"})
									nPosPot := aScan(aRotAuto,{|x| x[1] == "D3_POTENCI"})
									AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,MIN(nQuant,nQuantSD4),cSubLote,;
									IIf(nPosLot<>0,aRotAuto[nPosLot,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(nPosVal<>0,aRotAuto[nPosVal,2],CriaVar("D3_DTVALID")),IIf(nPosPot<>0,aRotAuto[nPosPot,2],CriaVar("D3_POTENCI")),"SC2",SC2->(Recno())})
								Else
									AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,MIN(nQuant,nQuantSD4),cSubLote,;
									IIf(lLoteACD,aRotAuto[8,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(lLoteACD,aRotAuto[9,2],CriaVar("D3_DTVALID")),CriaVar("D3_POTENCI"),"SC2",SC2->(Recno())})
								Endif
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			dbSelectArea("SD4")
			dbSetOrder(2)
			MsGoto(nRegistro)
			dbSkip()
		EndDo
	EndIF
		
		
	//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Processa Ordem de Producao Inicial                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
	aAreaSc2:= GetArea()
	If nNivel == 0
		SD3->(MsGoto(nRecSD3))
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+cOp)
		If lEstoque
			If lCheckEst .Or. lCheckLot
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Checa os saldos de todos os produtos empenhados    Ё
				//Ё das Ops vinculadas a Op Pai (produto Acabado)      Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				nElem := Ascan(aSaldo,{|x| x[1] == SC2->C2_PRODUTO .And. x[2] == SC2->C2_LOCAL})
				If nElem == 0
					AADD(aSaldo,{SC2->C2_PRODUTO,Alltrim(SC2->C2_LOCAL),nQuantDig,nQuantDig,nQuantDig,"N",NIL,NIL})
				Else
					aSaldo[nElem,3] += nQuantDig
					aSaldo[nElem,4] += nQuantDig
					aSaldo[nElem,5] += nQuantDig
				EndIf
				SF5->(dbSetOrder(1))
				If SF5->(dbSeek(xFilial("SF5")+M->D3_TM)) .And. SF5->F5_ATUEMP == "S"
					A250Estoq(nQuantDig,cParTot,SC2->C2_PRODUTO,(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD),@aSaldo,@aReqsOk,,, nParPercPrM)
				EndIf
			EndIf
		Else
			If Rastro(SC2->C2_PRODUTO,"S") .Or. Rastro(SC2->C2_PRODUTO,"L")
				cSubLote:=If(Rastro(SC2->C2_PRODUTO,"S"),NextLote(SC2->C2_PRODUTO,"S"),'')
				//AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,SD3->D3_QUANT,cSubLote,;
				//	IIf(lLoteACD,aRotAuto[8,2],PadR(NextLote(SC2->C2_PRODUTO,"L",cSubLote),aTamLt[1])),IIf(lLoteACD,aRotAuto[8,2],CriaVar("D3_DTVALID")),CriaVar("D3_POTENCI"),"SC2",SC2->(Recno())})
				If l250Auto .and. !lLoteACD
					nPosLot := aScan(aRotAuto,{|x| x[1] == "D3_LOTECTL"})
					nPosVal := aScan(aRotAuto,{|x| x[1] == "D3_DTVALID"})
					nPosPot := aScan(aRotAuto,{|x| x[1] == "D3_POTENCI"})
					AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,SD3->D3_QUANT,cSubLote,;
					IIf(nPosLot<>0,aRotAuto[nPosLot,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(nPosVal<>0,aRotAuto[nPosVal,2],CriaVar("D3_DTVALID")),IIf(nPosPot<>0,aRotAuto[nPosPot,2],CriaVar("D3_POTENCI")),"SC2",SC2->(Recno())})
				Else
					nPosLot := aScan(aRotAuto,{|x| x[1] == "D3_LOTECTL"})
					nPosVal := aScan(aRotAuto,{|x| x[1] == "D3_DTVALID"})
					AADD(aLotes,{SC2->C2_PRODUTO,SC2->C2_LOCAL,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,SD3->D3_QUANT,cSubLote,;
					IIf(lLoteACD,aRotAuto[nPosLot,2],PadR(NextLote(SC2->C2_PRODUTO,"L"),aTamLt[1])),IIf(lLoteACD,aRotAuto[nPosVal,2],CriaVar("D3_DTVALID")),CriaVar("D3_POTENCI"),"SC2",SC2->(Recno())})
				Endif
			EndIf
		EndIf
	EndIf
	RestArea(aAreaSC2)
	nNivel--

Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁExplodeSD4Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 03/08/98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Processa as producoes atraves do empenho                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё ExplodeSD4(ExpN1,ExpC1,ExpN2,ExpC2,ExpC3,ExpC4,ExpD1,ExpC5)Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpN1 = Indice (percentual do apontamento)                 Ё╠╠
╠╠Ё          Ё ExpC1 = Codigo da Ordem de Producao                        Ё╠╠
╠╠Ё          Ё ExpN2 = Nivel da estrutura (controle da Recursividade)     Ё╠╠
╠╠Ё          Ё ExpC2 = Local de producao da OP                            Ё╠╠
╠╠Ё          Ё ExpC3 = Codigo do movimento utilizado                      Ё╠╠
╠╠Ё          Ё ExpC4 = Documento do apontamento                           Ё╠╠
╠╠Ё          Ё ExpD1 = Data do apontamento                                Ё╠╠
╠╠Ё          Ё ExpC5 = Numero sequencial                                  Ё╠╠
╠╠Ё          Ё ExpN3 = Registro Original do SD3                           Ё╠╠
╠╠Ё          Ё ExpN3 = Array aPedidos (com @)                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function ExplodeSD4(nIndice,cOp,nNivel,cLocal,cTm,cDoc,dEmissao,cIdent,nRecSD3,aPedidos,cNumSeq,aCriaDif,nParPercPrM,aMRPxJson)
	Static nDecSD3,nDecSD4
	Static lA250FilD4,lA250PrPI
	Local i:=0,z:=0,w:=0
	Local lConsRegD4:=.T.
	Local cOpOrig:=""
	Local cAlias:="SD3"
	Local cBxProp := GetMv("MV_BXPROP")
	Local cReqAut  := A250ReqAut(GetMV("MV_REQAUT"))
	Local cDevAut  := A250DevAut(SuperGetMV("MV_DEVAUT",.F.,cReqAut))
	Local cLocProc := GetMvNNR('MV_LOCPROC','99')
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variavel utilizada para informar se movimentacao de producao Ё
	//Ё foi total ou parcial.                                        Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local lProdTot:=IIf(SD3->D3_PARCTOT == "T",.T.,.F.)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis utilizadas para baixa "INTELIGENTE" do empenho     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local nAchouSD4   := 0
	Local nAchouInd   := 0
	Local nQuantBxSD4 := 0
	Local nQuantBx2SD4:= 0
	Local nBaixaBxSD4 := 0
	Local nBaixaBx2SD4:= 0
	Local cProdBxSD4  := ""
	Local cTrtBxSD4   := ""
	Local cDValSD4    := Replicate('z', Len(DtoS(SD4->D4_DTVALID)))
	Local cLoteSD4    := Replicate('z', Len(SD4->D4_LOTECTL))
	Local cSLoteSD4   := Replicate('z', Len(SD4->D4_NUMLOTE))
	Local cOPOrigSD4  := Replicate('z', Len(SD4->D4_OPORIG))
	Local aProdsSD4   := {{}}
	Local aArraySD4   := {{}}
	Local nQuant      := 0
	Local nQuant2UM   := 0
	Local nNaoProduzPi:= 0
	Local nSaldoOpIn  := 0
	Local l240CAT83   := FindFunction("V240CAT83") .And. V240CAT83()
	Local cFornDoc	  := " "
	Local cLojaDoc	  := " "
	Local lFornece    := SD3->(ColumnPos("D3_FORNDOC")) > 0 .And. SD3->(ColumnPos("D3_LOJADOC")) > 0
	Local lRet        := .T.
	Local lRetParPrd  := .F.

	Local lDelTBMRP   := _lNewMRP == NIL
	Local lIntLocal   := aMRPxJson == NIL
	Local lIntNewMRP  := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
	Local nPercPrM	  := 0
	Local nQuantUso   := 0 	
	Local nQuantEst   := 0
	Local nQuantEst1  := 0
	Local nAchouProd  := 0

	Local aArrayAuto  := {}

	Default aMRPxJson := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP
	Default aProdAuto := {}

	If Type("aIndAuto") == "U"
		Private aIndAuto := {}  
	EndIf

	If fRetParPrd(cOp)
		lRetParPrd := .T.
	EndIf

	If lFornece
		dbSelectArea("SD3")
		MsGoto(nRecSD3)
		cFornDoc := SD3->D3_FORNDOC
		cLojaDoc := SD3->D3_LOJADOC
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250FilD4 == NIL
		lA250FilD4 := ExistBlock("A250FSD4")
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lA250PrPI == NIL
		lA250PrPI := ExistBlock("A250PRPI")
	EndIf

	If nDecSD3 == NIL
		nDecSD3:=TamSX3("D3_QUANT")[2]
	EndIf
	If nDecSD4 == NIL
		nDecSD4:=TamSX3("D4_QUANT")[2]
	EndIf

	lRetBen  := IIF(lRetBen ==NIL, .F., lRetBen)
	cChaveF1 := IIF(cChaveF1==NIL, "", cChaveF1)

	dbSelectArea("SD4")
	dbSetOrder(2)
	dbSeek(xFilial("SD4")+cOp)
	While !EOF() .And. D4_FILIAL+D4_OP==xFilial("SD4")+cOp
		lConsRegD4:=.T.
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica a existencia de um Ponto de Entrada para filtrar SD4Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lA250FilD4
			lConsRegD4:=ExecBlock("A250FSD4",.F.,.F.,{nIndice,.T.})
			If ValType(lConsRegD4) != "L"
				lConsRegD4:=.T.
			EndIf
		EndIf
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Nao baixa se filtrar empenho                                       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If !lConsRegD4.Or.(SF5->F5_TRANMOD=="N".And.IsProdMod(D4_COD))
			dbSkip()
			Loop
		EndIf
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se o parametro mv_ReqAut indicar que as requisicoes   Ё
		//Ё de materiais diretos sao digitadas entao ele baixara' Ё
		//Ё apenas materiais indiretos , diferentes de MOD , pois Ё
		//Ё a decisao de baixar ou nao a MOD esta' no TM pelo cam-Ё
		//Ё po F5_TRANMOD = "S".                                  Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea("SB1")
		dbSeek(xFilial("SB1")+SD4->D4_COD)
		cApropri := "1"
		If B1_APROPRI == "I"
			cApropri := "2"
		EndIf
		//здддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica o local a ser baixado           Ё
		//юдддддддддддддддддддддддддддддддддддддддддды
		If cApropri == "2"
			cLocReq := cLocProc
		Else
			cLocReq := SD4->D4_LOCAL
		EndIf
		//здддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se ira gerar uma Devolucao ou   Ё
		//Ё requisicao, e analisa se o processo sera Ё
		//Ё automatico ou manual.                    Ё
		//юдддддддддддддддддддддддддддддддддддддддддды
		If (QtdComp(SD4->D4_QUANT,.T.) < QtdComp(0,.T.) .And. QtdComp(SD4->D4_QTDEORI,.T.) < QtdComp(0,.T.))
			If cDevAut == "D" .And. cApropri == "1" .And. !IsProdMod(SD4->D4_COD)
				dbSelectArea("SD4")
				dbSkip()
				Loop
			EndIf
		Else
			If cReqAut == "D" .And. cApropri == "1" .And. !IsProdMod(SD4->D4_COD)
				dbSelectArea("SD4")
				dbSkip()
				Loop
			EndIf
		EndIf

		nPercPrM := RetPerMIt(nParPercPrM)

		//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Adiciona registro em array totalizador por produtoЁ
		//юддддддддддддддддддддддддддддддддддддддддддддддддддды
		If Len(aProdsSD4[Len(aProdsSD4)]) > 4095
			AADD(aProdsSD4,{})
		EndIf
		For i:=1 to Len(aProdsSD4)
			nAchouSD4:=ASCAN(aProdsSD4[i],{ |x| x[1] == SD4->D4_COD .And. x[3] == SD4->D4_TRT})
			If nAchouSD4 != 0
				aProdsSD4[i,nAchouSD4,2] += SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM)
				aProdsSD4[i,nAchouSD4,4] += SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM)
				Exit
			EndIf
		Next i
		If nAchouSD4 ==0
			AADD(aProdsSD4[Len(aProdsSD4)],{SD4->D4_COD,SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM),SD4->D4_TRT,SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM)})
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Nao baixa se quantidade estiver zerada                             Ё
		//Ё ou se for producao automatica via retorno de beneficiamento pela NFЁ
		//Ё  de Entrada pois neste caso a baixa ja ocorreu na remessa via FAT  Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If !IsInCallStack("MATA250") .AnD. !IsInCallStack("MATA680") .AnD. !IsInCallStack("MATA681")
			If QtdComp(SD4->D4_QUANT,.T.)=QtdComp(0,.T.)
				dbSelectArea("SD4")
				dbSkip()
				Loop
			EndIf
		Else
			If !lExistePM
				If QtdComp(SD4->D4_QUANT,.T.)=QtdComp(0,.T.)
					dbSelectArea("SD4")
					dbSkip()
					Loop
				EndIf
			EndIF
		EndIf

		// Retorno de beneficiamento que ja requisitou (RE5) e baixou empenhos do produto nao deve requisitar/baixar novamente
		If lRetBen .And. FindFunction("MTBuscaRE5")
			If MTBuscaRE5(cChaveF1, SD4->D4_COD, SD4->D4_OP)
				dbSelectArea("SD4")
				dbSkip()
				Loop
			EndIf
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Adiciona registro em array organizado por empenho Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддды
		If Len(aArraySD4[Len(aArraySD4)]) > 4095
			AADD(aArraySD4,{})
		EndIf
		AADD(aArraySD4[Len(aArraySD4)],{	SD4->(Recno()),;		//1
		SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),;			//2
		SD4->D4_COD,;			//3
		ALLTRIM(SD4->D4_LOCAL),;//4
		SD4->D4_TRT,;			//5
		SD4->D4_OPORIG,;       	//6
		SD4->D4_QUANT + (SD4->D4_QTDEORI * nPercPrM),;			//7
		DTOS(SD4->D4_DTVALID),;	//8
		SD4->D4_LOTECTL,;		//9
		SD4->D4_NUMLOTE,;		//10
		SD4->D4_OP,;			//11
		SD4->D4_QTDEORI + (SD4->D4_QTDEORI * nPercPrM),;		//12
		SD4->D4_QTSEGUM + (SD4->D4_QTDEORI * nPercPrM),;		//13
		SD4->D4_POTENCI})		//14
		dbSelectArea("SD4")
		dbSkip()
	End

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica quais empenhos serao baixados primeiro                 Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Ordena array para utilizar empenhos mais "INTELIGENTES" primeiroЁ
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	For i:=1 to Len(aArraySD4)
		//-- Forca os Empenhos sem Lote/SubLote/Dt.Valid./OP Origem a ficarem por ultimo na Indexacao
		For z:=1 to Len(aArraySD4[i])
			If Rastro(aArraySD4[i,z,3]) .And. Empty(aArraySD4[i,z,9])
				If !lRetParPrd
					If Empty(aArraySD4[i,z,6])
						aArraySD4[i,z,6] := cOPOrigSD4
					EndIf
				EndIf
				aArraySD4[i,z,9] := cLoteSD4
				If Empty(aArraySD4[i,z,8])
					aArraySD4[i,z,8] := cDValSD4
				EndIf
				If Rastro(aArraySD4[i,z,3], 'S') .And. Empty(aArraySD4[i,z,10])
					aArraySD4[i,z,10] := cSLoteSD4
				EndIf
			EndIf
		Next z
		ASORT(aArraySD4[i],,,{ |x,y| x[3]+x[5]+x[6]+x[8]+x[9]+x[10] < y[3]+y[5]+y[6]+y[8]+y[9]+y[10]})
		//-- Retorna os Empenhos sem Lote/SubLote/Dt.Valid./OP Origem ao formato original
		For z:=1 to Len(aArraySD4[i])
			If aArraySD4[i,z,9] == cLoteSD4
				If !lRetParPrd
					If aArraySD4[i,z,6] == cOPOrigSD4
						aArraySD4[i,z,6] := Space(Len(aArraySD4[i,z,6]))
					EndIf
				EndIf
				aArraySD4[i,z,9] := Space(Len(aArraySD4[i,z,9]))
				If aArraySD4[i,z,8] == cDValSD4
					aArraySD4[i,z,8] := Space(Len(aArraySD4[i,z,8]))
				EndIf
				If aArraySD4[i,z,10] == cSLoteSD4
					aArraySD4[i,z,10] := Space(Len(aArraySD4[i,z,10]))
				EndIf
			EndIf
		Next z
	Next i

	// FunГЦo ExplodeSD4 - Varrer o array aArraySD4 e ver os produtos que possuem apontamento automatico			
	If lRetParPrd
		fArrayAuto(dEmissao,aArraySD4,@aArrayAuto,cOp)
	EndIf 								

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Percorre array para adequar atraves do indice de producao quais Ё
	//Ё empenhos serao utilizados.                                      Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	For i:=1 to Len(aArraySD4)
		For z:=1 to Len(aArraySD4[i])
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Pesquisa quantidade para este produto no empenho                Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If !(aArraySD4[i,z,3]+aArraySD4[i,z,5] == cProdBxSD4+cTrtBxSD4)
				For w:=1 to Len(aProdsSD4)
					nAchouSD4:=ASCAN(aProdsSD4[w],{ |x| x[1] == aArraySD4[i,z,3] .And. x[3] == aArraySD4[i,z,5]})
					If nAchouSD4 != 0
						nQuantBxSD4 :=A250CalcD4(aProdsSD4[w,nAchouSD4,2],nIndice,If(lProdTot,"T","P"),aArraySD4[i,z,2],.F.)
						nQuantBx2SD4:=A250CalcD4(aProdsSD4[w,nAchouSD4,4],nIndice,If(lProdTot,"T","P"),aArraySD4[i,z,2],.F.)

						If !lRetParPrd .And. nDecSD4 == 6
							nAchouInd:=ASCAN(aIndAuto,{ |x| x[1] == aArraySD4[i,z,11]})
							If nAchouInd == 0
								AADD(aIndAuto, {aArraySD4[i,z,11],nIndice})
							EndIf
						EndIf
						Exit
					EndIf
				Next w

				If lRetParPrd
					If aArrayAuto[z,9] == .F.
						nQuantEst := fSaldoAAuto(i,z,aArraySD4,aArrayAuto,.F.,.F.)
						nQuantUso := 0
					ENDIF
				EndIf

				cProdBxSD4 := aArraySD4[i,z,3]
				cTrtBxSD4  := aArraySD4[i,z,5]
			EndIf

			If lRetParPrd
				If aArrayAuto[z,9] == .T.
					nQuantEst := fSaldoAAuto(i,z,aArraySD4,aArrayAuto,.F.,.F.)
					nQuantUso := 0
				ENDIF
			EndIf

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Efetua o calculo de quanto sera baixado em cada empenho         Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			
			If QtdComp(nQuantBxSD4,.T.) != QtdComp(0,.T.)
				
				If lRetParPrd .And. Empty(aArraySD4[i,z,9]) // ExplodeSD4
					If !Empty(aArraySD4[i,z,6]) //empenho da produГЦo automАtica
						nQuantEst1 := fSaldoAAuto(i,z,aArraySD4,aArrayAuto,.F.,.T.)
										
						If nQuantEst1 >= nQuantEst
							nQuantUso := nQuantEst
							nQuantEst1 -= nQuantEst
							nQuantBxSD4 -= nQuantEst
							nQuantEst := 0
						Else
							nQuantEst  -= nQuantEst1
							nQuantBxSD4 -= nQuantEst1
							nQuantEst1 := 0							
						EndIf
					Else
						If nQuantUso > 0
							aArraySD4[i,z,2] := nQuantUso
							nQuantUso := 0
						Else
							nQuantEst1 := nQuantEst
							nQuantEst  := 0
						EndIf
					EndIf 
				Else
					nQuantEst1 := aArraySD4[i,z,7]
				EndIf 				
											
				nBaixaBxSD4:=Min(QtdComp(nQuantBxSD4),QtdComp(aArraySD4[i,z,7]))
				nBaixaBxSD4:=Min(QtdComp(nQuantBxSD4),QtdComp(nQuantEst1))
				nBaixaBx2SD4:=Min(QtdComp(nQuantBx2SD4),QtdComp(aArraySD4[i,z,13]))
				If QtdComp(nBaixaBxSD4) < QtdComp(aArraySD4[i,z,7])
					aArraySD4[i,z,2] :=nBaixaBxSD4
				EndIf
				nQuantBxSD4-=nBaixaBxSD4
				nQuantBx2SD4-=nBaixaBx2SD4
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Caso tenha baixado toda a quantidade necessaria, passa o indice Ё
				//Ё dos empenhos restantes para ZERO.                               Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			Else
				If lRetParPrd .And. nQuantUso > 0
					aArraySD4[i,z,2] := nQuantUso
					nQuantUso := 0
				Else
					aArraySD4[i,z,2]:=0
				EndIf
			EndIf
		Next z
	Next i

	//здддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Percorre array para atualizar empenho .        Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддды
	For i:=1 to Len(aArraySD4) // ExplodeSD4
		For w:= 1 to Len(aArraySD4[i])
			If aArraySD4[i,w,2] != 0
				//здддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Posiciona no registro corrente .               Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддды
				dbSelectArea("SD4")
				MsGoto(aArraySD4[i,w,1])
				cOpOrig:=SD4->D4_OPORIG
				nPercPrM := RetPerMIt(nParPercPrM)
				//-- Evitar Erros devido a Inconsistencias na Base de Dados
				If !Empty(SD4->D4_OP)
					// Executa Ponto de Entrada para indicar se produz produto intermediario
					If lA250PrPI .And. (!Empty(cOpOrig) .And. dbSeek(xFilial("SD4")+cOpOrig) .And. SC2->(dbSeek(xFilial("SC2")+cOpOrig)))
						MsGoto(aArraySD4[i,w,1])
						nNaoProduzPi:=ExecBlock("A250PRPI",.F.,.F.,{aArraySD4[i,w,2]})
						If ValType(nNaoProduzPi) # "N"
							nNaoProduzPi:=0
						Else
							aArraySD4[i,w,2]-=nNaoProduzPi
						EndIf
					EndIf
					// Produz Produto intermediario
					dbSelectArea("SC2")
					SC2->(dbSetOrder(1))
					If QtdComp(aArraySD4[i,w,2],.T.) > QtdComp(0,.T.) .And. !Empty(cOpOrig)  .And. SC2->(dbSeek(xFilial("SC2")+cOpOrig))
						If dbSeek(xFilial("SD4")+cOpOrig)
							nNivel++
							lRet:= ExplodeSD4((aArraySD4[i,w,2]/SC2->C2_QUANT),cOpOrig,@nNivel,cLocal,cTm,cDoc,dEmissao,cIdent,nRecSD3,@aPedidos,cNumSeq,@aCriaDif,nParPercPrM,@aMRPxJson)
							If !lRet
								Return lRet
							ENDIF
						EndIf
						dbSelectArea("SC2")
						dbSetOrder(1)
						If dbSeek(xFilial("SC2")+cOpOrig)
							//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Verifica o saldo da OP filha e determina o quanto  Ё
							//Ё deve ser produzido em relacao ao saldo proporcionalЁ
							//Ё Se o saldo for menor que o saldo proporcional,     Ё
							//Ё nao produz a OP filha.                             Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
							nSaldo := SC2->C2_QUANT - SC2->C2_QUJE - SC2->C2_PERDA
							If nSaldo < 0
								nSaldo := 0
							EndIf
							nSaldoOpIn := SC2->C2_QUANT

							nQuant := Min(Round(aArraySD4[i,w,2],nDecSD3),(nSaldo+(nSaldoOpIn*nPercPrM)) )

							If cBxProp == "N"
								nQuant := (nSaldo+(nSaldoOpIn*nPercPrM))
							EndIf

							//здддддддддддддддддддддддддддддддддддддддддддддддд©
							//ЁVerifica o tipo de baixa do material de acordo  Ё
							//Ёcom o campo B1_TIPODEC                          Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддды
							nQuant:=A250AvalQt(nQuant,SC2->C2_PRODUTO)
							If nQuant > 0 .And. Empty(SC2->C2_DATRF)
								//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Envia p/func. de atualizacoes (SD3,SB2,SB3,SC2,..) Ё
								//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
								If Rastro(SC2->C2_PRODUTO)
									If lRetParPrd
										nAchouProd:=ASCAN(aCols,{|x| x[1] == SC2->C2_PRODUTO .And. x[2] == SC2->C2_LOCAL .And. x[3] == SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD .And. x[4] == nQuant .And. x[11] == .F.})
										If nAchouProd == 0
											If nComps<len(aCols)
												nComps++
											EndIf
										Else
											nComps := nAchouProd
										EndIF
									Else
										If nComps<len(aCols)
											nComps++
										EndIf
									EndIf
								EndIf
								dbSelectArea("SB1")
								dbSeek(xFilial("SB1")+SC2->C2_PRODUTO)
								//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
								//Ё Grava registro no SD3 das Ops vinculadas a Op Pai  Ё
								//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
								RecLock("SD3",.T.)
								Replace  D3_FILIAL  With xFilial("SD3")	,D3_COD     With SC2->C2_PRODUTO,;
								D3_QUANT   With nQuant       		,D3_TM      With cTm,;
								D3_OP      With SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD,;
								D3_DOC     With cDoc         		,D3_EMISSAO With dEmissao,;
								D3_CC      With SC2->C2_CC   		,D3_UM      With SC2->C2_UM, D3_CLVL      With SC2->C2_CLVL, ;
								D3_GRUPO   With SB1->B1_GRUPO		,D3_TIPO    With SB1->B1_TIPO,;
								D3_SEGUM   With SB1->B1_SEGUM		,D3_CONTA   With SB1->B1_CONTA,;
								D3_LOCAL   With SC2->C2_LOCAL		,D3_CF      With "PR1",;
								D3_CHAVE   With SubStr(D3_CF,2,1)+IIF(D3_CF=="DE4","9","0"),;
								D3_QTSEGUM With ConvUm(SB1->B1_COD,nQuant,0,2),;
								D3_USUARIO With CUSERNAME,;
								D3_IDENT   With cIdent,;
								D3_NIVEL   With SC2->C2_NIVEL,;
								D3_PARCTOT With A250AvalPt(lProdTot,nQuant),;
								D3_NUMLOTE With IIF(Rastro(SC2->C2_PRODUTO),aCols[nComps,GDFieldPos("D3_NUMLOTE")],CriaVar("D3_NUMLOTE")),;
								D3_LOTECTL With IIF(Rastro(SC2->C2_PRODUTO),aCols[nComps,GDFieldPos("D3_LOTECTL")],CriaVar("D3_LOTECTL")),;
								D3_DTVALID With IIF(Rastro(SC2->C2_PRODUTO),aCols[nComps,7],CriaVar("D3_DTVALID")),;
								D3_POTENCI With IIF(Rastro(SC2->C2_PRODUTO),aCols[nComps,8],CriaVar("D3_POTENCI")),;
								D3_NUMSEQ  With cNumSeq,;
								D3_ITEMCTA With SC2->C2_ITEMCTA

								If lFornece
									Replace	D3_FORNDOC With cFornDoc
									Replace	D3_LOJADOC WiTh cLojaDoc
								EndIf

								Replace D3_QTMAIOR With SD4->D4_QTDEORI * nPercPrM

								//здддддддддддддддддд©
								//Ё Portaria CAT83   |
								//юдддддддддддддддддды
								If l240CAT83 .And. Empty(D3_CODLAN)
									Replace D3_CODLAN With A240CAT83()
								EndIf
								
								If lRetParPrd // ExplodeSD4
									AADD(aProdAuto, {aArraySD4[i,w,3],aArraySD4[i,w,4],aArraySD4[i,w,5],aArraySD4[i,w,6],aArraySD4[i,w,11],nQuant})
								EndIf

								lRet := A250Atu(cAlias,cIdent,@aPedidos,@aCriaDif,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,nPercPrM,Nil,Nil,@aMRPxJson)
								If !lRet
									Return lRet
								ENDIF
								A250Nutri(SD3->D3_OP)
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Next w
	Next i

	//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Processa Ordem de Producao Inicial                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
	If nNivel == 0
		dbSelectArea("SD3")
		MsGoto(nRecSD3)
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+cOp)
		If Rastro(SC2->C2_PRODUTO)
			If nComps<len(aCols)
				nComps++
			EndIf
			RecLock("SD3",.F.)
			Replace D3_NUMLOTE With aCols[nComps,GDFieldPos("D3_NUMLOTE")],;
			D3_LOTECTL With aCols[nComps,GDFieldPos("D3_LOTECTL")],;
			D3_DTVALID With aCols[nComps,GDFieldPos("D3_DTVALID")],;
			D3_POTENCI With aCols[nComps,GDFieldPos("D3_POTENCI")]
			MsUnlock(SC2->C2_PRODUTO)
		EndIf
		If Localiza(SC2->C2_PRODUTO,.T.) .And. GDFieldPos("D3_LOCALIZ") > 0 .And. GDFieldPos("D3_NUMSERI") > 0
			if nComps<len(aCols)
				nComps++
			endif
			RecLock("SD3",.F.)
			Replace D3_LOCALIZ With aCols[nComps,GDFieldPos("D3_LOCALIZ")],;
			D3_NUMSERI With aCols[nComps,GDFieldPos("D3_NUMSERI")]
			MsUnlock(SC2->C2_PRODUTO)
		EndIf
		lRet := A250Atu(cAlias,cIdent,@aPedidos,@aCriaDif,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SD3->D3_LOTECTL,SD3->D3_NUMLOTE, nParPercPrM, Nil, Nil, @aMRPxJson)
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Chama integraГЦo com novo MRP                                Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lIntNewMRP .and. lIntLocal
			If Len(aMRPxJson[1]) > 0
				MATA650INT("INSERT", aMRPxJson[1])
				aSize(aMRPxJson[1], 0)
				FreeObj(aMRPxJson[2])
				aMRPxJson[2] := Nil
			EndIf
			If lDelTBMRP
				_lNewMRP := Nil
			EndIf
		EndIf
	EndIf
	nNivel--
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfEnvCQProdЁ Autor Ё Fernando Joly Siquini Ё Data Ё 05/02/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Verifica se o Produto deve ser enviado ao CQ na Produ┤└o.  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё fEnvProdCQ(ExpC1, ExpC2, ExpL1)                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno	 Ё .T. para Enviar o Produto ao CQ, e .F. em caso contr═rio.  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Codigo do Produto a ser Avaliado;                  Ё╠╠
╠╠Ё          Ё ExpC2 = Codigo do Tipo de Movimenta┤└o a ser Avaliada;     Ё╠╠
╠╠Ё          Ё ExpL1 = Atualiza (.T.) ou N└o (.F.) o Contador B1_CONTCQP  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Ger┌rico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function fEnvCQProd(cProduto, cTM, lAtuContB1, lProdNeg, lH6local)

	//-- Inicializa Variaveis Locais
	Local cAliAnt    := Alias()
	Local cQipMat	 := GetNewPar("MV_QIPMAT","N")
	Local lContinua	 := .T.
	Local lMsg       := .T.
	Local lRet       := .F.
	Local nContCQP   := 0
	Local nOrdAnt    := IndexOrd()
	Local nPrapont	 := GetNewPar("MV_PRAPONT",2)
	Local nRecAnt    := Recno()
	Local nSB1Ord    := SB1->(IndexOrd())
	Local nSB1Rec    := SB1->(Recno())
	Local nSF5Ord    := SF5->(IndexOrd())
	Local nSF5Rec    := SF5->(Recno())

	Default lProdNeg := .F.
	Default lH6local := SH6->H6_LOCAL

	//-- Reinicializa Variaveis
	lAtuContB1 := If(lAtuContB1==NIL,.F.,lAtuContB1)

	//-- Posiciona as Ordens dos arquivos utilizados pela fun┤└o
	SB1->(dbSetorder(1))
	SF5->(dbSetorder(1))

	//-- Consiste Parametros
	If cProduto == NIL .Or. cTM == NIL
		//-- Retorna a Integridade do Sistema
		lContinua := .F.
	EndIf

	If lContinua
		//-- Consiste Produto
		If !SB1->(dbSeek(xFilial('SB1')+cProduto, .F.))
			lContinua := .F.
		EndIf
		If cQipMat == 'S'
			If SB1->B1_NUMCQPR <= 0 .And. nPrapont == 2
				lContinua := .F.
			EndIf
		Else
			If (Type('l680') == "L" .And. l680) .Or. (Type('l680') == "L" .And. l681)
				If !(lH6local = GetMvNNR('MV_CQ','98'))
					If SB1->B1_NUMCQPR <= 0
						lContinua := .F.
					EndIf
				EndIf
				If lContinua
					If lProdNeg .And. SB1->B1_NUMCQPR <= 0
						lContinua := .F.
					EndIf
				EndIf
			else
				If SB1->B1_NUMCQPR <= 0
					lContinua := .F.
				EndIf
			endif
		EndIf
	EndIf
	If lContinua
		//-- Consiste Tipo de Movimenta┤└o
		If!SF5->(dbSeek(xFilial('SF5')+cTM, .F.))
			lContinua := .F.
		ElseIf !(SF5->F5_TIPO == 'P' .Or. (lProdNeg .And. SF5->F5_TIPO == 'D')) .Or. (nPrapont == 1 .And. SF5->F5_ENVCQPR # 'S')
			lContinua := .F.
		EndIf
	EndIf

	If lProdNeg .And. !(SF5->F5_CODIGO == cTM)
		//Posiciona no SF5 do movimento origem
		SF5->(MsGoto(nSF5Rec))
		If nPrapont == 1 .And. SF5->F5_TIPO == 'P' .And. SF5->F5_ENVCQPR == 'S'
			lRet := .T.
		EndiF
	EndIf

If lContinua 
		If cQipMat == "S" 
			//-- Consiste Quantas Produ┤■es ainda Faltam para o Envio ao CQ
			//Define o numero para inspecao ou certificaГЦo da Ordem de Producao
			If (Type("l250Auto") == "L" .and. l250Auto) .or. (Type("l680Auto") == "L" .and. l680Auto) .or. (Type("l681Auto") == "L" .and. l681Auto)
				lMsg := .F.
			else
				lMsg := .T.			
			ENDIF

			cRevisao := QA_UltRevEsp(cProduto,,lMsg,,"QIP")

			//Posiciona a Especificacao para verificar a definicao de Skip-Lote
			QP6->(dbSetOrder(1))
			QP6->(dbSeek(xFilial("QP6")+cProduto+Inverte(cRevisao)))

			QPF->(dbSetOrder(1))
			QPF->(dbSeek(xFilial("QPF")+QP6->QP6_SKPLOT))
			nQtdSkipLt := QPF->QPF_QTDE
			lRet := ((nContCQP := SB1->B1_CONTCQP + 1) >= nQtdSkipLt)

		ElseIF SB1->B1_TIPOCQ == 'M' .Or. (nPrapont == 1 .And. SF5->F5_ENVCQPR $ 'S')
			lRet := ((nContCQP := SB1->B1_CONTCQP + 1) >= SB1->B1_NUMCQPR)
		EndIf
		If lAtuContB1
			RecLock('SB1', .F.)
			Replace SB1->B1_CONTCQP With If(lRet, 0, nContCQP)
			SB1->(MsUnlock())
		EndIf
	EndIf
	
	If ExistBlock("MT680QUA")
		lRet := ExecBlock("MT680QUA",.F.,.F.)
		If ValType(lRet)<> "L"
			lRet :=.F.
		EndIf
	EndIf
	//-- Retorna a Integridade do Sistema
	SB1->(dbSetOrder(nSB1Ord))
	SB1->(MsGoto(nSB1Rec))
	SF5->(dbSetOrder(nSF5Ord))
	SF5->(MsGoto(nSF5Rec))

	// ALTERAгцO MATEUS HENGLE - 14/07/2023
	If !Empty(cAliant) 
		dbSelectArea(cAliAnt)
		dbSetOrder(nOrdAnt)
		MsGoto(nRecAnt)
	EndIf
	// ALTERAгцO MATEUS HENGLE - 14/07/2023

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ёa250GravD3Ё Autor Ё Fernando Joly Siquini Ё Data Ё 27/09/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Grava campos do D3 que nфo foram atualizados pelo AxInclui Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё a250GravD3                                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno	 Ё NIL                                                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ                                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Mata250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function a250GravD3()
	Local aAreaSd3
	Local aBack        :=aClone(aRotina)
	Local aPerdaPa 	   := {}
	Local aPerdaMp 	   := {}
	Local aCriaDif     :={{}}
	Local aDigLot	   := {}
	Local lIntNewMRP   := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
	Local aMRPxJson    := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP
	Local aPedidos     := {}
	Local cBxProp      := GetMv("MV_BXPROP")
	Local cDocto       := M->D3_DOC
	Local cFornDoc	   := " "
	Local cFuncSubs	   := "SUBSTRING"
	Local cLocal,cTm,cDoc,dEmissao,nRecSD3
	Local cLojaDoc	   := " "
	Local cNumOP       := ""
	Local cNumSeq, cIdent
	Local cOP          := ""
	Local cOpDig       := Alltrim(M->D3_OP)
	Local cSeq         := ""
	Local cTmp         := GetNextAlias()
	Local cVarreSd3	   := ""
	Local l240CAT83    := FindFunction("V240CAT83") .And. V240CAT83()
	Local lDelTBMRP    := _lNewMRP == NIL
	Local lDISTMOV	   := SuperGetMV("MV_DISTMOV",.F.,.F.)
	Local lEmptyGra	   := .T.
	Local lFornece     := SD3->(ColumnPos("D3_FORNDOC")) > 0 .And. SD3->(ColumnPos("D3_LOJADOC")) > 0
	Local lPmsInt      := IsIntegTop(,.T.)
	Local lRet         := .T.
	Local lWmsNew      := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local lWmsSD3      := IIf(!(Type('lExecWms')=='U'), lExecWms, .F.)
	Local n,z,w
	Local nIndice      := 1
	Local nPercPrM     := 0
	Local nPerda	   := 0
	Local nRecProd	   := SD3->(Recno())
	Local nTamOP       := 11	

	Private aCols      := {}
	Private aHeader    := {}
	Private aLotes     := {}
	Private aLotPrdAut := {}

	Default aEmpQtNec  := {}
	Default aEmpSaldo  := {}
	Default aProdAuto  := {}

	If Type('lGrade')=='U'
		Private lGrade := MaGrade()
	EndIf

	If lFornece
		cFornDoc := SD3->D3_FORNDOC
		cLojaDoc := SD3->D3_LOJADOC //m?
	EndIf

	If lProc113 .And. !l250Auto
		Return nil
	Endif

	If IsAtNewGrd()
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se grade foi informada                              Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lGrade
			lEmptyGra := oGrade:EmptyGrd("D3_QUANT")
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Grava no SD3 os produtos que foram Informados na Grade       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If MatGrdPrrf(M->D3_COD) .Or. ( lGrade .And. !lEmptyGra )
			If lEmptyGra
				aQtdGrade(.F.)
			EndIf
			If !oGrade:EmptyGrd("D3_QUANT")
				Ma650GraGr("SD3","A250",.T.)
				dbSetOrder(1)
				dbSeek(xFilial("SD3")+Substr(cOPDig,1,nTamOP))
			EndIf
		EndIf
	Else
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Grava no SD3 os produtos que foram Informados na Grade       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If MatGrdPrrf(M->D3_COD) .Or. (lGrade .And. Len(aCols) > 0)
			If Len(acols) == 0
				aQtdGrade(.F.)
			EndIf
			aColsGrd := AClone(aCols)
			If Len(acolsGrd) > 0
				Ma650GraGr("SD3","A250",.T.)
				dbSetOrder(1)
				dbSeek(xFilial("SD3")+Substr(cOPDig,1,nTamOP))
			EndIf
		EndIf
	EndIf

    If GetMV("MV_TTS") == "S" //DMANSMARTSQUAD1-10733

		cVarreSd3 :=	   "SELECT R_E_C_N_O_  SD3RECNO, D3_NUMSEQ SD3NUMSEQ FROM " + RetSqlName("SD3")
		cVarreSd3 +=	" WHERE "
		cVarreSd3 +=	"	D3_FILIAL = '" + xFilial("SD3") + "' "
		cVarreSd3 +=	"	AND " + cFuncSubs + "(D3_OP,1," + AllTrim(Str(nTamOP)) + ") = '" + Substr(cOPDig,1,nTamOp) + "' "
		cVarreSd3 +=	"	AND NOT (D3_TM > '500' "
		cVarreSd3 +=	"	OR D3_DOC <> '" + cDocto + "' "
		cVarreSd3 +=	"	OR SUBSTRING(D3_CF,1,2) = 'DE' "
		cVarreSd3 +=	   "	AND D3_ESTORNO <> 'S' ) "
		cVarreSd3 +=	"	AND D_E_L_E_T_ = '' "
		cVarreSd3 +=    "   ORDER BY R_E_C_N_O_ "
		cVarreSd3 := ChangeQuery(cVarreSd3)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cVarreSd3),cTmp,.T.,.F.)


		aAreaSD3 := SD3->(GetArea())
		Do While (cTmp)->(!(EoF()))
			If !(Empty((cTmp)->SD3RECNO)) .And. Empty((cTmp)->SD3NUMSEQ)

				SD3->(DbGoto((cTmp)->SD3RECNO))

				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Pega o proximo numero sequencial de movimento      Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				cNumSeq := ProxNum()
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Variavel que faz amarracao entre OP Pai e OPS filhas .       Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				cIdent  := ProxNum()

				RecLock('SD3',.F.)
				Replace D3_CF      With If(D3_CF#'PR1','PR0',D3_CF)
				Replace D3_CHAVE   With SubStr(D3_CF,2,1)+IF(D3_CF=='DE4','9','0')
				Replace D3_NUMSEQ  With cNumseq
				Replace D3_USUARIO With CUSERNAME
				Replace D3_IDENT   With cIdent

				If lFornece
					Replace	D3_FORNDOC With cFornDoc
					Replace	D3_LOJADOC WiTh cLojaDoc
				EndIf


				//здддддддддддддддддд©
				//Ё Portaria CAT83   |
				//юдддддддддддддддддды
				If l240CAT83 .And. Empty(D3_CODLAN)
					Replace D3_CODLAN With A240CAT83()
				EndIf

				MsUnlock()

				If SD3->D3_CF == 'PR0'
					fGravaSMO(SD3->D3_NUMSEQ, '1')
				EndIf

				cLocal   := SD3->D3_LOCAL
				cTm      := SD3->D3_TM
				cDoc     := SD3->D3_DOC
				dEmissao := SD3->D3_EMISSAO

				nRecSD3	:= SD3->(Recno())

				cIdent := SD3->D3_IDENT

				lReqOrig := RetReqOrig()
				If !lReqOrig 
					If lSavePerda			
					GravaSBC(SD3->D3_OP,NIL,NIL,"MATA250",SD3->D3_NUMSEQ)
					aPerda:={}
					aHdPerda:={}
					lSavePerda:=.F.
					EndIf
				EndIf
				
				dbSelectArea("SC2")
				dbSetOrder(1)
				If dbSeek(xFilial("SC2")+Alltrim(SD3->D3_OP))
					nPercPrM := (SD3->D3_QTMAIOR / SC2->C2_QUANT)
				EndIf
				
				aPerdaPa := {}
				aPerdaMp := {}
					
				for nPerda := 1 to len(aPerda)				
					If aPerda[nPerda,1] == SC2->C2_PRODUTO
						Aadd(aPerdaPa,aPerda[nPerda])
					Else
						Aadd(aPerdaMp,aPerda[nPerda])
					EndIf
				next nPerda

				//Processa a perda das matИrias primas.
				aPerda := aPerdaMp

				lReqOrig := RetReqOrig()
				If lReqOrig .and. Len(aPerda) > 0						
					GravaSBC(SD3->D3_OP,NIL,NIL,"MATA250",SD3->D3_NUMSEQ)
					aPerda:={}					
				EndIf

				lProdaut := IIF( lProdaut, .T., fRetPrdAut(SD3->D3_OP) )
				
				If lProdAut
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Variaveis utilizadas pela rastreabilidade                    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					nComps := 0
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Gera lancamentos de producao das Ops vinculadas    Ё
					//Ё a Op Pai (produto Acabado)                         Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					cNumOp := SubStr(SD3->D3_OP,1,8)
					cOp    := Alltrim(SD3->D3_OP)
					cIdent := SD3->D3_IDENT
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Proporcionaliza de acordo com a qtde da OP Pai     Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					nIndice := 1
					dbSelectArea("SC2")
					dbSetOrder(1)
					If dbSeek(xFilial("SC2")+cOp)
						If SD3->D3_PARCTOT == "P" .And. cBxProp == "S"
							If lPerdInf
								if nPercPrM = 0
									nIndice := Min(1,SD3->D3_QUANT / SC2->C2_QUANT)
								else
									nIndice := Max(1,SD3->D3_QUANT / SC2->C2_QUANT)
								endif
							Else
								nIndice := Min(1,(SD3->D3_QUANT + SD3->D3_PERDA) / SC2->C2_QUANT)
							EndIf
						EndIf
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Funcao de digitacao de lotes qdo utiliza producao  Ё
					//Ё automatica                                         Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					If GetMV("MV_RASTRO") == "S"
						aProdAuto := {}
						aEmpSaldo := {}
						aEmpQtNec := {}
						LotesSD4(nIndice,SD3->D3_OP,0,@aLotes,.F.,NIL,NIL,SD3->D3_QUANT,SD3->D3_PARCTOT, nPercPrM)
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Fun┤└o para digita┤└o dos lotes de controle.       Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					If Len(aLotes) > 0
						A250DigLot()
						aRotina:=aClone(aBack)
					EndIf
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Producao automatica atraves do empenho             Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					lRet := ExplodeSD4(Min(1,(SD3->D3_QUANT +If(!lPerdInf,SD3->D3_PERDA,0)) / SC2->C2_QUANT),SD3->D3_OP,0,cLocal,cTm,cDoc,dEmissao,cIdent,nRecSD3,@aPedidos,cNumSeq,@aCriaDif,nPercPrM,@aMRPxJson)
				Else
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Envia p/func. de atualizacoes (SD3,SB2,SB3,SC2,..) Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					lRet := A250Atu("SD3",cIdent,@aPedidos,@aCriaDif,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,nPercPrM,Nil,Nil,@aMRPxJson)
				EndIf

				if !lRet
				    RestArea(aAreaSD3)
					(cTmp)->(DbCloseArea())
					Return .F.
			    endif 

				If !lWmsNew 
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Abre uma tela que permite ao usuАrio endereГar os produtos  Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If Localiza(SC2->C2_PRODUTO) .And. lDISTMOV
						aADD(aDigLot,{	'0001',;
						SD3->D3_COD,;
						SD3->D3_LOCAL,;
						SD3->D3_LOTECTL,;
						SD3->D3_NUMLOTE,;
						SD3->D3_DTVALID,;
						SD3->D3_QUANT,;
						SD3->D3_NUMSEQ,;
						SD3->D3_DOC,;
						CriaVar("D1_SERIE"),;
						CriaVar("D1_FORNECE"),;
						CriaVar("D1_LOJA"),;
						.F.	})
						If !l250Auto
							A103DigEnd(aDigLot)
						Endif
					EndIf
				Else
					// VariАvel de controle para gerar ou nЦo uma ordem de serviГo no WMS
					If !lWmsSD3 .And. IntWms(SD3->D3_COD)
						// IntegraГЦo apontamento ordem de produГЦo com WMS
						lTranWMS := WmsIntOP(nRecSD3,cA240End)
					EndIf
				EndIf

				A250Nutri(SD3->D3_OP)	
				
				//Processa a perda do produto da ordem de produГЦo.
				aPerda := aPerdaPa

				lReqOrig := RetReqOrig()
				If lReqOrig .AND. Len(aPerda) > 0					
					GravaSBC(SD3->D3_OP,NIL,NIL,"MATA250",SD3->D3_NUMSEQ)
				EndIf
				
				aPerda:={}
				aHdPerda:={}				

				(cTmp)->(dbSkip())
			else
				(cTmp)->(dbSkip())
			EndIF
		EndDo
		RestArea(aAreaSD3)

		(cTmp)->(DbCloseArea())
	Else
       /*Varre a SD3*/
		Do While !EOF() .And. SD3->D3_FILIAL+Substr(SD3->D3_OP,1,nTamOP) == xFilial("SD3")+Substr(cOPDig,1,nTamOp) .AND. lRet

			If SD3->D3_TM > "500" .Or. SD3->D3_DOC != cDocto .Or. Substr(SD3->D3_CF,1,2) == "DE" .Or. !Empty(SD3->D3_NUMSEQ)
				dbSkip()
				loop
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Pega o proximo numero sequencial de movimento      Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			cNumSeq := ProxNum()
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Variavel que faz amarracao entre OP Pai e OPS filhas .       Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			cIdent  := ProxNum()

			RecLock('SD3',.F.)
			Replace D3_CF      With If(D3_CF#'PR1','PR0',D3_CF)
			Replace D3_CHAVE   With SubStr(D3_CF,2,1)+IF(D3_CF=='DE4','9','0')
			Replace D3_NUMSEQ  With cNumseq
			Replace D3_USUARIO With CUSERNAME
			Replace D3_IDENT   With cIdent

			//здддддддддддддддддд©
			//Ё Portaria CAT83   |
			//юдддддддддддддддддды
			If l240CAT83 .And. Empty(D3_CODLAN)
				Replace D3_CODLAN With A240CAT83()
			EndIf

			MsUnlock()

			cLocal   := SD3->D3_LOCAL
			cTm      := SD3->D3_TM
			cDoc     := SD3->D3_DOC
			dEmissao := SD3->D3_EMISSAO

			nRecSD3	:= SD3->(Recno())

			cIdent := SD3->D3_IDENT

			lReqOrig := RetReqOrig()
			If !lReqOrig 
				If lSavePerda
					GravaSBC(SD3->D3_OP,NIL,NIL,"MATA250",SD3->D3_NUMSEQ)
					aPerda:={}
					aHdPerda:={}
					lSavePerda:=.F.
				EndIf
			EndIf
	      
			dbSelectArea("SC2")
			dbSetOrder(1)
			If dbSeek(xFilial("SC2")+Alltrim(SD3->D3_OP))
				nPercPrM := (SD3->D3_QTMAIOR / SC2->C2_QUANT)
			EndIf

			aPerdaPa := {}
			aPerdaMp := {}
					
			For nPerda := 1 to len(aPerda)				
				If aPerda[nPerda,1] == SC2->C2_PRODUTO
					Aadd(aPerdaPa,aPerda[nPerda])
				Else
					Aadd(aPerdaMp,aPerda[nPerda])
				EndIf
			Next nPerda

			//Processa a perda das matИrias primas.
			aPerda := aPerdaMp

			lReqOrig := RetReqOrig()
			If lReqOrig .and. Len(aPerda) > 0						
				GravaSBC(SD3->D3_OP,NIL,NIL,"MATA250",SD3->D3_NUMSEQ)
				aPerda:={}					
			EndIf

			lProdaut := IIF( lProdaut, .T., fRetPrdAut(SD3->D3_OP) )

			If lProdAut
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Variaveis utilizadas pela rastreabilidade                    Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				nComps := 0
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Gera lancamentos de producao das Ops vinculadas    Ё
				//Ё a Op Pai (produto Acabado)                         Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				cNumOp := SubStr(SD3->D3_OP,1,8)
				cOp    := Alltrim(SD3->D3_OP)
				cIdent := SD3->D3_IDENT
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Proporcionaliza de acordo com a qtde da OP Pai     Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				nIndice := 1
				dbSelectArea("SC2")
				dbSetOrder(1)
				If dbSeek(xFilial("SC2")+cOp)
					If SD3->D3_PARCTOT == "P" .And. cBxProp == "S"
					If lPerdInf
						if nPercPrM = 0
							nIndice := Min(1,SD3->D3_QUANT / SC2->C2_QUANT)
						else
							nIndice := Max(1,SD3->D3_QUANT / SC2->C2_QUANT)
						endif
					Else
						nIndice := Min(1,(SD3->D3_QUANT + SD3->D3_PERDA) / SC2->C2_QUANT)
					EndIf
					EndIf
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Funcao de digitacao de lotes qdo utiliza producao  Ё
				//Ё automatica                                         Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				If GetMV("MV_RASTRO") == "S"
					aProdAuto := {}
					aEmpSaldo := {}
					aEmpQtNec := {}
					LotesSD4(nIndice,SD3->D3_OP,0,@aLotes,.F.,NIL,NIL,SD3->D3_QUANT,SD3->D3_PARCTOT, nPercPrM)
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Fun┤└o para digita┤└o dos lotes de controle.       Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(aLotes) > 0
					A250DigLot()
					aRotina:=aClone(aBack)
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Producao automatica atraves do empenho             Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				lRet:= ExplodeSD4(Min(1,(SD3->D3_QUANT + If(!lPerdInf,SD3->D3_PERDA,0)) / SC2->C2_QUANT),SD3->D3_OP,0,cLocal,cTm,cDoc,dEmissao,cIdent,nRecSD3,@aPedidos,cNumSeq,@aCriaDif,nPercPrM,@aMRPxJson)
			Else
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Envia p/func. de atualizacoes (SD3,SB2,SB3,SC2,..) Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				lRet:= A250Atu("SD3",cIdent,@aPedidos,@aCriaDif,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,nPercPrM,Nil,Nil,@aMRPxJson)
			EndIf

			If !lWmsNew
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Abre uma tela que permite ao usuАrio endereГar os produtos  Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Localiza(SC2->C2_PRODUTO) .And. lDISTMOV
				aADD(aDigLot,{	'0001',;
									SD3->D3_COD,;
									SD3->D3_LOCAL,;
									SD3->D3_LOTECTL,;
									SD3->D3_NUMLOTE,;
									SD3->D3_DTVALID,;
									SD3->D3_QUANT,;
									SD3->D3_NUMSEQ,;
									SD3->D3_DOC,;
									CriaVar("D1_SERIE"),;
									CriaVar("D1_FORNECE"),;
									CriaVar("D1_LOJA"),;
									.F.	})
					If !l250Auto				
						A103DigEnd(aDigLot)
					EndIf
				EndIf
			Else
				// VariАvel de controle para gerar ou nЦo uma ordem de serviГo no WMS
				If !lWmsSD3 .And. IntWms(SD3->D3_COD)
					// IntegraГЦo apontamento ordem de produГЦo com WMS
					lTranWMS := WmsIntOP(nRecSD3,cA240End)
				EndIf
			EndIf

	      	A250Nutri(SD3->D3_OP)

			//Processa a perda do produto da ordem de produГЦo.
			aPerda := aPerdaPa

			lReqOrig := RetReqOrig()
			If lReqOrig .AND. Len(aPerda) > 0					
				GravaSBC(SD3->D3_OP,NIL,NIL,"MATA250",SD3->D3_NUMSEQ)
			EndIf

			aPerda:={}
			aHdPerda:={}

			dbSelectArea("SD3")
			dbSkip()
       	EndDo
	Endif

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Chama integraГЦo com novo MRP                                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lIntNewMRP
		If Len(aMRPxJson[1]) > 0
			MATA650INT("INSERT", aMRPxJson[1])
			aSize(aMRPxJson[1], 0)
			FreeObj(aMRPxJson[2])
			aMRPxJson[2] := Nil
		EndIf
		If lDelTBMRP
			_lNewMRP := Nil
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Caso tenha liberado pedidos atraves da producao,   Ё
	//Ё atualiza campo no SC5                              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
	If Len(aPedidos) > 0
		MaLiberOk(aPedidos)
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Cria o registro de diferenca entre os empenhos.              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	For n:=1 to Len(aCriaDif)
		For z:=1 to Len(aCriaDif[n])
			If !Empty(aCriaDif[n,z,1])
				dbSelectArea("SD4")
				MsGoto(aCriaDif[n,z,1])
				// cSeq - chave sequencial para evitar erro de chave unica
				cSeq := SD4->D4_SEQ
				Reclock("SD4",.F.)
				Replace D4_QTDEORI	With D4_QTDEORI - aCriaDif[n,z,2]
				If Empty(SD4->D4_SEQ)
					cSeq := Soma1(cSeq)
					Replace D4_SEQ	With cSeq
				EndIf
				MsUnlock()
				RecLock("SD4",.T.)
				For w := 1 TO Len(aCriaDif[n,z,3])
					FieldPut(w,aCriaDif[n,z,3,w])
				Next w
				Replace D4_SEQ	With Soma1(cSeq)
				MsUnlock()
			EndIf
		Next z
	Next n

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Atualiza os arquivos do SIGAPMS                              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	// utiliza a requisiГЦo automАtica de produto?
	If IntePMS() .And. GetNewPar("MV_PMSPREQ", "1") == "1" .And. !Localiza(SD3->D3_COD,.T.).AND. !lPmsInt
		SD3->(MsGoTo(nRecProd))
		A250PmsReq(cOpDig, 1)
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Integracao com SIGASGA                     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддды
	SGAGEEPCP(M->D3_OP,"3")//Geracao de Gases de Efeito Estufa - GEE

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Desbloqueia a OP apos apontamento                      Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If SuperGetMV("MV_BLQOPAP",.F.,"N") == "S"
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+cOPDig))
			MsUnlock()
		EndIf
	EndIf
	SD3->(MsGoTo(nRecProd))

	// Contabiliza qunado nЦo for para contabilizar os itens em lote.
	// parametro a definir, e o padrao И para contabilizar em lote. No apontamento mata250.
	IF ! lctbLote
		A250Comum(aCtbDia)
	endif

	if l250Auto .and. (cPcpPend == '2' .OR. cPcpPend == '4')   //caso venha por execauto E esteja parametrizado para gravar apontamento pendente, verifica se teve erro na gravaГЦo
		if !lRet //caso tenha dado problema na gravaГЦo, disarm transaction e grava log logo depois
			aAdd(aRotAuto,{"GRAVA","2",NIL})
			aAdd(aRotAuto,{'NUMSEQ',SD3->D3_NUMSEQ,NIL})
		endif

	endif

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250VldPV Ё Autor ЁRodrigo de A. Sartorio Ё Data Ё 25/02/00 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Valida estorno da producao quando OP esta amarrada a um PV Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Mata250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250VldPV()
	Local lRet    :=.T.
	Local aArea   :=GetArea()
	Local aAreaSC2:=SC2->(GetArea())
	Local aAreaSC6:=SC6->(GetArea())

	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2")+SD3->D3_OP)) .And. !Empty(SC2->C2_PEDIDO)
		If SC6->(dbSeek(xFilial("SC6")+SC2->C2_PEDIDO+SC2->C2_ITEMPV)) .And. SC6->C6_QTDENT > 0
			lRet:=Aviso(STR0035,STR0041,{STR0038, STR0039},,, 1) == 2 //'Aten┤└o'###'A OP desta producao esta amarrada a um PV ja faturado.Quanto ao estorno ?'###'Abandona'###'Prossegue'
		EndIf
		RestArea(aAreaSC6)
	EndIf
	RestArea(aAreaSC2)
	RestArea(aArea)
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250AvalQtЁ Autor ЁRodrigo de A. Sartorio Ё Data Ё 15/06/00 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Verifica a qtd a ser movimentada ou produzida              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250AvalQt(ExpN1,ExpC1)                                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno	 Ё Quantidade de acordo com o conteudo do campo B1_TIPODEC    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpN1 = Quantidade Original                                Ё╠╠
╠╠Ё          Ё ExpC1 = Produto a ter a qtd calculada                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Gen┌rico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250AvalQt(nQuant,cProduto)
	Local aAreaSB1:={}
	Local lOK     :=.T.
	Local lSeek   :=.F.

	//здддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁCaso necessario posiciona produto               Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддды
	If SB1->B1_FILIAL+SB1->B1_COD != xFilial("SB1")+cProduto
		aAreaSB1:=SB1->(GetArea())
		lSeek:=.T.
		lOk:=SB1->(dbSeek(xFilial("SB1")+cProduto))
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica o tipo de baixa do material de acordo  Ё
	//Ёcom o campo B1_TIPODEC                          Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддды
	If lOk .And. (SB1->B1_TIPODEC == "A")
		nQuant := Round( nQuant,0 )
	ElseIf lOk .And. (SB1->B1_TIPODEC == "I")
		nQuant := Int(nQuant)+If(((nQuant-Int(nQuant)) > 0),1,0)
	ElseIf lOk .And. (SB1->B1_TIPODEC == "T")
		nQuant := Int( nQuant )
	ElseIf lOk
		nQuant := QtdComp(nQuant)	   
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁVolta status original no arquivo SB1            Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддды
	If lSeek
		RestArea(aAreaSB1)
	EndIf
Return nQuant

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    Ёa250VldOp Ё Autor ЁPatricia A. Salomao    Ё Data Ё03/2001   Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁVerifica se devera' Baixar Todos os Itens da Grade ou apenasЁ╠╠
╠╠Ё          Ёo item informado.                                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё.T.                                                         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁNenhum                                                      Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao Efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё          Ё               Ё                                            Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/

Function a250VldOP()
	Local cNumOp 	:= Alltrim(M->D3_OP)
	Local lChkRef	:= .F.
	Local lRet		:= .T.
	Local nQuant 	:= 0
	Local nQuant2UM := 0
	Local nTamOp 	:= Len(Alltrim(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD))
	//--------- Existe somente para manter legado ate R4 --------
	Local cMascara	 := GetMv("MV_MASCGRD")
	Local nTamRef	 := Val(Substr(cMascara,1,2))
	//-----------------------------------------------------------
	Local aAreaSC2  := ''
	Local cProd     := M->D3_COD
	Local lBxTudo   := .F.
	Local lGrade    := MaGrade()

	If lRet
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁSe nao digitou o item da Grade,ira baixar todos os itens da OP, senao, ira baixar apenas o item da grade digitadoЁ
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		lBxTudo	  := If(Len(Alltrim(cNumOp))==Len(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN),.T.,.F.)
	
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o produto digitado eh para baixar tudo e eh interface grade Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lBxTudo .And. lGrade .And. SC2->C2_GRADE=="S"
			aAreaSC2 := GetArea()
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё se digitou apenas o no. da op, pegar o codigo de referencia do Item     Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If IsAtNewGrd()
				If( SC2->C2_GRADE=="S" .And. Len(cNumOp)!=Len(Alltrim(nTamOp)) )
					cProd 	:= SC2->C2_PRODUTO
					lChkRef := .T.
				Else
					cProd := M->D3_COD
				EndIf
			Else
				cProd := If(SC2->C2_GRADE=="S" .And. Len(cNumOp)!=Len(Alltrim(nTamOp)),Substr(SC2->C2_PRODUTO,1,nTamRef),M->D3_COD)
			EndIf

			Do While C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN == xFilial("SC2")+cNumOp
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se e' OP Prevista                                              Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If SC2->C2_TPOP == "P"
					Help(" ",1,"NOPPREVIST")
					lRet := .F.
					Exit
				EndIf
				If Empty(C2_DATRF)	.And. SC2->C2_GRADE =="S"
					nQuant+= C2_QUANT-C2_QUJE-If(lPerdInf,0,C2_PERDA)
					nQuant2Um += C2_QTSEGUM - ConvUm(SC2->C2_PRODUTO, SC2->C2_QUJE, 0, 2)-ConvUm(SC2->C2_PRODUTO, If(lPerdInf,0,SC2->C2_PERDA), 0, 2)
				EndIf
				dbSkip()
			EndDo

			If lRet
				RestArea(aAreaSC2)
				M->D3_QUANT := nQuant
				M->D3_QTSEGUM := nQuant2Um
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//ЁSe nao digitou codigo do produto, chama funcao para montar a grade de produtos desta OPЁ
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If IsAtNewGrd()
					If MatGrdPrrf(@cProd,lChkRef)
						aProdGrade(cProd)
					EndIf
				Else
					If MatGrdPrrf(@cProd)
						aProdGrade(Substr(cProd,1,nTamRef))
					EndIf
				EndIf
				M->D3_COD   := cProd
			EndIf
		Else
			M->D3_COD  := SC2->C2_PRODUTO
		EndIf
	EndIf

Return lRet

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    Ёa250InsereЁ Autor ЁPatricia A. Salomao    Ё Data Ё 03/2001  Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁInsere na Coluna de Qtde. da Grade, a Qtde. a ser produzida Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁExpC1 - Nome do Campo                                       Ё╠╠
╠╠Ё          ЁExpL1 - Verifica se ja' foram informadas na grade, as qtdes Ё╠╠
╠╠Ё          Ё        a serem produzidas. Se ExpL1 ==True , traz na grade Ё╠╠
╠╠Ё          Ё        as qtdes de acordo com o arquivo SC2; Caso contrarioЁ╠╠
╠╠Ё          Ё        traz na grade as qtdes. que foram digitadas.        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁSempre .T.                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao Efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё          Ё               Ё                                            Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function a250Insere(cCampoQtd,lFirst)
	Local nQtd, nQuje, nPerda := 0
	Local nLinha, nColuna
	Local cLinha, cColuna
	Local lAchou    := .F.
	Local nAux      := 1
	Local nQuant    := 0

	If IsAtNewGrd()
		dbSelectArea("SC2")
		aAreaSC2 := GetArea()
		dbSeek(xFilial("SC2")+Alltrim(M->D3_OP))
		cNumOp := SC2->C2_NUM
		Do While !Eof() .And. C2_FILIAL+C2_NUM == xFilial("SC2")+cNumOp
			If SC2->C2_GRADE !="S"
				dbSkip()
				Loop
			EndIf

			cLinha := Substr(SC2->C2_PRODUTO,oGrade:TamRef()+1,oGrade:TamLin())
			cColuna:= Substr(SC2->C2_PRODUTO,oGrade:TamRef()+oGrade:TamLin()+1,oGrade:TamCol())

			For nLinha :=  1 To Len(oGrade:aColsGrade[nAux])
				For nColuna := 2 To Len(oGrade:aHeadGrade[nAux])
					lAchou := .F.
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//ЁAlimenta a Coluna de Quantidade, com o valor da Qtde `a produzir        Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If  (oGrade:GetNameLinha(nLinha)== cLinha) .And. (oGrade:GetNameColuna(nColuna)==cColuna) .And. SC2->C2_GRADE =="S" .And. Empty(SC2->C2_DATRF)
						lAchou := .T.
						nQtd  := If(cCampoQtd == "M->D3_QTSEGUM" .and. lFirst,ConvUm(SC2->C2_PRODUTO, SC2->C2_QUANT,SC2->C2_QTSEGUM,2), 0)
						nQuje := If(cCampoQtd == "M->D3_QTSEGUM" .and. lFirst,ConvUm(SC2->C2_PRODUTO, SC2->C2_QUJE ,0,2), 0)
						nPerda:= If(cCampoQtd == "M->D3_QTSEGUM" .and. lFirst,ConvUm(SC2->C2_PRODUTO, SC2->C2_PERDA,0,2), 0)

						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//ЁNao inserir na Grade Quantidades Negativas             Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If nQtd-nQuje-nPerda >= 0
							oGrade:aColsGrade[nAux][nLinha][nColuna][oGrade:GetFieldGrdPos("D3_QTSEGUM")] :=If(Empty(oGrade:aColsFieldByName("D3_QTSEGUM",nAux,nLinha,nColuna)) ,nQtd-nQuje-nPerda,oGrade:aColsFieldByName("D3_QTSEGUM",nAux,nLinha,nColuna))
						EndIf

						If lFirst
							nQuant := SC2->C2_QUANT-SC2->C2_QUJE-If(lPerdInf,0,SC2->C2_PERDA)
							oGrade:aColsGrade[nAux][nLinha][nColuna][oGrade:GetFieldGrdPos("D3_QUANT")] := If(nQuant >0, nQuant, 0)
							//aCols[nLinha][nColuna] := If(cCampoQtd == "M->D3_QTSEGUM" ,aColsGrade[nAux][nLinha][nColuna][nColQtd2],aColsGrade[nAux][nLinha][nColuna][nColQtd])
						EndIf
					EndIf
				Next nColuna
			Next nLinha
			SC2->(dbSkip())
		EndDo
		RestArea(aAreaSC2)
	Else
		_a250Insere(cCampoQtd,lFirst)
	EndIf
Return .T.

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    ЁaParcTot  Ё Autor ЁPatricia A. Salomao    Ё Data Ё 03/2001  Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁInformar se a baixa dos Itens da Grade sera Total / Parcial Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁExpC1 - Nome do Programa                                    Ё╠╠
╠╠Ё          ЁExpC2 - Se Mostra ou Nao a GetDados                         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁSempre .T.                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao Efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё          Ё               Ё                                            Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/

Function aParcTot(cProg, lMostra)
	Local lRet	:= .T.
	Local nLinha, nColuna
	Local cProdRef := M->D3_COD
	Local cCodProd := ""
	Local lGrade   := MaGrade()
	Local cParcTot := " "
	Local nAux     := 1
	Local aAreaSC2 := SC2->(GetArea())
	DEFAULT cProg 	:= ''
	DEFAULT lMostra	:= .T.

	If IsAtNewGrd()
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se a grade esta ativa                       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If ( lGrade ) .And.  MatGrdPrrf(@cProdRef) .And. cProg == "A250"
			M->D3_PARCTOT := " "
			If !Empty(M->D3_OP)
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se ja montou a grade de produtos desta OP           Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(oGrade:aColsGrade) == 0
					aQtdGrade(.F.)
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Carrega dados da grade                                       Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				For nLinha :=  1 To Len(oGrade:aColsGrade[nAux])
					For nColuna := 2 To Len(oGrade:aHeadGrade[nAux])
						dbSelectArea("SC2")
						dbSetOrder(6)
						cCodProd := oGrade:GetNameProd(cProdRef,nLinha,nColuna)
						If dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)+cCodProd)
							cParcTot := " "
							If oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)>0 .And. (oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)>=(SC2->C2_QUANT-SC2->C2_QUJE-If(lPerdInf,0,SC2->C2_PERDA)))
								cParcTot := "T"
							ElseIf oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)>0 .And. (oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)<(SC2->C2_QUANT-SC2->C2_QUJE-If(lPerdInf,0,SC2->C2_PERDA)))
								cParcTot := "P"
							ElseIf oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)==0.And.(!Empty(C2_DATRF))
								cParcTot := "B"
							ElseIf oGrade:aColsFieldByName("D3_QUANT",nAux,nLinha,nColuna)==0 .And.Empty(C2_DATRF)
								cParcTot := "X"
							EndIf
							oGrade:aColsGrade[nAux,nLinha,nColuna][oGrade:GetFieldGrdPos("D3_PARCTOT")] := If(!lMostra .And. oGrade:EmptyGrd("D3_PARCTOT"), "T", cParcTot)
						Else
							oGrade:aColsGrade[nAux,nLinha,nColuna][oGrade:GetFieldGrdPos("D3_PARCTOT")] := "--"
						EndIf
					Next nColuna
				Next nLinha

				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Mostra Grade para entrada de dados referente a Total e ParcialЁ
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				lRet := oGrade:Show("D3_PARCTOT")
			Else
				Help("",1,"A650NOP")
				lRet := .F.
			EndIf
		EndIf
		RestArea(aAreaSC2)
	Else
		lRet := _aParcTot(cProg, lMostra)
	EndIf
Return lRet

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    ЁaQtdPerda Ё Autor ЁPatricia A. Salomao    Ё Data Ё 03/2001  Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁInformar a Qtd. de Perda dos Itens da Grade                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁExpC1 - Nome do Programa                                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁSempre .T.                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao Efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё24/07/2006ЁErike Yuri     ЁAlteracao das chamadas da grade para objeto Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/

Function aQtdPerda(cProg)

	Local nLinha, nColuna
	Local cProdRef := M->D3_COD
	Local lGrade   := MaGrade()
	Local nSoma    := 0
	Local nAux     := 1
	DEFAULT cProg := ''

	If IsAtNewGrd()
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se a grade esta ativa e se o prod. e' uma referenciaЁ
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If ( lGrade ) .And.  MatGrdPrrf(@cProdRef)  .And. cProg == "A250"
			M->D3_PARCTOT := " "
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se ja montou a grade de produtos desta OP       Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Len(oGrade:aColsGrade) == 0
				aQtdGrade(.F.)
			EndIf

			If oGrade:Show("D3_PERDA")
				nSoma := oGrade:nQtdInformada
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁVerifica se ha divergencias                                             Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If ( nSoma != &(Readvar()) .And. &(Readvar()) != 0 )
				Help(" ",1,"A410QTDDIF")
			EndIf

			M->D3_PERDA := nSoma
		EndIf
	Else
		_aQtdPerda(cProg)
	EndIf

	If cProg == "A250"
		If !lPerdInf .And. M->D3_QUANT+M->D3_PERDA >= SC2->(C2_QUANT-C2_QUJE-C2_PERDA)
			M->D3_PARCTOT := "T"
		ElseIF !lPerdInf .And. M->D3_QUANT+M->D3_PERDA < SC2->(C2_QUANT-C2_QUJE-C2_PERDA)
			M->D3_PARCTOT := "P"
		Endif
	EndIf

Return .T.

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250CalcD4Ё Autor Ё Marcelo Iuspa         Ё Data Ё 07/06/01 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Calcula D4_QTDEORI arredondado                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ nQtde, nIndice                                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Valor arredondado com base nas decimais do SX3             Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250CalcD4(nQtde, nIndice,cParcTot,nSaldo,lMem)
	Local nRetorno   := 0
	Local nArred     := 8
	Local nQtdMaior  := 0
	Local uRet       := Nil

	DEFAULT nSaldo   := 0
	DEFAULT cParcTot := "P"
	DEFAULT lMem     := .T.

	If Type("l680") == "U"
		Private l680 := .F.
	EndIf

	If Type("l680Auto") == "U"
		Private l680Auto := .F.
	EndIf	

	If Type("l681") == "U"
		Private l681 := .F.
	EndIf

	If Type("l681Auto") == "U"
		Private l681Auto := .F.
	EndIf

	//Ponto de Entrada para alterar a quantidade de casas decimais para arredondamento
	If ExistBlock("MA250DEC")
		nArred := ExecBlock("MA250DEC",.F.,.F.)
		If ValType(nArred) # "N"
			nArred :=8
		EndIf
	EndIf

	nRetorno := Round(nQtde*nIndice,nArred)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁPonto de Entrada para manipular o valor do item.      Ё
	//ЁEh enviado o valor puro sem arredondamento e o valor  Ё
	//Ёde retorno sera definido pelo usuario.                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ExistBlock("MA250VAL")
		uRet := ExecBlock("MA250VAL",.F.,.F., { (nQtde*nIndice) } )
		If ValType(uRet) == "N" // retorno eh numerico
			nRetorno := uRet
		EndIf
	EndIf

	//DMANSMARTSQUAD1-23756 Quando estА incluindo apontamento pelo 680/681 SD3 nЦo estА posicionada.
	If l680 .or. l681 .or. l680Auto .or. l681Auto
		If lMem
			nQtdMaior := M->H6_QTMAIOR
		Else
			nQtdMaior := SH6->H6_QTMAIOR
		EndIf

		If nQtdMaior > 0 .And. nSaldo > 0 
			nRetorno:=nSaldo
		EndIf
	Else 
		nQtdMaior := SD3->D3_QTMAIOR
	EndIf 

	If cParcTot == "T" .And. nSaldo > 0
		If ABS(nSaldo - nRetorno) <= 0.01 .Or. nQtdMaior > 0
			nRetorno:=nSaldo
		EndIf
	EndIf
Return(nRetorno)

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250Indice   Ё Autor Ё Marcelo Iuspa         Ё Data Ё 27/03/02 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Soma quantidade empenhada do SD4 com D4_OPORIG vazio          Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ Utiliza o registro corrente do SC2                            Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Total empenhado                                               Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Indice(cOp)
	Local nPos := aScan(aNeed, {|x| x[6] == cOp})
	Local nRet := If(nPos > 0, aNeed[nPos, 9], 1)
Return(nRet)

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠??╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250CalInd   Ё Autor Ё Marcelo Iuspa         Ё Data Ё 01/04/02 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Calcula indices de baixa nas OPs filhas                       Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ OP                                                            Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Preenche array aNeed PRIVATE                                  Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250CalInd(cOp, nIndice)
	Local aSav     := {}
	Local nDecAnt  :=Set(3,10)
	Local cOpNum   := Pad(cOp, Len(SC2->C2_NUM + SC2->C2_ITEM))
	Local nIndAux  := nIndice
	Local x        := 0

	aEval({"SD4", Alias()}, {|z| Aadd(aSav, {z, ( z )->(IndexOrd()), ( z )->(RecNo())})})
	dbSelectArea("SD4")
	dbSetOrder(2)
	dbSeek(xFilial("SD4") + cOp)
	Do While ! Eof() .And. D4_FILIAL + Substr(D4_OP, 1, Len(cOpNum)) == xFilial("SD4") + cOpNum
		If Empty(SD4->D4_OPORIG)
			dbSkip()
			Loop
		EndIf
		If (nPos := aScan(aNeed, {|x| x[1] == D4_OP .And. x[2] == D4_COD})) == 0
			Aadd(aNeed, {D4_OP, D4_COD, 0, 0, 0, D4_OPORIG,0,0,0})
			nPos := Len(aNeed)
		EndIf
		aNeed[nPos, 4] += D4_QUANT
		aNeed[nPos, 8] += D4_QTDEORI
		dbSkip()
	EndDo

	For x :=1 to Len(aNeed)

		If (nSeek := aScan(aNeed, {|z| z[6] == aNeed[x, 1]})) == 0
			//--Restaura o Indice quando ha mudanca de OP
			nIndice := nIndAux
			nIndice := ((aNeed[x,3] + aNeed[x,4]) * nIndice) - aNeed[x,3]
			nIndice := nIndice / (aNeed[x,3]+aNeed[x,4])
		Else
			nIndice := aNeed[nSeek, 5]
			nIndice := ((aNeed[nSeek,3] + aNeed[nSeek,4]) * nIndice)               // quantidade que preciso do pai
			nIndice := nIndice * ((aNeed[x,3] + aNeed[x,4]) / (aNeed[nSeek,4]))   // quantidade que preciso do filho
			nIndice := nIndice /  (aNeed[x,3] + aNeed[x,4])                        // indice do filho
		EndIf
		aNeed[x,5] := nIndice
		aNeed[x,9] := (aNeed[x,3]+aNeed[x,4]) * nIndice / aNeed[x,4]

	Next

	aEval(aSav, {|z| (dbSelectArea( z[1]), dbSetOrder( z[2] ), MsGoto( z[3] ))})
	Set(3,nDecAnt)
Return NIL

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250EndOk    Ё Autor ЁRodrigo de A. Sartorio Ё Data Ё 25/04/02 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica se pode ser efetuado o encerramento da OP            Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ OP                                                            Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Logico, indica se pode encerrar a OP ou nao                   Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250EndOk()
	Local lExistVld:=ExistBlock('A250ENOK')
	Local lRet:=.T.
	Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
	Local aArea:=GetArea()
	Local aAreaSD3:=SD3->(GetArea())

	Local M->D3_OP      := SD3->D3_OP
	Local M->D3_EMISSAO := SD3->D3_EMISSAO

	//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Integracao com o ACD			 				  Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lIntACD
		lRet:= CBA250ENOK()
		If ValType(lRet) # "L"
			lRet :=.T.
		EndIf
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Template acionando Ponto de Entrada                             Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	ElseIf lRet .And. ExistTemplate('A250ENOK')
		lRet := ExecTemplate('A250ENOK',.F.,.F.)
		If ValType(lRet) # "L"
			lRet :=.T.
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se houveram movimentos posteriores a data de encerramento   Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet
		dbSelectArea("SD3")
		dbSetOrder(1)
		dbSeek(xFilial("SD3")+M->D3_OP)
		While !Eof() .And. xFilial("SD3")+M->D3_OP == SD3->D3_FILIAL+SD3->D3_OP
			If SD3->D3_ESTORNO <> "S" .And. SD3->D3_EMISSAO > M->D3_EMISSAO
				lRet:=Aviso(STR0035,STR0068,{STR0008,STR0007}) == 1
				Exit
			EndIf
			dbSkip()
		End
		RestArea(aAreaSD3)
		RestArea(aArea)
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Executa PONTO DE ENTRADA para validacao    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддды
	If lRet	.and. lExistVld
		lRet:=ExecBlock('A250ENOK',.F.,.F.)
		If ValType(lRet) # "L"
			lRet :=.T.
		EndIf
	EndIf
Return lRet

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250AvalPt   Ё Autor ЁRodrigo de A. Sartorio Ё Data Ё 27/06/02 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica se grava o apontamento como parcial ou total         Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ lProdTot - Indica se a producao deve ser parcial ou total     Ё╠╠
╠╠Ё          Ё nQuant   - Quantidade do Apontamento de producao              Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Caracter , indica se a producao deve ser parcial ou total     Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250AvalPt(lProdTot,nQuant)
	Local cRet:=IF(lProdTot,"T","P")
	If cRet == "T" .And. QtdComp(SC2->C2_QUANT) > (QtdComp(SC2->C2_QUJE)+QtdComp(nQuant))
		cRet:="P"
	EndIf
Return cRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A250Potenc  ЁAutorЁRodrigo de A. SartorioЁ Data Ё 04/07/02 Ё╠╠
╠╠цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Validacao para digitar a potencia e a data de validade do  Ё╠╠
╠╠Ё          Ё Lote corretamente.                                         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ nTipo - 1 - Valida Data de Validade 2 - Valida Potencia    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Mata250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Potenc(nTipo)
	LOCAL lRet      := .T.
	LOCAL cCod		:= aCols[n,Ascan(aHeader,{|x| Trim(x[2])=="D3_COD"})]
	LOCAL cLocal    := aCols[n,Ascan(aHeader,{|x| Trim(x[2])=="D3_LOCAL"})]
	LOCAL cLote     := aCols[n,Ascan(aHeader,{|x| Trim(x[2])=="D3_NUMLOTE"})]
	LOCAL cLoteCtl  := aCols[n,Ascan(aHeader,{|x| Trim(x[2])=="D3_LOTECTL"})]
	LOCAL dDtValid  := If(nTipo == 1,&(ReadVar()),aCols[n,Ascan(aHeader,{|x| Trim(x[2])=="D3_DTVALID"})])
	LOCAL nPotencia := If(nTipo == 1,&(ReadVar()),aCols[n,Ascan(aHeader,{|x| Trim(x[2])=="D3_POTENCI"})])
	LOCAL aAreaSB8  := SB8->(GetArea())
	LOCAL cAlias    := Alias()

	If !Rastro(cCod)
		Help(" ",1,"NAORASTRO")
		lRet:=.F.
	Else
		If nTipo == 2 .And. !PotencLote(cCod)
			Help(" ",1,"NAOCPOTENC")
			lRet:=.F.
		EndIf
		If lRet .And. (!Empty(cLoteCtl) .Or. !Empty(cLote))
			// Verifica a POTENCIA e a DATA DE VALIDADE
			dbSelectArea("SB8")
			dbSetOrder(3)
			If dbSeek(xFilial("SB8")+cCod+cLocal+cLoteCtl+IF(Rastro(cCod,"S"),+cLote,""))
				If nTipo == 1 .And. !Empty(dDtValid) .And. dDtValid # SB8->B8_DTVALID
					HelpAutoma(" ",1,"A240DTVALI")
					&(ReadVar()):=SB8->B8_DTVALID
				EndIf
				If nTipo == 2 .And. nPotencia # SB8->B8_POTENCI
					Help(" ",1,"POTENCORI")
					&(ReadVar()):=SB8->B8_POTENCI
				EndIf
			EndIf
			RestArea(aAreaSB8)
		EndIf
	EndIf
	dbSelectArea(cAlias)
Return lRet

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250VlOrig   Ё Autor ЁRodrigo de A. Sartorio Ё Data Ё 08/07/03 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Avalia situacao da OP origem para verificar se cria SDC       Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cOpOrig - Codigo da OP original                               Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Logico, se .T. deve criar SDC se .F. nao deve criar SDC       Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250VlOrig(cOpOrig)
	Local lRet:=.F.
	Local aAreaSC2:={}

	lProdaut := IIF( lProdaut, .T., fRetPrdAut(cOpOrig) )

	If Empty(SD4->D4_OPORIG) .Or. !lProdAut
		lRet:=.T.
	ElseIf !Empty(SD4->D4_OPORIG)
		aAreaSC2:=SC2->(GetArea())
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+cOpOrig)) .And. QtdComp(SC2->C2_QUJE,.T.) > QtdComp(0,.T.)
			lRet:=.T.
		EndIf
		SC2->(RestArea(aAreaSC2))
	EndIf

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250ERRO  Ё Autor ЁMarcos Daniel N. MunozЁ Data Ё 16/10/03  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Imprime o relatorio de erros gerados por AxInclui.         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250Erro(aErros)   	                                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ aErros - Array contendo os erros.                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/

Static Function A250Erro(aErros)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis tipo Local padrao de todos os relatorios           Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	LOCAL Tamanho  := "P"
	LOCAL titulo   := STR0014 //"Itens Sem Sld / Bloqs. / Empenhos Pendentes"
	LOCAL cDesc1   := STR0062 //"Lista os itens Sem Saldo / Bloqueados / Empenhos Pendentes"
	LOCAL cDesc2   := ""
	LOCAL cDesc3   := ""
	LOCAL cString  := "SC2"
	LOCAL aOrd     := {}
	LOCAL wnrel := "MATA250"

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis privadas ,padrao de todos os relatorios            Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	PRIVATE aReturn := {STR0063, 1,STR0064, 2, 2, 1, "",1 }		//"Zebrado"###"Administracao"
	PRIVATE nLastKey := 0

	wnrel := SetPrint(cString,wnrel,,titulo,cDesc1,cDesc2,cDesc3,.F.,aOrd,.F.,Tamanho,.F.,.F.)

	If !__lAutomacao
		If nLastKey = 27
			dbClearFilter()
		Else
			SetDefault(aReturn,cString)
		EndIf
	

		If nLastKey = 27
			dbClearFilter()
		Else
			RptStatus({|lEnd| A250RelErr(@lEnd,tamanho,wnRel,cString,titulo,aErros)},titulo)
		EndIf
	EndIf

Return NIL

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250RelErrЁ Autor ЁMarcos Daniel N. MunozЁ Data Ё 16/10/03  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Relatorio de erros gerados por AxInclui                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250Erro(aErros)   	                                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ aErros - Array contendo os erros.                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/

Static Function A250RelErr(lEnd,tamanho,wnRel,cString,titulo,aErros)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Variaveis locais especificas deste relatorio                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	LOCAL nCntImpr := 0
	LOCAL cRodaTxt := STR0014 //"Itens Sem Sld / Bloqs. / Empenhos Pendentes"
	LOCAL nTipo    := 0
	LOCAL nErr

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Contadores de linha e pagina                                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	PRIVATE Li := 80, M_PAG := 1

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Monta o cabecalho do relatorio                               Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	//"Produto           Local   Saldo               Ocorr┬ncia"
	// XXXXXXXXXXXXXXX   XX      99,999,999,999.99   XXXXXXXXXXXXXXXXXXXX
	// 0         1         2         3         4         5         6         7
	// 01234567890123456789012345678901234567890123456789012345678901234567890
	Cabec1 := STR0065 //"Produto           Local   Saldo               Ocorrencia"
	Cabec2 := ""

	If !__lAutomacao
		Li := Cabec(titulo,cabec1,cabec2,wnrel,Tamanho,nTipo)
		Li++
	EndIf

	nCntImpr := Len(aErros)

	SetRegua(nCntImpr)

	For nErr := 1 to nCntImpr

		IncRegua()

		If lEnd
			@ PROW()+1,001 PSAY STR0066 //"CANCELADO PELO OPERADOR"
			Exit
		EndIf

		If Li > 80
			Li := Cabec(titulo,cabec1,cabec2,wnrel,Tamanho,nTipo)
			Li++
		EndIf

		@ Li, 000 PSAY aErros[nErr][1]
		@ Li, 018 PSAY aErros[nErr][2]
		@ Li, 026 PSAY aErros[nErr][3]
		@ Li, 046 PSAY aErros[nErr][4]
		Li++

	Next

	@ Li,000 PSay __PrtThinLine()
	Li++
	@ Li,000 PSAY STR0067 + Alltrim(Str(nCntImpr)) //"Total de Itens: "
	Li++
	@ Li,000 PSay __PrtFatLine()

	If !__lAutomacao
		Roda(nCntImpr,cRodaTxt,Tamanho)
	
		If aReturn[5] = 1
			Set Printer To
			dbCommitAll()
			OurSpool(wnRel)
		EndIf
	
		MS_FLUSH()
	EndIf

Return NIL

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250QuJe     Ё Autor ЁMarcelo Iuspa          Ё Data Ё 29/04/04 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna quantidade ja produzida de uma OP                     Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cOp - Numero da OP a ser pesquisada                           Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Numerico - Retorna a quantidade ja produzida da OP informada  Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250QuJe(cOp)
	Local aSavAre := {GetArea(), SC2->(GetArea())}
	Local nQuJe   := 0
	dbSelectArea("SC2")
	dbSetOrder(1)
	dbSeek(xFilial("SC2") + cOp)
	nQuJe := SC2->C2_QUJE
	RestArea(aSavAre[2])
	RestArea(aSavAre[1])
Return(nQuJe)

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A250OpFilha Ё Autor ЁMarcelo Iuspa          Ё Data Ё 03/05/04 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna se OP informada e' filha de outra                     Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cOp - Numero da OP a ser pesquisada                           Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё Logico - Retorna se a OP informada e' filha de outra          Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250OpFilha(cOp)
	Local aSavAre  := {GetArea(), SD4->(GetArea())}
	Local lOpFilha := .F.
	dbSelectArea("SD4")
	dbSetOrder(4)
	lOpFilha := dbSeek(xFilial("SD4") + cOp)
	RestArea(aSavAre[2])
	RestArea(aSavAre[1])
Return(lOpFilha)
/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250OpsPis    Ё Autor ЁMarcelo Iuspa      Ё Data Ё 16/06/04 Ё╠╠
╠╠цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Busca Ops de PIs da OP fornecida (recursiva)               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250OpsPis(cOp, aOps)                                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A250OpsPis(cOp, aOps)
	Local aSavAre := {SD4->(GetArea()), GetArea()}
	Local cSeek   := NIL

	Default aOps  := {cOp}

	dbSelectArea("SD4")
	dbSetOrder(2)

	dbSeek(cSeek := xFilial("SD4") + cOp)
	Do While ! Eof() .And. SD4->(D4_FILIAL+D4_OP) == cSeek
		If ! Empty(SD4->D4_OPORIG)
			Aadd(aOps, SD4->D4_OPORIG)
			aOps := A250OpsPis(SD4->D4_OPORIG, aOps)
		EndIf
		dbSkip()
	EndDo

	RestArea(aSavAre[1])
	RestArea(aSavAre[2])

Return(aOps)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250BLQLOTЁ Autor Ё Marcos Vinicius       Ё Data Ё 09/08/04 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Grava arquivo de trabalho                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250BLQLOT(ExpC1,ExpC2,ExpC3,ExpC4)                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Local                                              Ё╠╠
╠╠Ё          Ё ExpC2 = Produto                                            Ё╠╠
╠╠Ё          Ё ExpC3 = Lote                                               Ё╠╠
╠╠Ё          Ё ExpC4 = Sub-Lote                                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё A250BLQLOT                                                 Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250BLQLOT(cLocal,cProd,cLoteCtl,cNumlote)

	LOCAL cNumSeri, dDtValid
	LOCAL cLocalB8,cNumLoteB8,cLoteCtlB8
	LOCAL bCompara, cDescri, cChaveB8, cChaveDD, cChave
	LOCAL nSaldo, nEmpenho
	LOCAL aBloqueio := {}
	LOCAL cPictQtd14 := PesqPict('SB8', 'B8_SALDO',14)
	LOCAL lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)

	DEFAULT cLoteCtl := ""
	DEFAULT cNumLote := ""

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o Produto utiliza Localizacao Fisica             Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

	If Rastro(cProd)

		DbSelectArea( "SB8" )
		DbSetOrder( 3 )
		cChave := xFilial( "SB8" ) + cProd + cLocal
		DbSeek( cChave )

		ProcRegua(LastRec())

		While !SB8->( Eof() ) .And. cChave == SB8->B8_FILIAL + SB8->B8_PRODUTO + SB8->B8_LOCAL
			If Rastro( cProd, "S" )
				cChaveDD :=  xFilial( "SDD" ) + SB8->B8_PRODUTO + SB8->B8_LOCAL + ;
				SB8->B8_LOTECTL + SB8->B8_NUMLOTE

				bCompara := { ||  SDD->DD_FILIAL + SDD->DD_PRODUTO + SDD->DD_LOCAL+;
				SDD->DD_LOTECTL + SDD->DD_NUMLOTE }

				SB8->( DbSkip() )

			Else

				//здддддддддддддддддддддддддддддддддд©
				//Ё Se utilizar rastreabilidade lote Ё
				//юдддддддддддддддддддддддддддддддддды

				cChaveB8 := xFilial( "SB8" ) + SB8->B8_PRODUTO + SB8->B8_LOCAL + SB8->B8_LOTECTL
				nSaldo   := nEmpenho := 0
				cLocalB8   := SB8->B8_LOCAL
				cLoteCtlB8 := SB8->B8_LOTECTL
				dDtValid := SB8->B8_DTVALID
				cNumLoteB8 := CriaVar( "DD_NUMLOTE" )
				cNumSeri := CriaVar( "DD_NUMSERI" )

				While !SB8->( Eof() ) .And. cChaveB8 == xFilial( "SB8" ) + ;
				SB8->B8_PRODUTO + SB8->B8_LOCAL + SB8->B8_LOTECTL
					nSaldo   += SB8SALDO(,,,,,lEmpPrev,,,.T.)
					nEmpenho += SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)
					SB8->( dbSkip() )
				EndDo
				//aAdd(aBloqueio,{cLocalB8,cLoteCtlB8,cNumLoteB8,Transform( nSaldo - nEmpenho, cPictQtd14 ),STR0073,dDtValid,STR0017})
				cChaveDD := xFilial( "SDD" ) + cProd + cLocalB8 + cLoteCtlB8

				bCompara := { ||  SDD->DD_FILIAL + SDD->DD_PRODUTO + SDD->DD_LOCAL+;
				SDD->DD_LOTECTL }

			EndIf

			//здддддддддддддддддддддддддддддддддд©
			//Ё Pesquisa por bloqueios de lote   Ё
			//юдддддддддддддддддддддддддддддддддды
			SDD->(DbSetOrder(2))
			SDD->(DbSeek( cChaveDD ))

			While !SDD->( Eof() ) .And. cChaveDD == Eval( bCompara )

				If SDD->DD_SALDO <= 0
					SDD->(dbSkip())
					Loop
				EndIf
				cDescri := ""
				SX5->( dbSetOrder( 1 ) )
				If SX5->( dbSeek( xFilial( "SX5" ) + "E1"  + SDD->DD_MOTIVO ) )
					cDescri := X5Descri()
				EndIf
				aAdd(aBloqueio,{SDD->DD_LOCAL,SDD->DD_LOTECTL,SDD->DD_NUMLOTE,Transform( SDD->DD_QUANT, cPictQtd14 ),cDescri,SDD->DD_DTVALID,STR0075} )
				SDD->( dbSkip() )
			EndDo

		EndDo

	EndIF
	If !__lAutomacao
		MaViewSB2(cProd)
	EndIf

	If !Empty(aBloqueio)
		A250ConLot(aBloqueio,cProd)
	EndIf
Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250ConLotЁ Autor Ё Marcos Vinicius       Ё Data Ё09/08/04  Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Mostra Bloqueios do Produto por Lote / Sublote             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpA1 - aBloqueio                                          Ё╠╠
╠╠Ё          Ё ExpC1 - Produto                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250ConLot(aBloqueio,cProd)
	Local oDlg
	Local oFolder1
	Local oLbx1
	Local aAreaAnt:= GetArea()
	Local aFolder1
	Local nX      := 1

	aFolder1 := {STR0015 + ": " + cProd}
	IF !__lAutomacao
		Define MsDialog oDlg Title STR0074 From 0,0 To 17, 77 OF oMainWnd

		oFolder1:=TFolder():New(5,5,aFolder1,{},oDlg,,,, .T., .F.,295,097,)
		If Len(aBloqueio) > 0
			@ 0,0 ListBox oLbx1 Fields HEADER OemToAnsi(STR0072),OemToAnsi(STR0022),OemToAnsi(STR0021),OemToAnsi(STR0020), ;
			OemToAnsi(STR0070),OemToAnsi(STR0071),OemToAnsi(STR0023);
			Size 293.5,080.5 Of oFolder1:aDialogs[nX]
			oLbx1:SetArray(aBloqueio)
			oLbx1:bLine := { ||{aBloqueio[oLbx1:nAT,1],aBloqueio[oLbx1:nAT,2],aBloqueio[oLbx1:nAT,3],aBloqueio[oLbx1:nAT,4],aBloqueio[oLbx1:nAT,7],aBloqueio[oLbx1:nAT,5],aBloqueio[oLbx1:nAT,6]} }
			nX ++
		EndIf

		Define SButton From 110,265 Type 1 Action (oDlg:End())	Enable Of oDlg
		Activate MsDialog oDlg Center
	ENDIF
	RestArea(aAreaAnt)
Return .T.

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250ReqAut    Ё Autor ЁMarcelo Iuspa      Ё Data Ё 05/11/04 Ё╠╠
╠╠цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Manipula parametro MV_REQAUT pelo PE A250REQAUT            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё cReqAut := A250ReqAut(cReqAut)                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250 / MATA680                                          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A250ReqAut(cReqAut)
	Static l250ReqAut
	Local cRetReqAut := cReqAut

	If l250ReqAut == NIL
		l250ReqAut := ExistBlock("A250REQAUT")
	EndIf

	If l250ReqAut
		If ! (ValType(cRetReqAut := ExecBlock("A250REQAUT", .F., .F., {cReqAut})) == "C" .And. cRetReqAut $ "AD")
			cRetReqAut := cReqAut
		EndIf
	EndIf

	If (Type('l250Auto') == 'L') .And. l250Auto .And. aScan(aRotAuto,{|x| x[1] == "REQAUT" .And. x[2] == "N"}) > 0
		cRetReqAut := "D"
	EndIf

Return(cRetReqAut)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250DevAut    Ё Autor ЁErike Yuri da SilvaЁ Data Ё 12/04/06 Ё╠╠
╠╠цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Manipula parametro MV_DEVAUT pelo PE A250DEVAUT            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё cReqAut := A250DevAut(cDevAut)                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250 / MATA680                                          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A250DevAut(cDevAut)
	Static l250DevAut
	Local cRetDevAut := cDevAut

	If l250DevAut == NIL
		l250DevAut := ExistBlock("A250DEVAUT")
	EndIf

	If l250DevAut
		If ! (ValType(cRetDevAut := ExecBlock("A250DEVAUT", .F., .F., {cDevAut})) == "C" .And. cRetDevAut $ "AD")
			cRetDevAut := cDevAut
		EndIf
	EndIf

Return(cRetDevAut)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250PmsReqЁ Autor ЁEdson Maricate         Ё Data Ё 18/11/04 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁGera as RequisiГУes para o projeto no apontamento da produc.Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   ЁA250PmsReq                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      ЁMATA250                                                     Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A250PmsReq(cNumOP,nOpcx)
	Local aArea	     := GetArea()
	Local aAreaSB1	 := SB1->(GetArea())
	Local aAreaSC2	 := SC2->(GetArea())
	Local aAreaSD3	 := SD3->(GetArea())
	Local bCampo 	 := {|nCPO| Field(nCPO) }
	Local bCampoGet	 := {|nCPO| FieldGet(nCPO) }
	Local aDadProd	 :=	{}
	Local nX         := 0
	Local aReq       := {}
	Local nReqSD3    := 0
	Local nQtdSD3    := 0
	Local nBaixa     := 0
	Local lGeraSD3   := .T.
	Local nAFMQtdAtu := 0
	Local nTamD3_COD := 0
	Local aAreaBKD3  := {}
	Local cD3Cod 	 := ""	

	If !__lAutomacao
		cD3Cod   := M->D3_COD
	EndIf

	SB1->(dbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1")+cD3Cod))

	SC2->(dbSetOrder(1))
	SC2->(MsSeek(xFilial("SC2")+cNumOP))

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁFaz a requisiГЦo da produГЦo para o projeto           Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
	dbSelectArea("AFM")
	dbSetOrder(2)
	If MsSeek(xFilial("AFM")+cNumOP)

		If nOpcx == 1 // Apontamento de ProduГЦo

			//здддддддддддддддддддддддддддддддддддддддддд©
			//Ё Gera requisicao ao projeto               Ё
			//юдддддддддддддддддддддддддддддддддддддддддды
			For nX := 1 To SD3->(fCount())
				aAdd(aDadProd,SD3->(Eval(bCampoGet,nX)))
			Next nX

			nQtdSD3 := aDadProd[SD3->(FieldPos("D3_QUANT"))]
			nBaixa  := 0
			lGeraSD3 := .T.

			//nSD3Recno := SD3->(Recno())
			//nSD3Index := SD3->(dbSetOrder())

			aAreaBKD3 := SD3->(GetArea())

			nTamD3_COD := TamSX3("AFM_NUMOP")[1]+TamSX3("AFM_ITEMOP")[1]+TamSX3("AFM_SEQOP")[1]

			SD3->(dbSetOrder(1))
			SD3->(dbSeek(xFilial("SD3")+cNumOP))
			While SD3->(!eof()) .and. SD3->D3_FILIAL+Left(SD3->D3_OP,nTamD3_COD) == ;
			xFilial("SD3")+AFM->AFM_NUMOP+AFM->AFM_ITEMOP+AFM->AFM_SEQOP

				If SD3->D3_CF == "RE1" .AND. !Empty(SD3->D3_PROJPMS) .AND. !Empty(SD3->D3_TASKPMS)
					nPosPMS := aScan( aReq ,{|xCampo| xCampo[1] == SD3->D3_PROJPMS+SD3->D3_TASKPMS } )
					If nPosPMS > 0
						aReq[nPosPMS][2] += SD3->D3_QUANT
					Else
						aAdd( aReq ,{SD3->D3_PROJPMS+SD3->D3_TASKPMS ,SD3->D3_QUANT} )
					EndIf
				EndIf
				SD3->(dbSkip())
			EndDo

			//SD3->(dbSetOrder(nSD3Index))
			//SD3->(MsGoTo(nSD3Recno))

			RestArea(aAreaBKD3)

			While AFM->(!Eof()) .And. xFilial("AFM")+cNumOP==;
			AFM->AFM_FILIAL+AFM->AFM_NUMOP+AFM->AFM_ITEMOP+AFM->AFM_SEQOP

				If AFM->AFM_REVISA == PmsAF8Ver(AFM->AFM_PROJET)

					nPosPMS := aScan( aReq ,{|xCampo| xCampo[1] == AFM->AFM_PROJET+AFM->AFM_TAREFA } )
					If nPosPMS > 0
						nAFMQtdAtu := AFM->AFM_QUANT -aReq[nPosPMS][2]
						If nAFMQtdAtu < 0
							nAFMQtdAtu := 0
						EndIf
					Else
						nAFMQtdAtu := AFM->AFM_QUANT
					EndIf

					// se o empenhado ou produzido for zerado, nao gera movimento
					If nAFMQtdAtu == 0 .OR. nQtdSD3 == 0
						lGeraSD3 := .F.
					Else
						// se o o produzido for maior q o empenhado, baixa o empenhado
						If nQtdSD3 > nAFMQtdAtu
							nBaixa   := nAFMQtdAtu
							nQtdSD3  := nQtdSD3-nAFMQtdAtu
							lGeraSD3 := .T.
							// se o empenhado for maior q o produzido , baixa o produzido
						ElseIf nQtdSD3 <= nAFMQtdAtu
							nBaixa  := nQtdSD3
							nQtdSD3 := 0
							lGeraSD3 := .T.
						Else
							lGeraSD3 := .F.
						EndIf
					EndIf
					If lGeraSD3
						RecLock("SD3",.T.)
						SD3->D3_FILIAL	:= xFilial("SD3")
						SD3->D3_COD		:= aDadProd[FieldPos("D3_COD")]
						SD3->D3_QUANT	:= nBaixa
						SD3->D3_TM		:= "999"
						SD3->D3_LOCAL	:= SC2->C2_LOCAL
						SD3->D3_CC      := SC2->C2_CC
						SD3->D3_CLVL    := SC2->C2_CLVL
						SD3->D3_ITEMCTA := SC2->C2_ITEMCTA
						SD3->D3_DOC		:= aDadProd[FieldPos("D3_DOC")]
						SD3->D3_EMISSAO := aDadProd[FieldPos("D3_EMISSAO")]
						SD3->D3_UM		:= aDadProd[FieldPos("D3_UM")]
						SD3->D3_CONTA	:= SB1->B1_CONTA
						SD3->D3_GRUPO	:= SB1->B1_GRUPO
						SD3->D3_TIPO	:= SB1->B1_TIPO
						SD3->D3_SEGUM	:= SC2->C2_SEGUM
						SD3->D3_CF		:= "RE1"
						SD3->D3_QTSEGUM	:= SC2->C2_QTSEGUM
						SD3->D3_USUARIO	:= CUSERNAME
						SD3->D3_CUSTO1	:= aDadProd[FieldPos("D3_CUSTO1")]*(AFM->AFM_QUANT/nBaixa)
						SD3->D3_CUSTO2	:= aDadProd[FieldPos("D3_CUSTO2")]*(AFM->AFM_QUANT/nBaixa)
						SD3->D3_CUSTO3	:= aDadProd[FieldPos("D3_CUSTO3")]*(AFM->AFM_QUANT/nBaixa)
						SD3->D3_CUSTO4	:= aDadProd[FieldPos("D3_CUSTO4")]*(AFM->AFM_QUANT/nBaixa)
						SD3->D3_CUSTO5	:= aDadProd[FieldPos("D3_CUSTO5")]*(AFM->AFM_QUANT/nBaixa)
						SD3->D3_NUMLOTE	:= aDadProd[FieldPos("D3_NUMLOTE")]
						SD3->D3_LOTECTL	:= aDadProd[FieldPos("D3_LOTECTL")]
						SD3->D3_DTVALID	:= aDadProd[FieldPos("D3_DTVALID")]
						SD3->D3_PROJPMS	:= AFM->AFM_PROJET
						SD3->D3_TASKPMS	:= AFM->AFM_TAREFA
						SD3->D3_TRT     := AFM->AFM_TRT
						SD3->D3_NUMSEQ  := ProxNum()
						MsUnlock()
						B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
						PmsWriteRQ(1,"SD3",{SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
					EndIf
				EndIf
				dbSelectARea("AFM")
				dbSkip()
			EndDo

			//Estorno de apontamento
		Else
			While !Eof() .And. xFilial("AFM")+cNumOP==;
			AFM_FILIAL+AFM_NUMOP+AFM_ITEMOP+AFM_SEQOP

				If AFM->AFM_REVISA == PmsAF8Ver(AFM->AFM_PROJET)
					//Achar as requisicoes
					DbSelectArea('SD3')
					DbSetOrder(9)
					cChave	:=	xFilial("SD3")+D3_DOC+Space(Len(D3_ITEM))+"RE1"
					DbSeek(cChave)
					While !Eof() .And. cChave == D3_FILIAL+D3_DOC+D3_ITEM+D3_CF
						If !Empty(D3_PROJPMS)
							//Estornar AFI
							PmsWriteRQ(2,"SD3",{SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
							dbSelectArea("SD3")
							RecLock("SD3",.F.)
							Replace D3_ESTORNO With "S"
							MsUnLock()
							//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Salva a integridade dos campos de Bancos de Dados            Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							For nX := 1 To FCount()
								M->&(EVAL(bCampo,nX)) := FieldGet(nX)
							Next nX

							//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Cria o registro de estorno com mesmos dados do original      Ё
							//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							RecLock("SD3",.T.)
							For nX := 1 TO FCount()
								FieldPut(nX,M->&(EVAL(bCampo,nX)))
							Next nX
							Replace D3_TM 		 With "499"
							Replace D3_CF 		 With "DE0"
							Replace D3_USUARIO With CUSERNAME
							Replace D3_CHAVE 	 With "0"
							If SD3->(FieldPos("D3_PERBLK")) > 0
								Replace D3_PERBLK With PADR(Nil,tamSX3('D3_PERBLK')[1])
							EndIf
							MsUnLock()
							//Estornar Requisicao
							B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
						EndIf
						DbSelectArea('SD3')
						DbSkip()
					EndDo
				EndIf
				dbSelectARea("AFM")
				dbSkip()
			EndDo
		EndIf
	EndIf

	RestArea(aAreaSD3)
	RestArea(aAreaSC2)
	RestArea(aAreaSB1)
	RestArea(aArea)
Return .T.

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁA250LDepOp╨Autor  ЁErike Yuri da Silva ╨ Data Ё  12/05/05   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     ЁFuncao recursiva que lista as ops dependentes a op Pai.     ╨╠╠
╠╠╨          ЁO retorno pode ser por referencia ou por atribuicao.        ╨╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 - Op                                                 Ё╠╠
╠╠Ё          Ё ExpA1 - Array com Lista das ops dependentes                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠╨Uso       Ё Mata250                                                    ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250LDepOp(cOpPai,aListaOri)
	Local nRecSD4     := 0
	Default aListaOri := {}
	DbSelectArea("SD4")
	DbSetOrder(2)
	SD4->(DbSeek(xFilial("SD4")+cOpPai))
	While SD4->(!Eof() .AND. D4_FILIAL+D4_OP==xFilial("SD4")+cOpPai)
		If Empty(SD4->D4_OPORIG)
			SD4->(DbSkip())
			Loop
		EndIf
		Aadd(aListaOri,SD4->D4_OPORIG)
		nRecSD4:= SD4->(Recno())
		A250LDepOp(SD4->D4_OPORIG,aListaOri)
		SD4->(MsGoto(nRecSD4))
		SD4->(DbSkip())
	EndDo
Return aClone(aListaOri)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250EstSBC Ё Autor ЁErike Yuri da Silva   Ё Data Ё 08/07/05 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Funcao que estorna a perda por op caso existe para este    Ё╠╠
╠╠Ё			 Ё apontamento.                                               Ё╠╠
╠╠Ё			 Ё Origem de solicitacao: BOPs 00000083121                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250EstSBC(cOp,cNumSeq)
	Local aArea := {GetArea(), SD3->(GetArea())}

	If SuperGetMv("MV_DIGIPER")== "S"
		EstornaSBC(cOp,cNumSeq)
	EndIf

	RestArea(aArea[2])
	RestArea(aArea[1])
Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁQtdReqPMS  Ё Autor ЁBruno Sobieski        Ё Data Ё 09/08/05 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica a quantidade de material que foi requisitado auto-Ё╠╠
╠╠Ё			 Ё maticamente quando a OP foi encerrada.                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function QtdReqPMS()
	Local aAreaSD3	:=	SD3->(GetArea())
	Local nQtdReq	:=	0
	Local cChave
	//Achar as requisicoes
	DbSelectArea('SD3')
	DbSetOrder(9)
	cChave	:=	xFilial("SD3")+D3_DOC+Space(Len(D3_ITEM))+"RE1"
	DbSeek(cChave)
	While !Eof() .And. cChave == D3_FILIAL+D3_DOC+D3_ITEM+D3_CF
		If !Empty(D3_PROJPMS)
			nQtdReq	+=	D3_QUANT
		EndIf
		DbSkip()
	EndDo
	RestArea(aAreaSD3)
Return nQtdReq

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250BloqPROЁ Autor ЁMarcos V. Ferreira    Ё Data Ё 29/09/05 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica se os produtos empenhados para producao estao     Ё╠╠
╠╠Ё			 Ё bloqueados para uso B1_MSBLQL == 1						  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250        	                                          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250BloqPR0(cOP)
	Local aAreaAnt	:= GetArea()
	Local lRet		:= .F.
	Local cQuery    := ''
	Local cAliasTmp  := GetNextAlias()

	Default cOp		:= ''

	If !Empty( cOP )

		cQuery := " SELECT SB1.B1_COD " +;
					"FROM " + RetSqlName("SD4") + " SD4 " +;
					"	JOIN " + RetSqlName("SB1") + " SB1 " +;
					"	 ON SB1.B1_FILIAL = '" + xFilial("SB1") + "'" +;
					"	AND SB1.B1_COD = SD4.D4_COD " +;
					"	AND substring(SB1.B1_COD,1,3) <> 'MOD' " +;
					"	AND SB1.B1_CCCUSTO = '' " +;
					"WHERE SD4.D4_FILIAL  = '" + xFilial('SD4') + "'" +;
					"  AND SD4.D4_OP      = '" + cOp + "' " +;
					"  AND SD4.D4_QUANT   > 0 " +;
					"  AND SB1.B1_MSBLQL  = '1' " +;
					"  AND SB1.D_E_L_E_T_ = ' ' " +;
					"  AND SD4.D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)
		While !(cAliasTmp)->(Eof())
			Aviso("A650BLOQ",STR0076+AllTrim((cAliasTmp)->B1_COD)+STR0077,{STR0007})   //Produto bloqueado
			lRet := .T.
			Return lRet
		EndDo
		(cAliasTmp)->(dbCloseArea())

	Endif

	RestArea(aAreaAnt)
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA250Assoc  Ё Autor ЁRodrigo de A Sartorio Ё Data Ё 18/01/06 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Associa os lotes utilizados nos apontamentos de producao   Ё╠╠
╠╠Ё			 Ё aos lotes produzidos                 			          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250        	                                          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250Assoc(cAlias,nReg,nOpc)
	// Variaveis utilizadas para posicionamento dos objetos
	Local aObjects :={},aPosObj  :={}
	Local aSize    :=MsAdvSize()
	Local aInfo    :={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
	Local nOpca    := 0
	Local nx       := 0
	Local aListaSD5:={}
	Local aArea    :=GetArea()
	//Local aAreaSD3 :=GetArea()
	Local lContinua:= .T.
	// Variaveis utilizadas na selecao de registros
	Local oChkQual,lQual,oQual,cVarQ
	// Carrega bitmaps
	Local oOk       := LoadBitmap( GetResources(), "LBOK")
	Local oNo       := LoadBitmap( GetResources(), "LBNO")
	// Selecao para filtro
	Local aOpcFiltro:={1}

	// Valida se trata-se de um movimento de producao
	If Subs(D3_CF,1,2) != "PR"
		Help(" ",1,"A250NAO")
		lContinua := .F.
	ElseIf D3_ESTORNO == "S"
		Help(" ",1,"A250ESTORN")
		lContinua := .F.
	ElseIf Empty(D3_LOTECTL+D3_NUMLOTE)
		Help(" ",1,"NAORASTRO")
		lContinua := .F.
	EndIf

	// Seleciona parametrizacao ao usuario
	If lContinua .And. ParamBox({	{3,STR0080,aOpcFiltro[1],{STR0081,STR0082,STR0083},60,,.T.}},STR0084,aOpcFiltro,,,.T.,120,3) //"Apresenta itens :"###"Sem lote associado"###"Com lote associado"###"Todos"###"Selecao de registros"

		// Array com objetos utilizados
		AADD(aObjects,{100,095,.T.,.F.,.F.})
		AADD(aObjects,{100,100,.T.,.T.,.F.})
		aPosObj:=MsObjSize(aInfo,aObjects)

		// Monta lista de registros
		//SD3->(dbSelectArea("SD3"))
		//SD3->(dbSetOrder(4))
		//SD3->(dbGoTo(nReg))
		SD5->(dbSelectArea("SD5"))
		SD5->(dbSetOrder(4))
		SD5->(dbSeek(xFilial("SD5")+SD3->D3_OP))
		While SD5->(!EOF()) .And. SD5->(D5_FILIAL+D5_OP) == xFilial("SD5")+SD3->D3_OP
			// Checa registros validos para a lista
			If SD5->D5_ESTORNO == "S" .Or. Substr(AC040TM(SD5->D5_NUMSEQ,SD5->D5_ORIGLAN),1,1) # "R" .Or. If(aOpcFiltro[1] == 1,!Empty(SD5->(D5_LOTEPRD+D5_SLOTEPR)),If(aOpcFiltro[1] == 2,Empty(SD5->(D5_LOTEPRD+D5_SLOTEPR)),.F.))
				SD5->(dbSkip())
				Loop
			EndIf
			// Adiciona registros na lista
			AADD(aListaSD5,{.F.,SD5->D5_PRODUTO,SD5->D5_DATA,SD5->D5_LOTECTL,If(Rastro(SD5->D5_PRODUTO,"S"),SD5->D5_NUMLOTE,""),SD5->D5_QUANT,SD5->D5_DOC,SerieNfId("SD5",2,"D5_SERIE"),SD5->D5_NUMSEQ,SD5->D5_OP,SD5->D5_LOTEPRD,SD5->D5_SLOTEPR,SD5->(Recno())})
			SD5->(dbSkip())
		End
		// Restaura area original do SD3
		//SD3->(RestArea(aAreaSD3))

		// Mostra interface para
		If Len(aListaSD5) > 0
			DEFINE MSDIALOG oDlg TITLE cCadastro OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5]
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Muda o valor do aRotina para so visualizar enchoice.         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			EnChoice(cAlias,nReg,nOpc,,,,,{aPosObj[1,1],aPosObj[1,2],aPosObj[1,3],aPosObj[1,4]})
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Monta tela para selecao dos registros                        Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			@ aPosObj[2,1],aPosObj[2,2] TO aPosObj[2,3],aPosObj[2,4] LABEL STR0085 OF oDlg  PIXEL //"Selecione as requisicoes que devem ser associadas ao lote produzido."
			@ aPosObj[2,1]+10,aPosObj[2,2]+5 CHECKBOX oChkQual VAR lQual PROMPT STR0086 SIZE 50, 10 OF oDlg PIXEL ON CLICK (AEval(aListaSD5, {|z| z[1] := If(z[1]==.T.,.F.,.T.)}), oQual:Refresh(.F.)) //"Inverte Selecao"
			@ aPosObj[2,1]+25,aPosObj[2,2]+5 LISTBOX oQual VAR cVarQ Fields HEADER "",RetTitle("D5_PRODUTO"),RetTitle("D5_DATA"),RetTitle("D5_LOTECTL"),RetTitle("D5_NUMLOTE"),RetTitle("D5_QUANT"),RetTitle("D5_DOC"),SerieNfId("SD5",7,"D5_SERIE"),RetTitle("D5_NUMSEQ"),RetTitle("D5_OP"),RetTitle("D5_LOTEPRD"),RetTitle("D5_SLOTEPR") SIZE (aPosObj[2,4]-aPosObj[2,2])-15,(aPosObj[2,3]-aPosObj[2,1])-30 ON DBLCLICK (aListaSD5:=CA250Troca(oQual:nAt,aListaSD5),oQual:Refresh()) SCROLL OF oDlg PIXEL
			oQual:SetArray(aListaSD5)
			oQual:bLine := { || {If(aListaSD5[oQual:nAt,1],oOk,oNo),aListaSD5[oQual:nAt,2],aListaSD5[oQual:nAt,3],aListaSD5[oQual:nAt,4],aListaSD5[oQual:nAt,5],aListaSD5[oQual:nAt,6],aListaSD5[oQual:nAt,7],aListaSD5[oQual:nAt,8],aListaSD5[oQual:nAt,9],aListaSD5[oQual:nAt,10],aListaSD5[oQual:nAt,11],aListaSD5[oQual:nAt,12]}}
			oQual:Refresh()
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,oDlg:End()},{||oDlg:End()})

			// Grava lote / sublote nos registros selecionados
			If nOpca == 1
				// Ordena pelos registros
				ASORT(aListaSD5,,,{ |x,y| x[13] < y[13]})
				// Varre lista de registros
				For nx:=1 to Len(aListaSD5)
					If aListaSD5[nx,1]
						// Se estiver marcado grava lote produzido
						SD5->(MsGoto(aListaSD5[nx,13]))
						Reclock("SD5",.F.)
						Replace D5_LOTEPRD With SD3->D3_LOTECTL
						Replace D5_SLOTEPR With SD3->D3_NUMLOTE
						MsUnlock()
					EndIf
				Next nx
			EndIf
		Else
			Help(" ",1,"RECNO")
		EndIf
	EndIf
RETURN

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠здддддддддддбдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©╠╠
╠╠Ё Fun┤┘o    Ё CA250Troca                                                 Ё╠╠
╠╠цдддддддддддеддддддддддддддддддддддддддддддддддддддддддбддддддбдддддддддд╢╠╠
╠╠Ё Autor     Ё Rodrigo de Almeida Sartorio              Ё Data Ё 18/01/06 Ё╠╠
╠╠цдддддддддддеддддддддддддддддддддддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠Ё Descri┤┘o Ё Troca marcador entre x e branco                            Ё╠╠
╠╠цдддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametros ЁnIt        Linha onde o click do mouse ocorreu              Ё╠╠
╠╠Ё           ЁaArray     Array com as opcoes para selecao                 Ё╠╠
╠╠цдддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё  Uso      Ё MATA250                                                    Ё╠╠
╠╠юдддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function CA250Troca(nIt,aArray)
	aArray[nIt,1] := !aArray[nIt,1]
Return aArray

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠здддддддддддбдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©╠╠
╠╠Ё Fun┤┘o    Ё A250EmpNeg                                                 Ё╠╠
╠╠цдддддддддддеддддддддддддддддддддддддддддддддддддддддддбддддддбдддддддддд╢╠╠
╠╠Ё Autor     Ё Erike Yuri da Silva                      Ё Data Ё 11/04/06 Ё╠╠
╠╠цдддддддддддеддддддддддддддддддддддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠Ё Descri┤┘o Ё Informa se um produto de uma op possui empenho negativo    Ё╠╠
╠╠цдддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametros ЁcProduto   Codigo do produto 							   Ё╠╠
╠╠Ё           ЁcLocal     Codigo do armazem                                Ё╠╠
╠╠Ё           ЁcOP        Codigo da Ordem de Producao                      Ё╠╠
╠╠цдддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё  Uso      Ё MATA250 / MATA680                                          Ё╠╠
╠╠юдддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250EmpNeg(cProduto,cLocal,cOp)
	Local cAlias	:= Alias()
	Local lRet		:= .F.
	Local aSD4		:= SD4->(GetArea())
	Default cProduto:= Space(15)
	Default cOp		:= Space(13)
	Default cLocal	:= Space(2)

	DbSelectArea("SD4")
	DbSetOrder(2)
	lRet := SD4->(DbSeek(xFilial("SC2")+cOp+cProduto+cLocal)) .And. (SD4->D4_QTDEORI <  0)
	SD4->(RestArea(aSD4))
	DbSelectArea(cAlias)
Return lRet

//------------------------- FUNCOES ANTIGAS PARA MANTER LEGADO DA GRADE DE PRODUTOS ANTIGA -------------------

//----------------------------------------------------------------------
// FUNCAO UTILIZADA SOMENTE PARA MANTER LEGADO DA UTILIZACAO DE GRADE
// DE PRODUTOS SEM OBJETO ATE LANCAMENTO DO R4.
//
// ATENCAO: Foi incluido um "_" na inicio do nome da funcao
//----------------------------------------------------------------------
Static Function _A250ShowOp()
	Local oDlg, nOAT
	Local nHdl  := GetFocus()
	Local nOpt1 :=0
	Local aArray:={}
	Local cAlias:=Alias()
	Local nOrder:=IndexOrd()
	Local nRecno:=Recno()
	Local cPicture:=PesqPictQt("C2_QUANT",16)
	Local nOrdSC2 :=SC2->(IndexOrd())
	Local cMascara	 := GetMv("MV_MASCGRD")
	Local nTamRef	 := Val(Substr(cMascara,1,2))
	Local cProdRef:= If(MatGrdPrrf(M->D3_COD),Substr(M->D3_COD,1,nTamRef),M->D3_COD)

	//здддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o produto e' referencia (Grade)Ё
	//юдддддддддддддддддддддддддддддддддддддддддддды
	If MatGrdPrrf(M->D3_COD)
		nTamRef	 := Val(Substr(cMascara,1,2))
		cProdRef    := Substr(M->D3_COD,1,nTamRef)
	Else
		nTamRef	 := Len(SC2->C2_PRODUTO)
		cProdRef    := M->D3_COD
	EndIf

	dbSelectArea("SC2")
	dbSetOrder(2)
	If !__lAutomacao
		If dbSeek(xFilial("SC2")+cProdRef)
			While !Eof() .And. C2_FILIAL+Substr(C2_PRODUTO,1, nTamRef) == xFilial("SC2")+cProdRef
				If Empty(C2_DATRF) .And. C2_TPOP # "P"
					AADD(aArray,{C2_NUM,C2_ITEM,C2_SEQUEN,C2_PRODUTO,DTOC(C2_DATPRI),DTOC(C2_DATPRF),Transform(aSC2Sld(),cPicture),C2_ITEMGRD})
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf

	If !Empty(aArray)
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0025) From 09,0 To 18,50 OF oMainWnd     //"OPs deste Produto"
		@ 0.5,  0 TO 4, 20.0 OF oDlg
		If __lPyme
			@ 1,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0026),OemToAnsi(STR0027),OemToAnsi(STR0028),OemToAnsi(STR0015),OemToAnsi(STR0045),OemToAnsi(STR0046),OemToAnsi(STR0017)  SIZE 150,35 ON DBLCLICK (nOpt1 := 1,oDlg:End())   //"Nёmero"###"Item"###"Sequ┬ncia"###"Produto"###"Dt. Prev. Inicio"###"Dt. Prev. Fim"###"Saldo"###"It. Grade"
			oQual:SetArray(aArray)
			oQual:bLine := { || {aArray[oQual:nAT][1],aArray[oQual:nAT][2],aArray[oQual:nAT][3],aArray[oQual:nAT][4],aArray[oQual:nAT][5],aArray[oQual:nAT][6],aArray[oQual:nAT][7]}}
		Else
			@ 1,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0026),OemToAnsi(STR0027),OemToAnsi(STR0028),OemToAnsi(STR0015),OemToAnsi(STR0045),OemToAnsi(STR0046),OemToAnsi(STR0017),OemToAnsi(STR0049)  SIZE 150,35 ON DBLCLICK (nOpt1 := 1,oDlg:End())   //"Nёmero"###"Item"###"Sequ┬ncia"###"Produto"###"Dt. Prev. Inicio"###"Dt. Prev. Fim"###"Saldo"###"It. Grade"
			oQual:SetArray(aArray)
			oQual:bLine := { || {aArray[oQual:nAT][1],aArray[oQual:nAT][2],aArray[oQual:nAT][3],aArray[oQual:nAT][4],aArray[oQual:nAT][5],aArray[oQual:nAT][6],aArray[oQual:nAT][7],aArray[oQual:nAT][8]}}
		EndIf
		DEFINE SBUTTON FROM 10  ,166  TYPE 1 ACTION (nOpt1 := 1,oDlg:End()) ENABLE OF oDlg
		DEFINE SBUTTON FROM 22.5,166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
		ACTIVATE MSDIALOG oDlg VALID (nOAT := oQual:nAT, .T.)
		If nOpt1 == 1
			M->D3_OP :=aArray[nOAT][1]+aArray[nOAT][2]+aArray[nOAT][3]+aArray[nOAT][8]
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "D3_OP" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->D3_OP
			EndIf
		EndIf
		SetFocus(nHdl)
	Else
		HELP(" ",1,"A250NAOOP")
	EndIf
	dbSelectArea(cAlias)
	dbSetOrder(nOrder)
	MsGoTo(nRecno)
	SC2->(dbSetOrder(nOrdSC2))
	CheckSx3("D3_OP")
Return NIL

//----------------------------------------------------------------------
// FUNCAO UTILIZADA SOMENTE PARA MANTER LEGADO DA UTILIZACAO DE GRADE
// DE PRODUTOS SEM OBJETO ATE LANCAMENTO DO R4.
//
// ATENCAO: Foi incluido um "_" na inicio do nome da funcao
//----------------------------------------------------------------------
Function _a250Insere(cCampoQtd,lFirst)

	Local nLinha, nColuna
	Local cMascara	:= GetMv("MV_MASCGRD")
	Local nTamRef	:= Val(Substr(cMascara,1,2))
	Local nTamLin   := Val(Substr(cMascara,4,2))
	Local nTamCol   := Val(Substr(cMascara,7,2))
	Local lAchou    := .F.
	Local nQtd, nQuje, nPerda := 0
	Local nColQtd   := 1
	Local nColQtd2  := 5
	Local nAux      := 1
	Local nQuant    := 0

	dbSelectArea("SC2")
	aAreaSC2 := GetArea()
	dbSeek(xFilial("SC2")+Alltrim(M->D3_OP))
	cNumOp := SC2->C2_NUM
	Do While !Eof() .And. C2_FILIAL+C2_NUM == xFilial("SC2")+cNumOp
		If SC2->C2_GRADE !="S"
			dbSkip()
			Loop
		EndIf
		For nLinha :=  1 To Len(aColsGrade[nAux])
			For nColuna := 2 To Len(aHeader)
				lAchou := .F.
				nPosLin := ASCAN(aCols[nLinha], Substr(SC2->C2_PRODUTO,nTamRef+1,nTamLin))
				nPosCol := ASCAN(aHeadGrade[nAux][nColuna], Substr(SC2->C2_PRODUTO,nTamRef+nTamLin+1,nTamCol))

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//ЁAlimenta a Coluna de Quantidade, com o valor da Qtde `a produzir        Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If nPosLin > 0 .And. nPosCol > 0 .And. SC2->C2_GRADE =="S" .And. Empty(SC2->C2_DATRF)
					lAchou := .T.
					nQtd  := If(cCampoQtd == "M->D3_QTSEGUM" .and. lFirst,ConvUm(SC2->C2_PRODUTO, SC2->C2_QUANT,SC2->C2_QTSEGUM,2), 0)
					nQuje := If(cCampoQtd == "M->D3_QTSEGUM" .and. lFirst,ConvUm(SC2->C2_PRODUTO, SC2->C2_QUJE ,0,2), 0)
					nPerda:= If(cCampoQtd == "M->D3_QTSEGUM" .and. lFirst,ConvUm(SC2->C2_PRODUTO, SC2->C2_PERDA,0,2), 0)

					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//ЁNao inserir na Grade Quantidades Negativas             Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If nQtd-nQuje-nPerda >= 0
						aColsGrade[nAux][nLinha][nColuna][nColQtd2] :=If(aColsGrade[nAux][nLinha][nColuna][nColQtd2]==0,nQtd-nQuje-nPerda,aColsGrade[nAux][nLinha][nColuna][nColQtd2])
					EndIf

					If lFirst
						nQuant := SC2->C2_QUANT-SC2->C2_QUJE-If(lPerdInf,0,SC2->C2_PERDA)
						aColsGrade[nAux][nLinha][nColuna][nColQtd] := If(nQuant >0, nQuant, 0)
						aCols[nLinha][nColuna] := If(cCampoQtd == "M->D3_QTSEGUM" ,aColsGrade[nAux][nLinha][nColuna][nColQtd2],aColsGrade[nAux][nLinha][nColuna][nColQtd])
					EndIf
				EndIf
			Next nColuna
		Next nLinha
		SC2->(dbSkip())
	EndDo
	RestArea(aAreaSC2)
Return .T.

//----------------------------------------------------------------------
// FUNCAO UTILIZADA SOMENTE PARA MANTER LEGADO DA UTILIZACAO DE GRADE
// DE PRODUTOS SEM OBJETO ATE LANCAMENTO DO R4.
//
// ATENCAO: Foi incluido um "_" na inicio do nome da funcao
//----------------------------------------------------------------------
Function _aParcTot(cProg, lMostra)
	Local lRet	:= .T.
	Local nLinha, nColuna, nOpcA := 0
	Local cProdRef := M->D3_COD
	Local lGrade   := GetMv("MV_GRADE")
	Local aAltGr   := {}
	Local aBackRot := aClone(aRotina)
	Local cParcTot := " "
	Local aColsCop := {}
	Local nAux     := 1
	Local aAreaSC2 := SC2->(GetArea())
	Local cMascara := GetMv("MV_MASCGRD")
	Local nTamRef  := Val(Substr(cMascara,1,2))
	Local nCntFor  := 0

	cProg    := If(cProg == NIL, '', cProg)
	lMostra  := If(lMostra == NIL, .T., lMostra)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Muda o valor do aRotina para nao incluir linha na GetDados   Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	aRotina[3,4] := 6

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se a grade esta ativa                       Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ( lGrade ) .And.  MatGrdPrrf(@cProdRef) .And. cProg == "A250"
		M->D3_PARCTOT := " "
		If !Empty(M->D3_OP)
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se ja montou a grade de produtos desta OP           Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aColsCop := AClone(aCols)
			If Len(acols) == 0
				aQtdGrade(.F.)
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁMonta aHeader e aCols                                                   Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aHeader	:= Aclone(aHeadGrade[1])
			aHeader[1] 	:=  {" ","R","@!",4,0,"","","C","","V"}
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁMontagem do Array dos campos que poderao ser alterados                  Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			For nCntFor := 2 To Len(aHeadgrade[1])
				aadd(aAltGr,aHeader[nCntFor][2])
				aHeader[nCntFor][3] := "@!"
				aHeader[nCntFor][4] := 4
				aHeader[nCntFor][5] := 0
				aHeader[nCntFor][6] := "aVldGrade('A250','M->D3_PARCTOT')"
			Next nCntFor
			aCols := AClone(aColsPT)
			For nLinha :=  1 To Len(aColsGrade[nAux])
				If len(aColsPT) == 0
					aadd(acols,Array(Len(aHeader)))
				EndIf
				For nColuna := 1 To Len(aHeader)
					If  nColuna ==  1
						acols[nLinha][nColuna] := aColsGrade[nAux][nLinha][nColuna]
					Else
						dbSelectArea("SC2")
						dbSetOrder(6)
						cProdRef := Substr(M->D3_COD,1,nTamRef)+acols[nLinha][1]+aHeader[nColuna][1]
						If dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)+cProdRef)
							cParcTot := " "
							If aColsGrade[nAux][nLinha][nColuna][1]>0.And.(aColsGrade[nAux][nLinha][nColuna][1]>=(SC2->C2_QUANT-SC2->C2_QUJE-If(lPerdInf,0,SC2->C2_PERDA)))
								cParcTot := "T"
							ElseIf aColsGrade[nAux][nLinha][nColuna][1]>0.And.aColsGrade[nAux][nLinha][nColuna][1]<(SC2->C2_QUANT-SC2->C2_QUJE-If(lPerdInf,0,SC2->C2_PERDA))
								cParcTot := "P"
							ElseIf aColsGrade[nAux][nLinha][nColuna][1]==0.And.(!Empty(C2_DATRF))
								cParcTot := "BX"
							ElseIf aColsGrade[nAux][nLinha][nColuna][1]==0 .And.Empty(C2_DATRF)
								cParcTot := "X"
							EndIf
							acols[nLinha][nColuna] := If(!lMostra .And. Len(aColsPT)==0, "T", cParcTot)
						Else
							acols[nLinha][nColuna] := "--"
						EndIf
					EndIf
				Next nColuna
			Next nLinha
			If lMostra
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0050) FROM 10,10 TO 25,68   OF oMainWnd //Baixa Total / Parcial
				oGet:=MSGetDados():New(20,12,103,223,3,"AllwaysTrue","AllwaysTrue",,.F.,aAltGr,1)
				ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpcA:=1,oDlg:End()},{||oDlg:End()})
			Else
				nOpcA := 1
			EndIf
			If ( nOpcA == 1 )
				aColsPT := AClone(aCols)
			EndIf
			aCols := AClone(aColsCop)
		Else
			Help("",1,"A650NOP")
			lRet := .F.
		EndIf
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Restaura aRotina Original                                    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	aRotina:=aClone(aBackRot)
	RestArea(aAreaSC2)
Return lRet

//----------------------------------------------------------------------
// FUNCAO UTILIZADA SOMENTE PARA MANTER LEGADO DA UTILIZACAO DE GRADE
// DE PRODUTOS SEM OBJETO ATE LANCAMENTO DO R4.
//
// ATENCAO: Foi incluido um "_" na inicio do nome da funcao
//----------------------------------------------------------------------
Function _aQtdPerda(cProg)

	Local nLinha, nColuna, nOpcA, nQtdInf := 0
	Local cProdRef := M->D3_COD
	Local lGrade   := GetMv("MV_GRADE")
	Local aAltGr   := {}
	Local aColsCop := {}
	Local nSoma    := 0
	Local aBackRot := aClone(aRotina)
	Local nAux     := 1
	Local nCntFor  := 0
	cProg := If(cProg == NIL,'', cProg)
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Muda o valor do aRotina para nao incluir linha na GetDados   Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If !__lAutomacao
		aRotina[3,4] := 6
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se a grade esta ativa e se o prod. e' uma referenciaЁ
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ( lGrade ) .And.  MatGrdPrrf(@cProdRef)  .And. cProg == "A250"
		M->D3_PARCTOT := " "
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se ja montou a grade de produtos desta OP       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		aColsCop := AClone(aCols)
		If Len(acols) == 0
			aQtdGrade(.F.)
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁMonta aHeader e aCols                                                   Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		aHeader	:= Aclone(aHeadGrade[1])
		aHeader[1] 	:=  {" ","R","@!",4,0,"","","C","","V"}
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁMontagem do Array dos campos que poderao ser alterados                  Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		For nCntFor := 2 To Len(aHeadgrade[1])
			aadd(aAltGr,aHeader[nCntFor][2])
			aHeader[nCntFor][6] := "aVldGrade('A250')"
		Next nCntFor
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁSe nao tiver sido digitado nenhuma perda,monta acols,senao,considera no acols a qtd. ja' digitadaЁ
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		aCols := AClone(aQtdPerda)
		If Len(aCols) == 0
			For nLinha :=  1 To Len(aColsGrade[nAux])
				aadd(acols,Array(Len(aHeader)))
				For nColuna := 1 To Len(aHeader)
					acols[nLinha][nColuna]:=If(nColuna==1, aColsGrade[nAux][nLinha][nColuna], 0)
				Next nColuna
			Next nLinha
			aQtdPerda := AClone(aCols)
		EndIf

		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0051) FROM 10,10 TO 25,68   OF oMainWnd //Perdas
		oGet:=MSGetDados():New(20,12,103,223,3,"AllwaysTrue","AllwaysTrue",,.F.,aAltGr,1)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpcA:=1,oDlg:End()},{||oDlg:End()})

		If ( nOpcA == 1 )
			For nLinha :=  1 To Len(aColsGrade[nAux])
				For nColuna := 2 To Len(aHeader)
					aQtdPerda[nLinha][nColuna] := acols[nLinha][nColuna]
					nSoma+=aCols[nLinha][nColuna]
				Next nColuna
			Next nLinha
		EndIf

		aCols := AClone(aColsCop)
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁVerifica se ha divergencias                                             Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If ( nSoma != &(Readvar()) .And. &(Readvar()) != 0 )
			Help(" ",1,"A410QTDDIF")
		EndIf

		M->D3_PERDA := nSoma
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Restaura aRotina Original                                    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	aRotina:=AClone(aBackRot)

Return .T.

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁPrograma  ЁMenuDef   Ё Autor Ё Fabio Alves Silva     Ё Data Ё04/10/2006Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Utilizacao de menu Funcional                               Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁArray com opcoes da rotina.                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁParametros do array a Rotina:                               Ё╠╠
╠╠Ё          Ё1. Nome a aparecer no cabecalho                             Ё╠╠
╠╠Ё          Ё2. Nome da Rotina associada                                 Ё╠╠
╠╠Ё          Ё3. Reservado                                                Ё╠╠
╠╠Ё          Ё4. Tipo de Transa┤└o a ser efetuada:                        Ё╠╠
╠╠Ё          Ё	  1 - Pesquisa e Posiciona em um Banco de Dados     	  Ё╠╠
╠╠Ё          Ё    2 - Simplesmente Mostra os Campos                       Ё╠╠
╠╠Ё          Ё    3 - Inclui registros no Bancos de Dados                 Ё╠╠
╠╠Ё          Ё    4 - Altera o registro corrente                          Ё╠╠
╠╠Ё          Ё    5 - Remove o registro corrente do Banco de Dados        Ё╠╠
╠╠Ё          Ё5. Nivel de acesso                                          Ё╠╠
╠╠Ё          Ё6. Habilita Menu Funcional                                  Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё          Ё               Ё                                            Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Static Function MenuDef()

	Private aRotina	:= { {STR0001,"AxPesqui"  	, 0 , 1,0,.F.},;   	//"Pesquisar"
						 {STR0002,"A250Visual"	, 0 , 2,0,Nil},;   	//"Visualizar"
						 {STR0003,"A250Inclui"	, 0 , 3,0,Nil},;   	//"Incluir"
						 {STR0004,"A250Estorn"	, 0 , 5,0,Nil},;	//"Estornar"
		 				 {STR0005,"A250Encer"	, 0 , 7,0,Nil},;  	//"Encerrar"																		 						 
						 {STR0079,"A250Assoc"   , 0 , 2,0,Nil},;    //"Assoc. Lote"
						 {OemToAnsi(STR0078),"A240Legenda",0 , 2,0,Nil}} //"Legenda"
					
	If ExistBlock("MTA250MNU")
		ExecBlock("MTA250MNU",.F.,.F.)
	EndIf
	
Return (aRotina)

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁPrograma  Ёa250Nutri Ё Autor Ё Andre Anjos		    Ё Data Ё17/03/2008Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Calcula Micro e Macronutrientes para uma OPa                Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function A250Nutri(cOP)
	Local aRequis    := {}
	Local nX 	     := 0
	Local nTotReq    := 0
	Local nTotMac    := 0
	Local nTotMic    := 0
	Local nPMacro    := 0
	Local nPMicro    := 0
	Local nQuant     := 0
	Local nCount     := 0
	Local aArea	     := GetArea()
	Local aAreaSD3   := SD3->(GetArea())
	Local lContinua  := .T. // por padrao sempre executa o calculo
	Local lMMacro    := SuperGetMv("MV_MIMACRO",.F.,.T.) // por padrao sempre executa o calculo
	Local l250Nut
	
	Local lMT250NUT   := ExistBlock("MT250NUT")
	Local cQuery      := " "
	Local cAliasNut   := GetNextAlias()

	If ExistBlock("M250CNUT")
		lContinua := ExecBlock("M250CNUT", .F., .F.)
		If ValType(lContinua) # "L"
			lContinua := .T. // por padrao sempre executa o calculo
		EndIf
	EndIf

	If lMT250NUT //Se possuir o PE nЦo И possivel executar com a melhoria de performance
		If lMMacro .And. lContinua
			dbSelectArea("SD3")
			dbSetOrder(1)
			dbSeek(xFilial("SD3")+cOp)
			While !EOF() .And. SD3->(D3_FILIAL+D3_OP) == xFilial("SD3")+cOp
				If IsProdMOD(SD3->D3_COD) .Or. SD3->D3_ESTORNO == "S" .Or. Left(SD3->D3_CF,2) # "RE"
					dbSkip()
					Loop
				EndIf

				If ExistBlock("MT250NUT")
					l250Nut := ExecBlock("MT250NUT",.F.,.F.,{SD3->D3_COD,SD3->D3_OP,SD3->D3_NUMSEQ})
					If ValType(l250Nut) == "L" .And. !l250Nut
						dbSkip()
						Loop
					EndIf
				EndIf

				dbSelectArea("SB1")
				dbSetOrder(1)
				dbSeek(xFilial("SB1")+SD3->D3_COD)

				nPMacro := If(!Empty(SD3->D3_PMACNUT),SD3->D3_PMACNUT,SB1->B1_PMACNUT)
				nPMicro := If(!Empty(SD3->D3_PMICNUT),SD3->D3_PMICNUT,SB1->B1_PMICNUT)

				nTotReq += SD3->D3_QUANT
				aAdd(aRequis,{SD3->D3_QUANT,nPMacro,nPMicro})

				dbSelectArea("SD3")
				dbSkip()
			End

			For nX:=1 To Len(aRequis)
				nTotMac += aRequis[nX][2] * (aRequis[nX][1]/nTotReq)
				nTotMic += aRequis[nX][3] * (aRequis[nX][1]/nTotReq)
			Next nX			

			dbSelectArea("SC2")
			dbSetOrder(1)
			dbSeek(xFilial("SC2")+cOP)
			RecLock("SC2",.F.)
			Replace C2_PMACNUT With nTotMac, C2_PMICNUT With nTotMic
			MsUnLock()
		EndIf
	Else
		If lMMacro .And. lContinua
			cQuery := "  SELECT "
			cQuery += "        SUM (CASE "
			cQuery += "             WHEN SD3.D3_PMACNUT <> 0 THEN SD3.D3_PMACNUT "
			cQuery += "             ELSE B1_PMACNUT "
			cQuery += "             END ) PMACNUT, "
			cQuery += "        SUM (CASE "
			cQuery += "             WHEN SD3.D3_PMICNUT <> 0 THEN SD3.D3_PMICNUT "
			cQuery += "             ELSE B1_PMICNUT "
			cQuery += "             END ) PMICNUT, "
			cQuery += "        SUM(SD3.D3_QUANT) QUANT, "
			cQuery += "        COUNT(*) COUNT1 "
			cQuery += "   FROM " + RetSqlName("SD3") + " SD3 , " + RetSqlName("SB1") + " SB1 "
			cQuery += "  WHERE SD3.D3_FILIAL  = '" + xFilial( "SD3" ) + "'"
			cQuery += "    AND SD3.D3_OP      = '" + cOp + "'"
			cQuery += "    AND SD3.D3_CF      LIKE ('RE%')	"
			cQuery += "    AND SD3.D3_ESTORNO = ' ' "
			cQuery += "    AND SD3.D3_COD     NOT LIKE 'MOD%' "
			cQuery += "    AND SD3.D_E_L_E_T_ = ' ' "
			cQuery += "    AND SB1.B1_COD     = SD3.D3_COD "
			cQuery += "    AND SB1.D_E_L_E_T_ = ' ' "
			cQuery += "    AND SB1.B1_FILIAL  = '" + xFilial( "SB1" ) + "'"

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasNut,.T.,.T.)
			If (cAliasNut)->(!Eof())
				nPMacro := (cAliasNut)->PMACNUT
				nPMicro := (cAliasNut)->PMICNUT
				nQuant  := (cAliasNut)->QUANT
				nCount  := (cAliasNut)->COUNT1				
			EndIf

			(cAliasNut)->(DBCloseArea())

			nTotMac := nPMacro * ( nQuant / (nQuant * nCount))
			nTotMic := nPMicro * ( nQuant / (nQuant * nCount))
 
			dbSelectArea("SC2")
			dbSetOrder(1)
			dbSeek(xFilial("SC2")+cOP)
			RecLock("SC2",.F.)
			Replace C2_PMACNUT With nTotMac, C2_PMICNUT With nTotMic
			MsUnLock()
		EndIf
	EndIf

	RestArea(aArea)
	RestArea(aAreaSD3)

Return

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁPrograma  Ёa250ChkEmpЁ Autor Ё Andre Anjos		    Ё Data Ё14/04/2008Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica se hА empenhos nao baixados quando MV_REQAUT = D  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function a250ChkEmp(cOP)
	Local lRet := .T.
	Local aArea := GetArea()
	Local aErros := {}

	If SuperGetMV("MV_REQAUT",.F.) == "D" .And. If(l250,M->D3_PARCTOT == "T",M->H6_PT == "T")
		dbSelectArea("SD4")
		dbSetOrder(2)
		dbSeek(xFilial("SD4")+cOP)

		While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOP

			IF SUBSTR(SD4->D4_COD,1,3)=="MOD".AND. SF5->F5_TRANMOD=="S"
				dbSelectArea("SD4")
				dbSkip()
				Loop
			ENDIF

			If SD4->D4_QUANT > 0
				aAdd(aErros,{SD4->D4_COD,SD4->D4_LOCAL,Transform(SD4->D4_QUANT,PesqPictQT("D4_QUANT")),OemToAnsi(STR0100),Nil,Nil})//Saldo de empenho pendente
			EndIf
			dbSkip()
		End

		If !Empty(aErros)
			If !MsgYesNo(OemToAnsi(STR0099)) //A Ordem de Producao apontada sera encerrada e ainda possui saldo de empenho(s). Deseja realmente prosseguir com o apontamento?
				MTA250TELA(aErros)
				lRet := .F.
			EndIf
		EndIf
	EndIf

	RestArea(aArea)
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁA250VerReq╨Autor  ЁAndre Anjos         ╨ Data Ё  07/01/09   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descricao Ё Verifica a existencia de requisicoes para uma OP a partir  ╨╠╠
╠╠╨			 Ё de determinada data.										  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ cOP: Ordem de Producao							          ╨╠╠
╠╠╨			 Ё dData: Data de referencia para a busca de requisicoes      ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Retorno   Ё lRet: Indica se ha requisicoes contra a OP (T=Sim,F=Nao)   ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё MATA250                                                    ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A250VerReq(cOP,dData)
	Local lRet := .F.
	Local aArea := GetArea()
	Local cQuery := ""
	Local cAlias := "SD3"

	If !Empty(dData)
		cAlias := GetNextAlias()
		cQuery := "SELECT MAX(D3_EMISSAO) AS D3_EMISSAO FROM " +RetSQLName("SD3") +" WHERE D3_OP = '" +cOP +"' AND "
		cQuery += "SUBSTRING(D3_CF,1,2) = 'RE' AND D3_ESTORNO <> 'S' AND D3_FILIAL = '" +xFilial("SD3") +"' AND "
		cQuery += "D3_EMISSAO > '" +DToS(dData) +"' AND D_E_L_E_T_ = ''"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cAlias,.F.,.T.)
		dbSelectArea(cAlias)
		dbGoTop()
		If !Empty((cAlias)->D3_EMISSAO)
			lRet := .T.
		EndIf
		(cAlias)->(DbCloseArea())
	EndIf

	RestArea(aArea)
Return lRet

/*эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250Bloq  Ё Autor ЁMicrosiga S/A          Ё Data Ё16/01/2009|╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁFuncao utilizada para verificar se o armazem possui controleЁ╠╠
╠╠Ё          Ёbloqueio pelo campo tipo de armazem.                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       ЁMATA250                                                     Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Static Function A250Bloq(cCod,cLocal,cOp)
	Local lRet := .F.
	Local aAreaAnt := GetArea()

	Default cOp := ""

	If AvalBlqLoc(cCod,cLocal,Nil,.F.,,,,,,cOP)
		lRet := .T.
	EndIf

	RestArea(aAreaAnt)
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁA250EstSDB╨Autor  ЁAndre Anjos         ╨ Data Ё  07/01/09   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descricao Ё Verifica se a RE1 no SDB ja foi processada como estorno    ╨╠╠
╠╠╨			 Ё pela MovLote. Se nao, inclui o Recno no array.			  ╨╠╠
╠╠╨			 Ё Esta funcao foi criada para corrigir um erro na MovLote	  ╨╠╠
╠╠╨			 Ё caso o usuario selecione redistribuir no estorno de movim. ╨╠╠
╠╠╨			 Ё com endereco. Como neste caso o SDB nao e estornado 		  ╨╠╠
╠╠╨			 Ё monto o array com Recnos ja processados.					  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ nRecno: Recno do registro a estornar 					  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Retorno   Ё lRet: Indica se deve estornar ou nao. (T=Sim,F=Nao)   	  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё SIGACUSA                                                   ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A250EstSDB(nRecno)
	Static aRecnosDB := {}
	Local lRet := .T.

	If (lRet := (aScan(aRecnoSDB,{|x| x == nRecno}) == 0))
		aAdd(aRecnosDB,nRecno)
	EndIf

Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    ЁA250NEstorЁ Autor Ё Sergio S. Fuzinaka    Ё Data Ё 21.09.09 |╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescricao ЁValida a origem do apontamento Producao PCP Mod1 ou Mod2.   Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       ЁMATA250                                                     Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A250NEstor( cD3Ident )

	Local lRet		:= .F.
	Local cAlias	:= "SH6"
	Local aArea		:= GetArea()
	Local aAreaSH6	:= SH6->( GetArea() )
	Local cIndex 	:= ""
	Local cChave 	:= ""
	Local cQuery 	:= ""
	Local lQuery	:= .T.

	dbSelectArea("SH6")
	dbSetOrder(1)

	If lQuery
		cAlias := GetNextAlias()
		BeginSql Alias cAlias
			SELECT H6_IDENT
			FROM %table:SH6% SH6
			WHERE H6_FILIAL = %xFilial:SH6% AND
			SH6.H6_IDENT = %Exp:cD3Ident% AND
			SH6.%NotDel%
		EndSql
	Else
		cIndex := CriaTrab(NIL,.F.)
		cChave := IndexKey()
		cQuery := "H6_FILIAL == '"+xFilial("SH6")+"' .And. H6_IDENT == '"+cD3Ident+"'"
		IndRegua("SH6",cIndex,cChave,,cQuery)
		dbGoTop()
	Endif

	lRet := ( (cAlias)->(!Eof()) )

	If lQuery
		dbCloseArea()
	Else
		RetIndex("SH6")
		Ferase(cIndex+OrdBagExt())
	Endif

	RestArea( aAreaSH6 )
	RestArea( aArea )

Return( lRet )

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA250LinOK Ё Autor Ё Everton M. Fernandes Ё Data Ё 16/11/11  Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida a linha da GetDados na inclusao                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A250LinOk()                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A250LinOk()
	Local lRet      := .T.
	Local i         := 0
	Local nQuant    := 0
	Local nQuant2   := 0
	Local nQuantCols:= 0
	Local nAchou    := 0
	Local aAreaAnt  := {}
	Local aAreaSD3  := {}

	Local cSeek     := ''
	Local cDoc      := ''
	Local cLoja     := ''
	Local cProduto  := ''
	Local cSeekSD3  := ''
	Local cNumSeq   := ''
	Local cLocal    := ''

	Local aArea     := GetArea()
	Local cLocCQ    := GetMvNNR('MV_CQ','98')
	Local aInfProd  := InfProd(SDA->DA_PRODUTO)
	Local lIntegEIC := (SuperGetMV("MV_EASY") == "S")
	Local dDataFec  := MVUlmes()
	Local lAchou    := .F.
	Local lDistMov	:=	SuperGetMV("MV_DISTMOV",.F.,.F.)

	if lDistMov .And. Localiza(SD3->D3_COD)
		If !(aCols[n,Len(aCols[n])])

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Valida quantidade IGUAL A 1 quando usa numero de serie       Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lRet
				lRet:=MtAvlNSer(SD3->D3_COD,aCols[n,nPosNumSer],aCols[n,nPosQuant])
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se j═ nao existe um numero de serie p/ este produto Ё
			//Ё neste almoxarifado.                                          Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lRet .And. !Empty(aCols[n,nPosNumSer])
				dbSelectArea("SBF")
				dbSetOrder(4)
				cSeek  := xFilial("SBF")+SD3->D3_COD+aCols[n,nPosNumSer]
				nAchou := ASCAN(aCols,{|x| x[nPosNumSer] == aCols[n,nPosNumSer] })
				If (nAchou > 0 .And. nAchou <> n) .Or. (dbSeek(cSeek) .And. QtdComp(BF_QUANT) > QtdComp(0))
					Help(" ",1,"NUMSERIEEX")
					lRet:=.F.
				EndIf
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se nao existe outro produto nesta localizacao que   Ё
			//Ё utilize controle de area.                                    Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lRet
				SBE->(dbSetOrder(1))
				If SBE->(dbSeek(xFilial("SBE")+SD3->D3_LOCAL+aCols[n,nPosLocali]))
					//зддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Verifica se utiliza controle de Cubagem         Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддды
					If aInfProd[1] .OR. (SBE->BE_ALTURLC*SBE->BE_LARGLC*SBE->BE_COMPRLC > 0)
						lRet:=ProdLocali(SD3->D3_COD,SD3->D3_LOCAL,aCols[n,nPosLocali])
					EndIf
				EndIf
			EndIf

			If lRet
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se qtd distribuida nao ultrapassou o saldo a ser    Ё
				//Ё distribuido.                                                 Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				For i:= 1 to Len(aCols)
					If !(aCols[i,Len(aCols[i])])
						nQuant+= aCols[i,nPosQuant]
					EndIf
				Next i
				If QtdComp(nQuant) > QtdComp(SD3->D3_QUANT)
					Help(" ",1,"MA265QUANT")
					lRet:=.F.
				EndIf
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se qtd distribuida nao ultrapassou a capacidade da  Ё
			//Ё localizacao.                                                 Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lRet .And. !Empty(aCols[n,nPosLocali])
				For i:=1 to Len(aCols)
					If aCols[i,nPosLocali] == aCols[n,nPosLocali]
						nQuantCols+=aCols[i,nPosQuant]
					EndIf
				Next i
				lRet:=Capacidade(SD3->D3_LOCAL,aCols[n,nPosLocali],nQuantCols,SD3->D3_COD)
			EndIf
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se qtde a distribuir foi empenhada conforme conceito da processo de importaГЦo, se sim, nЦo    Ё
			//Ё permitir a distribuiГЦo dos produtos.                                                                   Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lRet .And. cPaisLoc != "BRA" .And. lIntegEIC .And. Rastro(SD3->D3_COD)
				If  SaldoSDA(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,.T. ) < aCols[n][nPosQuant]
					Aviso(STR0016,STR0017, { "  OK  " } )
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf
	RestArea(aArea)
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    ЁoDlgTdOK  Ё Autor Ё Everton M. Fernandes  Ё Data Ё 02.01.12 |╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescricao ЁValida a tela de classificaГЦo de produГЦo a maior		  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       ЁMATA250, MATA680 e MATA681                                  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function oDlgTdOK(oDlg, lOk, nQtdGanho, nQtdMaior, nExcede)
	Local lRet
	Local aEstC2 := SC2->(DBSTRUCT())
	Local nDecimal := 2
	Local nX := 0

	for  nX:= 1 to len(aEstC2)
		IF aEstC2[nX][1] == "C2_QUANT"
			nDecimal := aEstC2[nX][4]
			EXIT
		EndIf
	Next

	if lOk
		if round( (nQtdGanho + nQtdMaior) , nDecimal) = round(nExcede , nDecimal)
			oDlg:End()
		else
			//A quantidade classificada И diferente do excedente da produГЦo.
			Help(" ",1,"A250QTDDIF")
		endif
	endif

return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFuncao    Ёa250Maior Ё Autor Ё Everton M. Fernandes  Ё Data Ё 02.01.12 |╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescricao ЁVerifica a necessidade de prorporcionalizaГЦo               Ё╠╠
╠╠Ё          Ёdos empenhos SD4                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       ЁMATA250, MATA680 e MATA681                                  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function a250Maior(nOP , nQuant, nQtdPerd, nQtdGanho, nQtdMaior, nPercPrM, cAlias)
	Local lRet		 := .T.
	Local nProduz	 := 0
	Local nExcede 	 := 0
	Local nExcedeAtu :=0
	Local nPercExced := SuperGetMV("MV_PERCPRM",.F.,0)
	Local lProdMaior    := SuperGetMV("MV_PERCPRM",.F., 0) > 0
	Local oQtdGanho	 := Nil
	Local oQtdMaior	 := Nil
	Local lOk		 := .F.
	Local lH6		 := cAlias = "SH6"
	Local lGanho	 := SuperGetMV("MV_GANHOPR",.F.,.T.)
	Local nQtdApont     := 0
	Local nQtdEstor     := 0
	Local nQtdTotal     := 0
	Local nQtdDisp      := 0
	Local nQtdSaldo     := 0
	Local nQtdRecalc    := 0
	Local aAreaSH61     := {}
	Local aAreaSD31     := {}

	if nQtdMaior == nil
		nQtdMaior := 0
	endif

	if nQtdGanho == nil
		nQtdGanho := 0
	endif

	//Posicionaliza a SD4  //Everton
	DbSelectArea("SC2")
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2") + nOP))
		if lH6
			cOpeSaldo := M->H6_OPERAC
			cSeqSaldo := M->H6_SEQ
			If mv_par07 == 1
				lCoPer := .T.
				lCoOA  := .F.
			Else
				If mv_par07 == 2
					lCoPer := .F.
					lCoOA  := .F.
				Else
					lCoPer := .F.
					lCoOA  := .F.
				EndIf
			EndIf

			nProduz := A680SldOper(l680,lCoPer,lCoOA)[1] //Retorna o apontamento anterior
		else
			nProduz :=	C2_QUANT - C2_QUJE - If(lPerdInf,0,C2_PERDA)
		endif

		//nProduz    - saldo da quantidade que ja foi apontada ate o momento
		//nQuant     - quantidade que esta sendo apontada agora
		//nExcede    - quantidade que excedeu considerando todos os apontamentos
		//nExcedeAtu - quantidade que excedeu no apontamento corrente

		If !lPerdInf
			nQuant := nQuant + nQtdPerd
		EndIf

		If nQuant > nProduz
			nSomaAponN := 0
			If lH6
				aAreaSH61  := SH6->(GetArea())
				dbSelectArea("SH6")
				dbSetOrder(1)
				dbGotop()
				dbSeek(xFilial("SH6")+nOP)
				While !Eof() .And. SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + nOP
					If SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + nOP .And. SH6->H6_OPERAC + SH6->H6_SEQ = cOpeSaldo + cSeqSaldo
						If SH6->H6_QTDPROD > 0 .OR. SH6->H6_QTDPERD > 0
							lPerdPrd := IIF(lPerdInf,0,SH6->H6_QTDPERD)
							nSomaAponN += SH6->H6_QTDPROD + lPerdPrd - H6_QTMAIOR - H6_QTGANHO
						EndIf
					EndIf
					dbSkip()
				End
				RestArea(aAreaSH61)

				nProduz := SC2->C2_QUANT - nSomaAponN
				If nProduz < 0
					nProduz := 0
				EndIf
			Else
				aAreaSD31  := SH6->(GetArea())
				dbSelectArea("SD3")
				dbSetOrder(1)
				dbGotop()
				dbSeek(xFilial("SD3")+nOP+SC2->C2_PRODUTO)
				While !Eof() .And. xFilial("SD3")+nOP+SC2->C2_PRODUTO == SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD
					If SD3->D3_ESTORNO == "S" .Or. SD3->D3_CF != "PR0"
						dbSkip()
						Loop
					EndIf

					If SD3->D3_QUANT > 0 .Or. SD3->D3_PERDA > 0
						lPerdPrd := IIF(lPerdInf,0,SD3->D3_PERDA)
						nSomaAponN += SD3->D3_QUANT + lPerdPrd - D3_QTMAIOR - D3_QTGANHO
					EndIf
					dbSkip()
				End
				RestArea(aAreaSD31)

				nProduz := SC2->C2_QUANT - nSomaAponN
				If nProduz < 0
					nProduz := 0
				EndIf
			EndIf

			nExcede    := nQuant - nProduz

			If nProduz <= 0
				nExcedeAtu := nQuant
			Else
				nExcedeAtu := nQuant - nProduz
			EndIf

			If nExcedeAtu <= 0
				Return .T.
			EndIf

			//If lGanho .and. nPercExced > 0
			If lGanho .and. nPercExced > 0 .AND. !(Type("l680Auto") == "L" .and. l680Auto) .AND. !(Type("l681Auto") == "L" .and. l681Auto) .And. !(Type("l250Auto") == "L" .and. l250Auto)
				//---------------------------
				//Monta a tela
				//---------------------------
				DEFINE MSDIALOG oDlg  FROM 000, 000  TO 180, 360 TITLE OemToAnsi(STR0108)/*"ClassificaГЦo da quantidade produzida acima do previsto"*/ PIXEL STYLE DS_MODALFRAME //"ClassificaГЦo da quantidade produzida acima do previsto"
				cTexto := OemToAnsi(STR0109) + ALLTRIM(STR(nExcedeAtu)) + OemToAnsi(STR0110) + ALLTRIM(STR(SC2->C2_QUANT)) + "." + OemToAnsi(STR0111)
				/*----------------------------
				Texto contido na variАvel cTexto que serА exibida na tela
				"Foi produzida quantidade de <nExcede> ;
				" acima da quantidade prevista pela ordem de produГЦo, que era <SC2->C2_QUANT>.
				" Classifique este excedente conforme abaixo:"
				------------------------------*/

				@ 010, 015 SAY cTexto SIZE 160, 025 OF oDlg COLORS 0, 16777215 PIXEL

				@ 040, 015 SAY OemToAnsi(STR0112)/*"Ganho de produГЦo:"*/ SIZE 055, 015 OF oDlg COLORS 0, 16777215 PIXEL
				@ 060, 015 SAY OemToAnsi(STR0113)/*"ProduГЦo a maior:"*/  SIZE 055, 015 OF oDlg COLORS 0, 16777215 PIXEL

				@ 040, 070 MSGET oQtdGanho VAR nQtdGanho Picture PesqPict("SD3","D3_QTGANHO") Valid (Positivo(nQtdGanho)) SIZE 070, 010 OF oDlg PIXEL
				@ 060, 070 MSGET oQtdMaior VAR nQtdMaior Picture PesqPict("SD3","D3_QTMAIOR") Valid (Positivo(nQtdMaior)) SIZE 070, 010 OF oDlg PIXEL

				DEFINE SBUTTON FROM 075, 086 TYPE 01 OF oDlg ENABLE ACTION (lOK := .T.,oDlgTdOK(oDlg, lOk, nQtdGanho, nQtdMaior, nExcedeAtu))
				DEFINE SBUTTON FROM 075, 115 TYPE 02 OF oDlg ENABLE ACTION (lOK := .F.,oDlg:End())

				oDlg:lEscClose := .F.
				ACTIVATE MSDIALOG oDlg CENTERED
				//---------------------------
				lRet := lOk
				if lRet
					If nExcedeAtu > nQtdMaior + nQtdGanho //Faz com que tudo que nЦo seja produГЦo a maior vire ganho de produГЦo
						nQtdGanho := nExcedeAtu - nQtdMaior
					endif
				EndIf
			Else
				//If lGanho .and. nPercExced = 0 .AND. !(Type("l680Auto") == "L" .and. l680Auto) .AND. !(Type("l681Auto") == "L" .and. l681Auto) .And. !(Type("l250Auto") == "L" .and. l250Auto)
				If !(Type("l680Auto") == "L" .and. l680Auto) .AND. !(Type("l681Auto") == "L" .and. l681Auto) .And. !(Type("l250Auto") == "L" .and. l250Auto)
					If lGanho
						nQtdMaior := 0
						nQtdGanho := nExcedeAtu
					Else
						nQtdMaior := nExcedeAtu
						nQtdGanho := 0
					EndIf
				Else
					//If !l680Auto .AND. !l681Auto .And. !l250Auto
					If (Type("l680Auto") == "L" .and. l680Auto) .Or. (Type("l681Auto") == "L" .and. l681Auto)
						If M->H6_QTMAIOR = 0 .And. !lGanho .And. lProdMaior
							nQtdMaior := nExcedeAtu
							nQtdGanho := 0
						Else
							nQtdMaior := M->H6_QTMAIOR
							nQtdGanho := M->H6_QTGANHO
						EndIf
					Else
						If l250Auto
							If M->D3_QTMAIOR = 0 .And. !lGanho .And. lProdMaior
								nQtdMaior := nExcedeAtu
								nQtdGanho := 0
							Else
								nQtdMaior := M->D3_QTMAIOR
								nQtdGanho := M->D3_QTGANHO
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		ElseIf lH6
			nQtdMaior := 0
			nQtdGanho := 0
		EndIf

		#IFDEF TOP
		If nQtdMaior > 0
			nQtdApont := 0
			cAliasSD3:=GetNextAlias()
			cQuery:="SELECT SUM(d3_qtmaior) qtd_normal FROM "+RetSqlName("SD3")+" "
			cQuery+="WHERE D3_FILIAL='"+xFilial("SD3")+"' "
			cQuery+="AND D3_OP='"+nOP+"' "
			cQuery+="AND D3_CF='PR0'"

			cQuery:=ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cAliasSD3,.F.,.T.)
			If (cAliasSD3)->(!Eof())
				nQtdApont := (cAliasSD3)->qtd_normal
			EndIF

			If Empty(nQtdApont)
				nQtdApont := 0
			EndIf

			nQtdEstor := 0
			cAliasSD3:=GetNextAlias()
			cQuery:="SELECT SUM(d3_qtmaior) qtd_estorno FROM "+RetSqlName("SD3")+" "
			cQuery+="WHERE D3_FILIAL='"+xFilial("SD3")+"' "
			cQuery+="AND D3_OP='"+nOP+"' "
			cQuery+="AND D3_CF='ER0'"

			cQuery:=ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cAliasSD3,.F.,.T.)
			If (cAliasSD3)->(!Eof())
				nQtdEstor := (cAliasSD3)->qtd_estorno
			EndIF

			If Empty(nQtdEstor)
				nQtdEstor := 0
			EndIf

			nQtdTotal := nQtdApont - nQtdEstor //Quantidade que ja foi apontada de produГЦo a maior

			nQtdDisp := (SC2->C2_QUANT * nPercExced) / 100 //Quantidade que pode apontar a maior conforme percentual
			nQtdSaldo := nQtdDisp - nQtdTotal

			If nQtdTotal > 0

				If nQtdDisp > nQtdTotal
					cAliasSD3:=GetNextAlias()
					cQuery:="SELECT SUM(d3_quant) qtd_normal FROM "+RetSqlName("SD3")+" "
					cQuery+="WHERE D3_FILIAL='"+xFilial("SD3")+"' "
					cQuery+="AND D3_OP='"+nOP+"' "
					cQuery+="AND D3_CF='PR0'"
					cQuery+="AND D3_ESTORNO=''"
					cQuery:=ChangeQuery(cQuery)
					dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cAliasSD3,.F.,.T.)
					If (cAliasSD3)->(!Eof())
						nQtdRecalc := (cAliasSD3)->qtd_normal
					EndIF
					If Empty(nQtdApont)
						nQtdRecalc := 0
					EndIf
					nQtdSaldo = (SC2->C2_QUANT + nQtdDisp) - nQtdRecalc
				EndIf

				If nQtdDisp <= nQtdTotal
					//cMsg  := 'JА foi apontada toda a quantidade disponМvel de produГЦo a maior permitida conforme parametrizaГЦo ("MV_PERCPRM").'
					//cMsg1 := ' Quantidade permitida: ' + CVALTOCHAR(nQtdDisp) + '. Quantidade jА apontada de produГЦo a maior:' + CVALTOCHAR(nQtdTotal)
					cMsg  := STR0120 + ' ' + STR0121 + CVALTOCHAR(nQtdDisp) + '. ' + STR0122 + CVALTOCHAR(nQtdTotal) + '.'

					Aviso('MATA250',cMsg, { "  OK  " } )
					lRet := .F.
				Else
					If nQtdSaldo < nQtdMaior
						//cMsg  := 'Quantidade informada de produГЦo a maior ultrapassa o limite permitido conforme parametrizaГЦo ("MV_PERCPRM").'
						//cMsg1 := ' Quantidade permitida: ' + CVALTOCHAR(nQtdDisp) + '. Quantidade disponМvel: ' + CVALTOCHAR(nQtdSaldo) + '.'
						cMsg := STR0123 + ' ' + STR0121 + CVALTOCHAR(nQtdDisp) + '. ' + STR0124 + CVALTOCHAR(nQtdSaldo) + '.'
						Aviso('MATA250',cMsg, { "  OK  " } )
						lRet := .F.
					EndIf
				EndIF
			Else
				If nQtdSaldo < nQtdMaior
					//cMsg  := 'Quantidade informada de produГЦo a maior ultrapassa o limite permitido conforme parametrizaГЦo ("MV_PERCPRM").'
					//cMsg1 := ' Quantidade permitida: ' + CVALTOCHAR(nQtdDisp) + '. Quantidade disponМvel: ' + CVALTOCHAR(nQtdSaldo) + '.'
					cMsg := STR0123 + ' ' + STR0121 + CVALTOCHAR(nQtdDisp) + '. ' + STR0124 + CVALTOCHAR(nQtdSaldo) + '.'
					Aviso('MATA250',cMsg, { "  OK  " } )
					lRet := .F.
				EndIF
			EndIf

			nPercPrM:=(nQtdMaior/SC2->C2_QUANT)
		EndIf
		#ELSE
		//Valida se a quantidade a maior estА dentro do limite permitido
		nPercPrM:=(nQtdMaior/SC2->C2_QUANT)
		If (nPercPrM * 100) > nPercExced
			//A quantidade supera o percentual de produГЦo a maior ("MV_PERCPRM")
			Help(" ",1,"A250QUANT")
			lRet := .F.
		EndIf
		#ENDIF
	EndIf

	lExistePM := .F.
	If lRet
		If nQtdMaior > 0
			lExistePM := .T.
		EndIf
	EndIf

Return lRet

//-----------------------------------------------------------
/*/{Protheus.doc} A250INTAGR
Valida se o Apontamento da OP foi originado pelo SIGAAGR

@param: cOP - NЗmero da ordem de produГЦo
@author: Aecio Ferreira Gomes
@since: 07/08/2013
@Uso: MATA250
/*/
//-----------------------------------------------------------
Static Function A250INTAGR(cOP)
	Local lRet 			:= .T.
	Local cAliasAGR 	:= ""

	If !( "AGR" $ FunName() )

		If !IsinCallStack("AGRA600")
			DbSelectArea("DXM")
			DbSetOrder(2)
			If MsSeek(xFilial("DXM")+cOP)
				lRet := .F.
				Aviso( STR0035,STR0115,{"OK"})
			Endif
		EndIf

		If lRet .And. !IsinCallStack("AGRA620")

			cAliasAGR 	:= GetNextAlias()

			BeginSql Alias cAliasAGR
				Select
				DXL_OPBN
				From
				%Table:DXL% DXL
				Where
				DXL.DXL_FILIAL = %exp:xFilial("DXL")% AND
				DXL.DXL_OPBN = %exp:cOP% AND
				DXL.%NotDel%
			EndSql

			If (cAliasAGR)->(!Eof())
				lRet := .F.
				Aviso( STR0035,STR0116,{"OK"}) // "O estorno deste movimento deverА ser feito atravИs da rotina de Encerramento do modulo (SIGAAGR - UBA)."
			EndIf

			(cAliasAGR)->(dbCloseArea())

		EndIf

	EndIf

Return lRet

/*эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤ao    ЁA250VlPImp Ё Autor ЁRobson Sales          Ё Data Ё02/09/2013Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤ao ЁValida o percentual de importado digitado                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A250VlPImp()

	Local lRet   := .T.

	If IsInCallStack("MATA242") .Or. IsInCallStack("MATA250") .Or. IsInCallStack("MATA261")
		If M->D3_PERIMP > 100 .Or. M->D3_PERIMP < 0
			Help(" ",1,"A250VLPIMP")
			lRet := .F.
		EndIf
	EndIf
	If IsInCallStack("MATA260")
		If nPerImp > 100 .Or. nPerImp < 0
			Help(" ",1,"A250VLPIMP")
			lRet := .F.
		EndIf
	EndIf

Return lRet

/*эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤ao    ЁA250descbr Ё Autor ЁMichelle Ramos        Ё Data Ё16/10/2017Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤ao ЁTrazer a descriГЦo do produto no browse (chamada da funГЦo  Ё╠╠
╠╠Ё           pelo dicionАrio no campo D3_DESCRI)                         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/

Function A250descbr()

	Local lRetorno := ' '

	If IsInCallStack("MATA185")
		lRetorno := If(l240.And.!Empty(M->D3_COD),Posicione("SB1",1,xFilial("SB1")+M->D3_COD,"B1_DESC"),"")
	Else
		If (Type("INCLUI") == "L" .And. !INCLUI) .Or. (Type("INCLUI") != "L")
			If Type('M')=='C'
				lRetorno := IIF(M->D3_COD <> NIL,POSICIONE("SB1",1,XFILIAL("SB1")+M->D3_COD,"B1_DESC"),"")
			else
				lRetorno := IIF(SD3->D3_COD <> NIL,POSICIONE("SB1",1,XFILIAL("SB1")+SD3->D3_COD,"B1_DESC"),"")
			EndIf
		EndIf
	EndIf

Return lRetorno

/*эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤ao    ЁA250contde Ё Autor ЁMichelle Ramos        Ё Data Ё19/10/2017Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤ao ЁVerifica a quantidade de casas decimais do valor calculado  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA250                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/

function A250contde(nQtd)

	local nDec := 0
	local ni:= 0
	local ccompara := cValToChar(nqtd)
	local lvirgula := .F.

	for ni:=1 to len(Trim(ccompara))
		if lvirgula == .T.
			nDec += 1
		else
			if substr( ccompara, ni, 1 ) == "." .Or. substr( ccompara, ni, 1 ) == ","
				lvirgula := .T.
			endif
		endif
	next ni

return nDec

// Valida se a ordem jА foi apontada no MATA680/MATA681
Static Function A250VerApo()
	Local aArea  := GetArea()
	Local cAlias := ""
	Local cQuery := ""
	Local lRet   := .T.

	If !Empty(M->D3_OP)
		cAlias := GetNextAlias()
		cQuery := " SELECT Count(*) TOTAL FROM "+RetSqlName('SH6') + " SH6 "
		cQuery += "  WHERE SH6.H6_FILIAL  = '"+xFilial("SH6")+"' "
		cQuery += "    AND SH6.H6_OP      = '"+M->D3_OP+"' "
		cQuery += "    AND (SH6.H6_QTDPROD > 0 OR SH6.H6_QTDPERD > 0) "
		cQuery += "    AND SH6.D_E_L_E_T_ = ' ' "

		dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAlias, .T., .F. )
		If (cAlias)->(TOTAL) > 0
			// Mensagem existe apontamento
			//Aviso('MATA250',STR0127,{'Ok'}) //Ordem jА apontada pelo MATA680/MATA681 (Apontamento MOD1/MOD2 ). NЦo И permitido realizar o apontamento.
			Help( ,, 'Help',, STR0127, 1, 0 )
			lRet = .F.
		EndIf
		(cAlias)->(dbCloseArea())
	EndIf
	RestArea(aArea)
Return lRet

/*/{Protheus.doc} A250SalPer
FunГЦo para validaГЦo do saldo da perda
@type  Function
@author Michele Girardi
@since 09/01/2018
@version version
@param nQtdSD3, number, quantidade produzida
@return lRet, logical, valido ou invalido
@example
(examples)
@see (links_or_references)
/*/
Function A250SalPer(nQtdSD3)
	Local lESTNEG  := SuperGetMv("MV_ESTNEG",,'N') == 'S'//'Identifica se o sistema permitirА que os saldos em estoque dos produtos fique negativo atravИs de movimentaГЦo. ConteЗdo deve ser (S)im ou (N)Цo.'
	Local lRet     := .F.
	Local nQtdPerd := 0

	Pergunte("MTA685",.F.)
	lParam := IIf(mv_par01 == 1, .T. , .F.)

	//Se nЦo requisitar produto origem deve consistir o saldo em estoque no estorno
	If !lParam
		lRet := .F.
		Return lRet
	EndIf

	dbSelectArea("SBC") //Perda por OP
	dbSetOrder(1)
	If dbSeek(xFilial("SBC")+SD3->D3_OP+SD3->D3_NUMSEQ)
		Do While !Eof() .And. BC_FILIAL+BC_OP+BC_NUMSEQ == xFilial("SBC")+SD3->D3_OP+SD3->D3_NUMSEQ
			If SD3->D3_COD == SBC->BC_PRODUTO
				nQtdPerd += SBC->BC_QUANT
			EndIf
			dbSkip()
		EndDo
	EndIf

	//Quantidade de perda do PA И igual ou menor que a produzida
	//EntЦo nЦo possui saldo pois produziu e requisitou no mesmo apontamento
	If nQtdSD3 >= nQtdPerd
		lRet := .T.
	EndIf

	//'Identifica se o sistema permitirА que os saldos em estoque dos produtos fique negativo atravИs de movimentaГЦo.'
	IF !lESTNEG .AND. lRet
		If (SaldoMov(Localiza(SD3->D3_COD,.T.),Nil,Nil,A250PARTERC()==1,Nil,Nil,Nil,SD3->D3_EMISSAO) - nQtdSD3) < 0
			lRet := .F.
			Return lRet
		EndIf
	ENDIF

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} a250Empsed
FunГЦo para validar se hА empenhos com lote e sem endereГo

@author Michelle Ramos
@since 14/03/2018
@version P12
/*/
//-------------------------------------------------------------------
Function a250Empsed()
	Local lRet	:= .T.
	Local i128	:= 0
	Local i129	:= 0
	Local aLoteEnder  := {}
	Local dPercApont := 0
	Local dTotMov := 0
	Default cD3op 	 := ""
	Default cD3Quant := 0

	If !__lAutomacao
		cD3op    := M->D3_OP
		cD3Quant := M->D3_QUANT
	EndIf

	SD4->(dbSetOrder(2))
	SDC->(dbSetOrder(2))
	SD4->(dbSeek(xFilial("SD4")+cD3op))
	Do While !SD4->(Eof()) .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cD3op

		i128 := Ascan(aLoteEnder,{|x| x[1]=="128" .And. x[2]==SD4->D4_COD})
		If i128 == 0
			aAdd(aLoteEnder,{"128",SD4->D4_COD,0,SD4->D4_QTDEORI,0,.F.})
		Else
			aLoteEnder[i128][4] += SD4->D4_QTDEORI
		EndIf

		/*i129 := Ascan(aLoteEnder,{|x| x[1]=="129" .And. x[2]==SD4->D4_COD})
		If i129 == 0
			aAdd(aLoteEnder,{"129",SD4->D4_COD,0,SD4->D4_QTDEORI,0,.F.})
		Else
			aLoteEnder[i129][4] += SD4->D4_QTDEORI
		EndIf*/

		If Rastro(SD4->D4_COD) .And. Localiza(SD4->D4_COD)

			IF ! EMPTY(SD4->D4_LOTECTL) // VERIFICA SE TEM LOTE E NAO TEM ENDEREгO

				IF SDC->(dbSeek(xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+SD4->D4_LOTECTL)) == .F.
					i128 := Ascan(aLoteEnder,{|x| x[1]=="128" .And. x[2]==SD4->D4_COD})
					If i128 == 0
						aAdd(aLoteEnder,{"128",SD4->D4_COD,SD4->D4_QUANT,0,0,.T.})
					Else
						aLoteEnder[i128][3] += SD4->D4_QUANT
					EndIf
					If aLoteEnder[i128][5] == 0
						aLoteEnder[i128][5] := aLoteEnder[i128][4] - aLoteEnder[i128][3]
						aLoteEnder[i128][6] := .T.
					EndIf
				EndIf

			/*Else //VERIFICA SE NAO TEM LOTE E TEM ENDEREгO

				IF SDC->(dbSeek(xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP))
					i129 := Ascan(aLoteEnder,{|x| x[1]=="129" .And. x[2]==SD4->D4_COD})
					If i129 == 0
						aAdd(aLoteEnder,{"129",SD4->D4_COD,SD4->D4_QUANT,0,0,.T.})
					Else
						aLoteEnder[i129][3] += SD4->D4_QUANT
					EndIf
					If aLoteEnder[i129][5] == 0
						aLoteEnder[i129][5] := aLoteEnder[i129][4] - aLoteEnder[i129][3]
						aLoteEnder[i129][6] := .T.
					EndIf
				EndIf*/

			ENDIF

		Endif
		SD4->(dbSkip())
	EndDo

	//a validaГЦo serА feita somente atИ encontrar uma SD4 inconsistente
	//se o saldo de registros anteriores for suficiente, libera.
	//caso contrАrio barra, pois posteriormente a leitura seguira o mesmo indice e darА problema.

	SD3->(dbSetOrder(1))
	SD3->(dbSeek(xFilial("SD3")+cD3op))
	Do While !SD3->(Eof())
		If Alltrim(SD3->D3_CF) $ "PR0/PR1"	//-- Producoes
			dTotMov += SD3->D3_QUANT
		EndIf
		SD3->(dbSkip())
	EndDo

	dTotMov += cD3Quant

	dPercApont := (dTotMov * 100) / SC2->C2_QUANT //percentual que esta sendo apontado
	If Ascan(aLoteEnder,{|x| x[1]=="128" .And. (dPercApont * x[4]) / 100 > x[5] .And. x[6] == .T. })
		lRet := .F.
		Help(,, 'MATA250',, STR0128,1,0 ) //Existem componentes com controle de lote e endereГo,  porИm somente o lote foi empenhado. Para efetuar o apontamento, o endereГo tambИm deve estar empenhado.
	EndIf
	/*If Ascan(aLoteEnder,{|x| x[1]=="129" .And. (dPercApont * x[4]) / 100 > x[5] .And. x[6] == .T. })
		lRet := .F.
		Help(,, 'MATA250',,STR0129,1,0 ) //Existem componentes com controle de lote e endereГo,  porИm somente o lote foi empenhado. Para efetuar o apontamento, o endereГo tambИm deve estar empenhado.
	EndIf*/

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} a250QtdNec
FunГЦo para calcular a quantidade para requisitar com base na
quantidade necessАria

@param nQtAtual, nQtProd, nQtdGanho
@return nQtd

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
Static Function a250QtdNec(nQtAtual, nQtProd, nQtdGanho, nQtdMaior, cParcTot)
	Local lExiste := .F.
	Local lReqNec := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
	Local nQtd    := 0

	If cParcTot == 'T' .And. nQtdGanho == 0 .And. nQtdMaior == 0
		Return nQtAtual
	EndIf

	If cParcTot == 'P' .And. (nQtProd == SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)) .And. nQtdGanho == 0 .And. nQtdMaior == 0
		Return nQtAtual
	EndIF

	If !lReqNec
		Return nQtAtual
	EndIf

	lExiste := a250EmpOP(SD4->D4_OP, SD4->D4_COD, SD4->D4_TRT)

	If lExiste
		Return nQtAtual
	EndIf

	If !(SD4->(FieldPos('D4_QTNECES')) > 0)
		Return nQtAtual
	EndIf

	If SD4->D4_QTNECES > 0
		If nQtdGanho > 0
			nQtProd -= nQtdGanho
		EndIf

		nQtd := nQtProd * SD4->D4_QTNECES
		nQtd := A250CalcD4(nQtd, 1,'P',,.F.)
	Else
		nQtd := nQtAtual
	EndIF

Return nQtd

//-------------------------------------------------------------------
/*/{Protheus.doc} a250QtdNec
FunГЦo para verificar se o componente estА parametrizado para
requisitar com base na quantidade necessАria

@param
@return lRet

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
Static Function a250VeQtNe(cParcTot, nQtProd, nQtdGanho, nQtdMaior)
	Local lExiste := .F.
	Local lReqNec := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
	Local lRet    := .F.

	If cParcTot == 'T' .And. nQtdGanho == 0 .And. nQtdMaior == 0
		Return lRet
	EndIf

	If cParcTot == 'P' .And. (nQtProd == SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)) .And. nQtdGanho == 0 .And. nQtdMaior == 0
		Return lRet
	EndIF

	If !lReqNec
		Return lRet
	EndIf

	If !(SD4->(FieldPos('D4_QTNECES')) > 0)
		Return lRet
	EndIf

	lExiste := a250EmpOP(SD4->D4_OP, SD4->D4_COD, SD4->D4_TRT)

	If lExiste
		Return lRet
	EndIf

	If SD4->D4_QTNECES > 0
		lRet = .T.
	EndIF

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} a250EmpOP
FunГЦo para verificar se existe empenho com saldo e op intermediАria
Se existir nЦo deve entra na regra da quantidade necessАria.

@param
@return lExiste

@author  Michele Girardi
@version P12
@since   30/09/2022
/*/
//-------------------------------------------------------------------
Function a250EmpOP(cOp, cProdSD4, cTrtSD4)

Local aAreaSd4   := SD4->(GetArea()) 
Local cAliasD4   := GetNextAlias()
Local cQuery     := ''
Local lExiste    := .F.

 //michele-

cQuery := " SELECT COUNT(1) NCOUNT "
cQuery += "   FROM " + RetSqlName("SD4") + " SD4 "
cQuery += "  WHERE SD4.D4_FILIAL  = '" + xFilial("SD4") + "' "
cQuery += "    AND SD4.D_E_L_E_T_ = ' ' "				
cQuery += "    AND SD4.D4_OP      = '" + cOp + "' "
cQuery += "    AND SD4.D4_COD    = '" + cProdSD4 + "' "
cQuery += "    AND SD4.D4_TRT    = '" + cTrtSD4 + "' "
cQuery += "    AND SD4.D4_OPORIG  <> ' ' "
cQuery += "    AND EXISTS ( SELECT 1  "
cQuery += "                   FROM " + RetSqlName("SD4") + " SD41 "
cQuery += "                  WHERE SD41.D4_FILIAL  = '" + xFilial("SD4") + "' "
cQuery += "                    AND SD41.D_E_L_E_T_ = ' ' "
cQuery += "                    AND SD41.D4_OP      = SD4.D4_OP "
cQuery += "                    AND SD41.D4_COD     = SD4.D4_COD "
cQuery += "                    AND SD41.D4_TRT     = SD4.D4_TRT "
cQuery += "                    AND SD41.D4_OPORIG  = ' ' ) " 

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasD4,.T.,.T.)

While (cAliasD4)->(!Eof())
					
	If (cAliasD4)->NCOUNT > 0
		lExiste := .T.
	EndIf
					
	(cAliasD4)->(dbSkip())
EndDo

(cAliasD4)->(dbCloseArea())

RestArea(aAreaSd4)

Return lExiste

//-------------------------------------------------------------------
/*/{Protheus.doc} a250QtLote
FunГЦo para calcular a qtd de lote empenhado

@param
@return lQtdLote

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
Function a250QtLote(cOp, cCOD, cTRT)
	Local lQtdLote := 0
	Local aAreaSD4 := SD4->(GetArea())

	dbSelectArea("SD4")
	dbSetOrder(1)
	dbGoTop()
	dbSeek(xFilial("SD4")+cCOD+cOp+cTRT)
	While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT) == (xFilial("SD4")+cCOD+cOp+cTRT)
		If SD4->D4_QUANT > 0
			lQtdLote += 1
		EndIf
		dbSkip()
	End

	SD4->(RestArea(aAreaSD4))

Return lQtdLote

//-------------------------------------------------------------------
/*/{Protheus.doc} a250VeQtN1

@param
@return lRet

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
Function a250VeQtN1(cProduto)
	Local lRet := .F.
	Local lReqNec  := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
	Local aAreaSB1 := SB2->(GetArea())

	If lReqNec
		If SB1->(dbSeek(xFilial("SB1")+cProduto))
			If SB1->B1_TIPODEC == "I"
				lRet := .T.
			EndIf
		EndIf
	EndIf

	SB1->(RestArea(aAreaSB1))
Return lRet

/*/{Protheus.doc} a250GrvPnd
//FunГЦo para gravar tabela de apontamentos pendentes
@author Gustavo Baptista
@since 08/04/2019
/*/
Function a250GrvPnd(aAuto,cRot, cMsg)

	Local lRet 	   := .T.
	Local nPos	   := 0
    Local cAutoStr := ""
    Local aCposSh6 := {}
    Local aCposSd3 := {}
    Local nc       := 0
    DEFAULT crot   := "MATA250"
    DEFAULT cMsg   := ""

    cAutoStr := FWJsonSerialize(aAuto,.F.,.F.) //transforma Array em Json para gravar no campo memo

    IF crot == 'MATA250'
        cSeq := GETSXENUM("T4K","T4K_SEQ")
        aadd(aCposSd3, {"D3_TM"			,"C_TM"			})
        aadd(aCposSd3, {"D3_COD"		,"C_COD"		})
        aadd(aCposSd3, {"D3_UM"			,"C_UM"			})
        aadd(aCposSd3, {"D3_QUANT"		,"C_QUANT"		})
        aadd(aCposSd3, {"D3_OP"			,"C_OP"			})
        aadd(aCposSd3, {"D3_LOCAL" 		,"C_LOCAL"		})
        aadd(aCposSd3, {"D3_DOC"		,"C_DOC"		})
        aadd(aCposSd3, {"D3_EMISSAO"	,"C_EMISSAO"	})
        aadd(aCposSd3, {"D3_PARCTOT"	,"C_PARCTOT"	})
        aadd(aCposSd3, {"D3_PERDA" 		,"C_PERDA"		})

        FOR NC := 1 TO LEN(aCposSd3)
            nPos := 0
            nPos := aScan(aAuto,{|x| x[1] == aCposSd3[NC][1] })
            IF nPos > 0
                &(aCposSd3[NC][2]) := aAuto[nPos,2]
            Else
                &(aCposSd3[NC][2]) := CriaVar(aCposSd3[NC][1], .T.)
            Endif
        NEXT NC

        dbselectarea("T4K")
        RecLock("T4K",.T.)
            REPLACE T4K->T4K_FILIAL 	WITH XFILIAL("T4K")
            REPLACE T4K->T4K_SEQ 		WITH cSeq
            REPLACE T4K->T4K_TM			WITH C_TM
            REPLACE T4K->T4K_COD		WITH C_COD
            REPLACE T4K->T4K_UM			WITH C_UM
            REPLACE T4K->T4K_QUANT		WITH C_QUANT
            REPLACE T4K->T4K_OP 		WITH C_OP
            REPLACE T4K->T4K_LOCAL		WITH C_LOCAL
            REPLACE T4K->T4K_DOC        WITH C_DOC
            REPLACE T4K->T4K_EMISSA		WITH C_EMISSAO
            REPLACE T4K_PARCTO          WITH c_PARCTOT
            REPLACE T4K_PERDA           WITH C_PERDA
            REPLACE T4K->T4K_STRAUT		WITH cAutoStr
            REPLACE T4K->T4K_ORIGEM		WITH cRot
            REPLACE T4K->T4K_DATA		WITH dDataBase
            REPLACE T4K->T4K_HORA       WITH SubStr(time(),1,5)
            REPLACE T4K->T4K_USER 		WITH IIF(EMPTY(cUserName), "ROTAUT",cUserName)
            REPLACE T4K->T4K_MENSAG 	WITH cMsg
            REPLACE T4K->T4K_STATUS 	WITH "1"
        T4K->(MSUNLOCK())
        ConfirmSX8()


    ElseIF cRot == 'MATA681' .OR. cRot == 'MATA680' .OR. cRot == "ACDA080"
        cSeq := GETSXENUM("T4K","T4K_SEQ")

        // Procura as posicoes dos campos no Array da Rotina automatica
        aadd(aCposSh6, {"H6_PRODUTO" ,"c_PRODUTO"	})
        aadd(aCposSh6, {"H6_QTDPROD" ,"c_QTDPROD"	})
        aadd(aCposSh6, {"H6_OP" 	 ,"c_OP"		})
        aadd(aCposSh6, {"H6_LOCAL" 	 ,"c_LOCAL"		})
        aadd(aCposSh6, {"H6_DTAPONT" ,"c_DTAPONT"	})
        aadd(aCposSh6, {"H6_LOTECTL" ,"c_LOTECTL"	})
        aadd(aCposSh6, {"H6_DTVALID" ,"c_DTVALID"	})
        aadd(aCposSh6, {"H6_NUMLOTE" ,"c_NUMLOTE"	})
        aadd(aCposSh6, {"H6_REVI" 	 ,"c_REVI"		})
        aadd(aCposSh6, {"H6_OPERAC"  ,"c_OPERAC"	})
        aadd(aCposSh6, {"H6_RECURSO" ,"c_RECURSO"	})
        aadd(aCposSh6, {"H6_FERRAM"  ,"c_FERRAM"	})
        aadd(aCposSh6, {"H6_DATAINI" ,"c_DATAINI"	})
        aadd(aCposSh6, {"H6_HORAINI" ,"c_HORAINI"	})
        aadd(aCposSh6, {"H6_DATAFIN" ,"c_DATAFIN"	})
        aadd(aCposSh6, {"H6_HORAFIN" ,"c_HORAFIN"	})
        aadd(aCposSh6, {"H6_PT"      ,"c_PT"    	})
        aadd(aCposSh6, {"H6_QTDPERD" ,"C_QTDPERD"	})

       //Seta valores para variaveis, de acordo com os campos do MATA681 - SH6
        FOR NC := 1 TO LEN(aCposSh6)
            nPos := 0
            nPos := aScan(aAuto,{|x| x[1] == aCposSh6[NC][1] })
            IF nPos > 0
                &(aCposSh6[NC][2]) := aAuto[nPos,2]
            Else
                &(aCposSh6[NC][2]) := CriaVar(aCposSh6[NC][1], .T.)
            Endif
        NEXT NC

        Dbselectarea("T4K")
        RecLock("T4K",.T.)
            REPLACE T4K->T4K_FILIAL 	WITH XFILIAL("T4K")
            REPLACE T4K->T4K_SEQ 		WITH cSeq
            REPLACE T4K->T4K_COD		WITH c_PRODUTO
            REPLACE T4K->T4K_QUANT		WITH c_QTDPROD
            REPLACE T4K->T4K_OP 		WITH c_OP
            REPLACE T4K->T4K_LOCAL		WITH c_LOCAL
            REPLACE T4K->T4K_EMISSA		WITH c_DTAPONT
            REPLACE T4K->T4K_LOTECT		WITH c_LOTECTL
            REPLACE T4K->T4K_DTVALI		WITH c_DTVALID
            REPLACE T4K->T4K_NUMLOT		WITH c_NUMLOTE
            REPLACE T4K->T4K_REVISA		WITH c_REVI
            REPLACE T4K->T4K_OPERAC		WITH c_OPERAC
            REPLACE T4K->T4K_RECURS		WITH c_RECURSO
            REPLACE T4K->T4K_FERRAM		WITH c_FERRAM
            REPLACE T4K->T4K_DATAIN		WITH c_DATAINI
            REPLACE T4K->T4K_HORAIN		WITH c_HORAINI
            REPLACE T4K->T4K_DATAFI		WITH c_DATAFIN
            REPLACE T4K->T4K_HORAFI		WITH c_HORAFIN
            REPLACE T4K_PARCTO          WITH c_PT
            REPLACE T4K_PERDA           WITH C_QTDPERD
            REPLACE T4K->T4K_STRAUT		WITH cAutoStr
            REPLACE T4K->T4K_ORIGEM		WITH cRot
            REPLACE T4K->T4K_DATA		WITH dDataBase
            REPLACE T4K->T4K_HORA       WITH SubStr(time(),1,5)
            REPLACE T4K->T4K_USER 		WITH IIF(EMPTY(cUserName), "ROTAUT",cUserName)
            REPLACE T4K->T4K_STATUS 	WITH "1"
            REPLACE T4K->T4K_MENSAG 	WITH cMsg
        T4K->(MSUNLOCK())
        ConfirmSX8()

    ENDIF
Return lRet

/*/{Protheus.doc} RetPerMIt
//FunГЦo para atribuiГЦdo percentual de produГЦ a maior
//por item, que permite customizar o percentual por item
//empenhado (SD4 posicionada)
@author Andre Anjos
@since 19/03/2020
/*/
Static Function RetPerMIt(nPercPrM)
Local nPercPrMIt := nPercPrM

If ExistBlock("A250PRMI")
	If ValType(nPercPrMIt := ExecBlock("A250PRMI",.F.,.F.,{nPercPrM})) <> "N"
		nPercPrMIt := nPercPrM
	EndIf
EndIf

Return nPercPrMIt

/*/{Protheus.doc} RetReqOrig ..
//FunГЦo para retornar que deve requisitar o produto origem na perda
@author Michele Girardi
@since 31/08/2020
/*/
Static Function RetReqOrig()
lReqOrig := .F.

	Pergunte("MTA685",.F.)
	lReqOrig := IIf(mv_par01 == 1, .T. , .F.)
	Pergunte("MTA250",.F.)

Return lReqOrig

/*/{Protheus.doc} RetQtdArred
//FunГЦo para retornar quantidade arredondada para requisiГЦo.
//NЦo arredondar caso Зltima casa decimal seja 5 (ex.: 0,275), para evitar que seja requisitada quantidade maior que a necessАria de MP
@type  Static Function
@author Vivian Beatriz de Almeida Nogueira
@since 03/02/2021
@version P12
@param nQtdArred, numeric, Quantidade a ser arredondada
@param nDecarred, numeric, NЗmero de casas decimais para efetuar o arredondamento
@return nQtdArred
/*/
Static Function RetQtdArred(nQtdArred,nDecArred)  
Local ncontador:= A250contde(nQtdArred)

Default nQtdArred := 0
Default nDecArred := 0

if ncontador > nDecArred
    If round(nQtdArred,nDecArred) - nQtdArred != (0.5 / (10**nDecArred))	
		nQtdArred := round(nQtdArred,nDecArred)
	EndIf
EndIf

Return nQtdArred


/*/{Protheus.doc} fTemLetra
Verifica se existe alguma letra na cadeia de caracteres enviada por parametro
@type  Function
@author rafael.kleestadt
@since 26/04/2021
@version 1.0
@param cString, string, cadeia de caracteres a ser testada
@return lTemLetra, logical, se .t. possui letras na cadeia de caracteres
@example
(examples)
@see https://tdn.totvs.com/x/xYZc
/*/
Function fTemLetra(cString)
Local nX        := 0
Local lTemLetra := .F.

	While nX <= Len(cString)
		If !IsDigit(Substr(cString,nX,1))
			lTemLetra := .T.
			Exit
		EndIf
		nX ++			
	EndDo

Return lTemLetra


/*/{Protheus.doc} fArrayAuto
Carrega o array aArrayAuto com informaГУes do apontamento automАtico
@type  Function
@author Michele Girardi
@since 25/05/2021
@version 1.0
@param dEmissao, aArraySD4, aArrayAuto, cOp
@return nil
/*/
Static Function fArrayAuto(dEmissao,aArraySD4,aArrayAuto,cOp)

Local cCompara     := ''
Local cComparaSB8  := ''
Local cSeek        := ''
Local cSeekSB8     := ''
Local lEmpPrev     := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lSeekSDC     := .F.
Local nI           := 0
Local nQuantDC     := 0
Local nSaldo       := 0
Local nZ           := 0

Default aArraySD4  := {}
Default aArrayAuto := {}
Default cOp        := ''
Default dEmissao   := dDataBase

If Empty(aArraySD4) .Or. Empty(dEmissao)
	Return Nil
EndIf

For nI:=1 to Len(aArraySD4)
	For nZ:=1 to Len(aArraySD4[nI])
		If !Empty(aArraySD4[nI,nZ,6])
			AADD(aArrayAuto,{aArraySD4[nI,nZ,3],aArraySD4[nI,nZ,4],aArraySD4[nI,nZ,5],.T.,.F.,.F.,0,aArraySD4[nI,nZ,2],.F.,aArraySD4[nI,nZ,9], .F.})
		Else
			AADD(aArrayAuto,{aArraySD4[nI,nZ,3],aArraySD4[nI,nZ,4],aArraySD4[nI,nZ,5],.F.,.F.,.F.,0,aArraySD4[nI,nZ,2],.F.,aArraySD4[nI,nZ,9], .F.})
		EndIf
	Next nZ
Next nI

// Para os que possuem apontamento automatico ver se existe registro para baixar o saldo
For nI:=1 to Len(aArrayAuto)
	If aArrayAuto[nI,4] == .T. //Possui apontamento automАtico 
		For nZ:=1 to Len(aArrayAuto) // Procurar no array se existe um registro de saldo para o mesmo produto/local/trt
			If aArrayAuto[nI,1] == aArrayAuto[nZ,1] .And.; // Produto
				aArrayAuto[nI,2] == aArrayAuto[nZ,2] .And.; // Local
				aArrayAuto[nI,3] == aArrayAuto[nZ,3] .And.; // TRT
				aArrayAuto[nZ,4] == .F. //NЦo possui apontamento automАtico - Registro de Saldo
								
				aArrayAuto[nI,5] := .T. //И referente a apontamento automАtico e possui um registro para baixar saldo
				aArrayAuto[nZ,6] := .T. //И referente ao registro com saldo e que possui apontamento automАtico

				If Rastro(aArrayAuto[nZ,1])					
					nSaldo := 0
					dbSelectArea("SB8")
					dbSetOrder(3)

					If Empty(aArrayAuto[nZ,10])
						cSeekSB8:=xFilial("SB8")+aArrayAuto[nZ,1]+aArrayAuto[nZ,2]
						cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL"
				
						SB8->(dbSeek(cSeekSB8))
						Do While !Eof() .And. cSeekSB8 == &(cComparaSB8)
							If dEmissao > dDataBase
								nSaldo+=SB8Saldo(,,,,,lEmpPrev,,dEmissao)
							Else
								nSaldo+=SB8Saldo(,,,,,lEmpPrev,,dDataBase)
							EndIf
							SB8->(dbSkip())						
						EndDo

						nSaldo := MIN(nSaldo,aArrayAuto[nZ,8])

						aArrayAuto[nI,7] := nSaldo
						aArrayAuto[nZ,7] := aArrayAuto[nI,7] //Referente ao registro de saldo	
					Else
						aArrayAuto[nI,11] := .T.
						aArrayAuto[nZ,11] := .T. //Referente ao registro de saldo	
					ENDIF			
				Else
					If Localiza(aArrayAuto[nZ,1])
						lSeekSDC:=.F.
						dbSelectArea("SDC")
						dbSetOrder(2)
						cSeek:=xFilial("SDC")+aArrayAuto[nZ,1]+aArrayAuto[nZ,2]+PADR(cOp,tamSX3('DC_OP')[1])+aArrayAuto[nZ,3]						
						cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"						
						lSeekSDC:= SDC->(dbSeek(cSeek))
						nQuantDC:=0
						If lSeekSDC							
							Do While !Eof() .And. cSeek == &cCompara
								lSeekSDC := .T.
								nQuantDC += SDC->DC_QUANT
								SDC->(dbSkip())
							EndDo
						EndIf

						If lSeekSDC == .F.
							nQuantDC:=SaldoSBF(aArrayAuto[nZ,2],"",aArrayAuto[nZ,1],"","","",NIL,NIL,NIL)
						EndIf

						nQuantDC := MIN(nQuantDC,aArrayAuto[nZ,8])

						aArrayAuto[nI,7] := nQuantDC
						aArrayAuto[nZ,7] := aArrayAuto[nI,7] //Referente ao registro de saldo
					Else				
						//Busca saldo em estoque para esse componente
						nSaldo := 0
						SB2->(dbSeek(xFilial("SB2")+aArrayAuto[nZ,1]+aArrayAuto[nZ,2]))
						SB1->(dbSeek(xFilial("SB1")+aArrayAuto[nZ,1]))

						nSaldo := SaldoMov(Nil,.F.,Nil,A250PARTERC()==1,Nil,Nil,Nil,dEmissao)
						nSaldo := MIN(nSaldo,aArrayAuto[nZ,8])

						aArrayAuto[nI,7] := nSaldo //Referente ao registro do apontamento automatico
						aArrayAuto[nZ,7] := aArrayAuto[nI,7] //Referente ao registro de saldo
					EndIf 
				EndIf 
			EndIf
		Next nZ
	EndIf 
Next nI

For nI:=1 to Len(aArrayAuto)
	If aArrayAuto[nI,4] == .F. .AND. aArrayAuto[nI,11] == .F. //NЦo Possui apontamento automАtico 
		If aArrayAuto[nI,7] == 0 // NЦo foi calculado saldo em estoque para produto que nЦo possui produГЦo automАtica
			aArrayAuto[nI,9] := .T. //Indica q nao possui produГЦo automАtica - somente saldo em estoque
			
			If IsProdMod(aArrayAuto[nI,1]) 
				nSaldo := aArrayAuto[nI,8]
				aArrayAuto[nI,7] := nSaldo
			ELSE
				If Rastro(aArrayAuto[nI,1])
					nSaldo := 0
					dbSelectArea("SB8")
					dbSetOrder(3)
				
					If Empty(aArrayAuto[nI,10])
						cSeekSB8:=xFilial("SB8")+aArrayAuto[nI,1]+aArrayAuto[nI,2]
						cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL"				
				
						SB8->(dbSeek(cSeekSB8))
						Do While !Eof() .And. cSeekSB8 == &(cComparaSB8)
							If dEmissao > dDataBase
								nSaldo+=SB8Saldo(,,,,,lEmpPrev,,dEmissao)
							Else
								nSaldo+=SB8Saldo(,,,,,lEmpPrev,,dDataBase)
							EndIf
							SB8->(dbSkip())						
						EndDo

						nSaldo := MIN(nSaldo,aArrayAuto[nI,8])

						aArrayAuto[nI,7] := nSaldo
					ELSE
						aArrayAuto[nI,7] := aArrayAuto[nI,8]
					ENDIF
				Else
					If Localiza(aArrayAuto[nI,1])
						lSeekSDC:=.F.
						dbSelectArea("SDC")
						dbSetOrder(2)
						cSeek:=xFilial("SDC")+aArrayAuto[nI,1]+aArrayAuto[nI,2]+PADR(cOp,tamSX3('DC_OP')[1])+aArrayAuto[nI,3]						
						cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"						
						lSeekSDC:= SDC->(dbSeek(cSeek))
						nQuantDC:=0
						If lSeekSDC							
							Do While !Eof() .And. cSeek == &cCompara
								lSeekSDC := .T.
								nQuantDC += SDC->DC_QUANT
								SDC->(dbSkip())
							EndDo
						EndIf

						If lSeekSDC == .F.
							nQuantDC:=SaldoSBF(aArrayAuto[nI,2],"",aArrayAuto[nI,1],"","","",NIL,NIL,NIL)
						EndIf

						nQuantDC := MIN(nQuantDC,aArrayAuto[nI,8])

						aArrayAuto[nI,7] := nQuantDC
					Else				
						//Busca saldo em estoque para esse componente
						nSaldo := 0
						SB2->(dbSeek(xFilial("SB2")+aArrayAuto[nI,1]+aArrayAuto[nI,2]))
						SB1->(dbSeek(xFilial("SB1")+aArrayAuto[nI,1]))

						nSaldo := SaldoMov(Nil,.F.,Nil,A250PARTERC()==1,Nil,Nil,Nil,dEmissao)
						nSaldo := MIN(nSaldo,aArrayAuto[nI,8])

						aArrayAuto[nI,7] := nSaldo //Referente ao registro do apontamento automatico
					ENDIF
				EndIf 
			ENDIF
		ENDIF
	ENDIF
NEXT nI 

Return Nil

/*/{Protheus.doc} fSaldoAAuto
Retorna o saldo do Array do produto que tambИm possui apontamento automАtico
@type  Function
@author Michele Girardi
@since 25/05/2021
@version 1.0
@param nI, nZ, aArraySD4, aArrayAuto, lDesProd, lEstAut
@return nQuantEst
/*/
Static Function fSaldoAAuto(nI, nZ, aArraySD4,aArrayAuto,lDesProd,lEstAut)

Local lExistEst := .F.
Local nAchou    := 0
Local nQuantEst := 0
Local nQuantPrd := 0
Local nX        := 0
Local nY        := 0

Default aArraySD4  := {}
Default aArrayAuto := {}
Default lDesProd   := .F.
Default lEstAut    := .F. 
Default nI := 0
Default nZ := 0

If Empty(aArrayAuto) .Or. Empty(aArraySD4)
	Return nQuantEst
EndIf

If aArrayAuto[nZ,6] == .T. .And. aArrayAuto[nZ,5] == .F.
	For nY:=1 to Len(aArrayAuto)
		If aArrayAuto[nY,6] == .T. .And. aArrayAuto[nY,5] == .F.
			If aArrayAuto[nY,1] == aArraySD4[nI,nZ,3] .And.;
				aArrayAuto[nY,2] == aArraySD4[nI,nZ,4] .And.;
				aArrayAuto[nY,3] == aArraySD4[nI,nZ,5]

				nQuantPrd := 0
				/*If lDesProd .And. !Rastro(aArrayAuto[nY,1])	.And. !Localiza(aArrayAuto[nY,1])				
					nAchou := aScan(aProdAuto,{|nX| nX[1] == aArrayAuto[nY,1] .And. nX[2] == aArrayAuto[nY,2] .And. nX[3] == aArrayAuto[nY,3] .And. nX[5] == aArraySD4[nI,nZ,11]})
					If nAchou == 0
						nQuantPrd := 0
					Else
						nQuantPrd := aProdAuto[nAchou, 6]
					EndIf 										
				EndIf*/
										
				lExistEst := .T.	
				nQuantEst := aArrayAuto[nY,7] - nQuantPrd
				Exit
			EndIf
		EndIf
	Next nY
EndIf

If !lExistEst .And. lEstAut
	nQuantEst := aArraySD4[nI,nZ,7]
Else
	If !lExistEst
		nAchou := aScan(aArrayAuto,{|nX| nX[1] == aArraySD4[nI,nZ,3] .And. nX[2] == aArraySD4[nI,nZ,4] .And. nX[3] == aArraySD4[nI,nZ,5] .And. nX[4] == .F. .And. nX[5] == .F. .And. nX[6] == .F. .And. nX[9] == .F.})
		If nAchou > 0
			nQuantEst := aArraySD4[nI,nZ,7]
		ELSE
			nAchou := aScan(aArrayAuto,{|nX| nX[1] == aArraySD4[nI,nZ,3] .And. nX[2] == aArraySD4[nI,nZ,4] .And. nX[3] == aArraySD4[nI,nZ,5] .And. nX[4] == .F. .And. nX[5] == .F. .And. nX[6] == .F. .And. nX[9] == .T. .And. nX[10] == aArraySD4[nI,nZ,9]})
			If nAchou > 0
				nQuantEst := aArrayAuto[nZ,7]
			ENDIF
		EndIf
	EndIf 
EndIf

Return nQuantEst
	
/*/{Protheus.doc} fCalcSaldo
Carrega o saldo no array aEmpSaldo para o produto que possui apontamento automАtico e saldo em estoque
@type  Function
@author Michele Girardi
@since 25/05/2021
@version 1.0
@param cOp, nTamOP, nNivel, dEmissao
@return nil
/*/
Static Function fCalcSaldo(cOp, nTamOP,nNivel,dEmissao)
Local cCompara    := ''
Local cComparaSB8 := ''
Local cSeek       := ''
Local cSeekSB8    := ''
Local lEmpPrev    := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lSeekSDC    := .F.
Local nQuantDC    := 0
Local nSaldo      := 0
Local nRecnoD4    := 0

Default aEmpSaldo := {}
Default cOp       := ' '
Default nTamOP    := 0
Default nNivel    := 0
Default dEmissao  := dDataBase

	dbSelectArea("SD4")
	dbSetOrder(2)
	SD4->(dbSeek(xFilial("SD4")+cOp))
	Do While !Eof() .And. xFilial("SD4")+cOp == SD4->D4_FILIAL+Substr(SD4->D4_OP,1,nTamOP)
		
		nRecnoD4 := SD4->(Recno())

		If Empty(SD4->D4_LOTECTL) .And. SD4->D4_QUANT > 0
			If Empty(SD4->D4_OPORIG)
				If IsProdMod(SD4->D4_COD)
					nSaldo := SD4->D4_QUANT
					AADD(aEmpSaldo,{nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_OPORIG, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, nSaldo,.F. })
				Else
					If Rastro(SD4->D4_COD)
						nSaldo := 0
						dbSelectArea("SB8")
						dbSetOrder(3)
						cSeekSB8:=xFilial("SB8")+SD4->D4_COD+SD4->D4_LOCAL
						cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL"
				
						SB8->(dbSeek(cSeekSB8))
						Do While !Eof() .And. cSeekSB8 == &(cComparaSB8)
							If dEmissao > dDataBase
								nSaldo+=SB8Saldo(,,,,,lEmpPrev,,dEmissao)
							Else
								nSaldo+=SB8Saldo(,,,,,lEmpPrev,,dDataBase)
							EndIf
							SB8->(dbSkip())						
						EndDo

						nSaldo := MIN(nSaldo,SD4->D4_QUANT)

						AADD(aEmpSaldo,{nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_OPORIG, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, nSaldo,.F. })
					Else
						If Localiza(SD4->D4_COD)
							dbSelectArea("SDC")
							dbSetOrder(2)
							cSeek:=xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT
							cCompara:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"						
							lSeekSDC:= SDC->(dbSeek(cSeek))
							nQuantDC:=0
							lSeekSDC:=.F.
							If lSeekSDC							
								Do While !Eof() .And. cSeek == &cCompara
									lSeekSDC := .T.
									nQuantDC += SDC->DC_QUANT
									SDC->(dbSkip())
								EndDo
							EndIf

							If lSeekSDC == .F.
								nQuantDC:=SaldoSBF(SD4->D4_LOCAL,"",SD4->D4_COD,"","","",NIL,NIL,NIL)
							EndIf

							nQuantDC := MIN(nQuantDC,SD4->D4_QUANT)

							AADD(aEmpSaldo,{nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_OPORIG, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, nQuantDC,.F. })
						Else							
							//Busca saldo em estoque para esse componente
							SB2->(dbSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL))
							SB1->(dbSeek(xFilial("SB1")+SD4->D4_COD))

							nSaldo := SaldoMov(Nil,.F.,Nil,A250PARTERC()==1,Nil,Nil,Nil,dEmissao) //Referente ao registro do apontamento automatico

							nSaldo := MIN(nSaldo,SD4->D4_QUANT)
							AADD(aEmpSaldo,{nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_OPORIG, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, nSaldo,.F. })
						EndIf
					EndIf
				EndIf
			Else
				AADD (aEmpSaldo,{nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_OPORIG, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, SD4->D4_QUANT, .T. })
			EndIf
		Else
			If !Empty(SD4->D4_LOTECTL) .And. SD4->D4_QUANT > 0 
				AADD (aEmpSaldo,{nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_OPORIG, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, SD4->D4_QUANT, .F. })
			EndIf
		EndIf
		
		dbSelectArea("SD4")
		dbSetOrder(2)
		SD4->(MsGoTo(nRecnoD4))
		SD4->(dbSkip())
	EndDo

Return nil 

/*/{Protheus.doc} fRetSldEmp
Retorna o saldo em estoque para o componente
@type  Function
@author Michele Girardi
@since 25/05/2021
@version 1.0
@param nNivel
@return nQuantEst
/*/
Static Function fRetSldEmp(nNivel)

Local nQuantEst := 0
Local nX        := 0

Default nNivel  := 0

For nX := 1 TO Len(aEmpSaldo)
	nNivel := nNivel
	If aEmpSaldo[nX,1] == nNivel .And.; 
		aEmpSaldo[nX,2] == SD4->D4_OP .And.;
		aEmpSaldo[nX,3] == SD4->D4_COD .And.;
		aEmpSaldo[nX,4] == SD4->D4_LOCAL .And.;
		aEmpSaldo[nX,5] == SD4->D4_TRT .And.;
		Empty(aEmpSaldo[nX,7]) .And.;
		aEmpSaldo[nX,10] == .F.
		nQuantEst += aEmpSaldo[nX,9]
	EndIf 
Next nX							  

Return nQuantEst

/*/{Protheus.doc} fCalcQtdNec
Calcula quantidade necessaria do componente
@type  Function
@author Michele Girardi
@since 25/05/2021
@version 1.0
@param cOp, nTamOP, nNivel
@return nil
/*/
Static Function fCalcQtdNec(cOp, nTamOP,nNivel)

Local nAchou    := 0
Local nSaldo    := 0
Local nX        := 0

Default aEmpQtNec := {}
Default cOp       := ''
Default nNivel    := 0
Default nTamOP    := 0

dbSelectArea("SD4")
dbSetOrder(2)
SD4->(dbSeek(xFilial("SD4")+cOp))
Do While !Eof() .And. xFilial("SD4")+cOp == SD4->D4_FILIAL+Substr(SD4->D4_OP,1,nTamOP)
	
	nAchou := aScan(aEmpQtNec,{|nX| nX[1] == nNivel .And.;
							        nX[2] == SD4->D4_OP .And.;
									nX[3] == SD4->D4_COD .And.;
									nX[4] == SD4->D4_LOCAL .And.;
									nX[5] == SD4->D4_TRT})
	
	If nAchou == 0
		AADD(aEmpQtNec, {nNivel,SD4->D4_OP,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_TRT, SD4->D4_QTDEORI, SD4->D4_QUANT,0})
	Else
		aEmpQtNec[nAchou,6] += SD4->D4_QTDEORI
		aEmpQtNec[nAchou,7] += SD4->D4_QUANT
	EndIf
		
	SD4->(dbSkip())
EndDo

dbSelectArea("SC2")
dbSetOrder(1)
If SC2->(dbSeek(xFilial("SC2")+cOp))

	nSaldo := SC2->C2_QUANT - SC2->C2_QUJE - If(lPerdInf,0,SC2->C2_PERDA)

	For nX := 1 to Len(aEmpQtNec)
		If aEmpQtNec[nX,1] == nNivel .And. Trim(aEmpQtNec[nX,2]) == Trim(cOp)
			aEmpQtNec[nX,8] := aEmpQtNec[nX,7]/nSaldo
		EndIf
	Next nX 
EndIf 

Return Nil

/*/{Protheus.doc} fRetQtdNec
Retorna a quantidade necessaria do componente
@type  Function
@author Michele Girardi
@since 25/05/2021
@version 1.0
@param nNivel
@return nQuantNec
/*/
Static Function fRetQtdNec(nNivel)

Local nQuantNec := 0
Local nX        := 0

Default nNivel  := 0

For nX := 1 TO Len(aEmpQtNec)
	If 	aEmpQtNec[nX,1] == nNivel .And.; 
		aEmpQtNec[nX,2] == SD4->D4_OP .And.;
		aEmpQtNec[nX,3] == SD4->D4_COD .And.;
		aEmpQtNec[nX,4] == SD4->D4_LOCAL .And.;
		aEmpQtNec[nX,5] == SD4->D4_TRT 
		

		nQuantNec := aEmpQtNec[nX,8]
	EndIf
Next nX							  

Return nQuantNec

/*/{Protheus.doc} fRetParPrd
Retorna conteЗdo do parБmetro MV_PRODEST
@type  Function
@author Michele Girardi
@since 10/06/2021
@version 1.0
@param cOp - ordem de produГЦo
@return lProdEst
/*/
Static Function fRetParPrd(cOp, cInit)

Local lGanho     := .F.
Local lMaior     := .F.
Local lPrdAuto   := .F.
Local lEstProp   := .F.

Default cInit    := 'N'

If Type("lPrdProp") == "U"
	Private lPrdProp := .F.
EndIf

Static cProc   := ' '

If cInit = 'S'
	cProc   := ' '
	Return .F.
EndIf 

//MV_ESTPROP - ParБmetro que indica se a validaГЦo do saldo disponМvel no estoque serА proporcional ou nЦo.
//Por padrЦo a validaГЦo serА proporcional - .T. - como sempre foi feito

//SС serА permitido nЦo ser proporcional se possuir produГЦo automАtica e nЦo possuir ganho e produГЦo a maior.
//Quando estiver parametrizado para permitir apontar ganho ou produГЦo a maior, o cАlculo sempre 
//serА feito utilizando a proporГЦo.

If Empty(cProc)	
	lPrdAuto   := SuperGetMV("MV_PRODAUT")
	lGanho     := SuperGetMV("MV_GANHOPR",.F.,.T.)
	lMaior     := SuperGetMV("MV_PERCPRM",.F., 0) > 0

	lPrdAuto := IIF( lPrdAuto, .T., fRetPrdAut(cOp) )

	If !lPrdAuto .Or. lGanho .Or. lMaior
		lEstProp   := .T.
	Else
		lEstProp   := SuperGetMV("MV_ESTPROP",.F.,.T.)
	EndIf

	cProc := IIF(lEstProp,'S','N')
Else
	lEstProp := IIF(cProc=='S',.T.,.F.)
EndIf

lPrdProp := !lEstProp
Return !lEstProp

/*/{Protheus.doc} fGravaSMO
Grava tabela fGravaSMO
Tabela com informaГУes complementares do apontamento
@type Function
@author Michele Girardi
@since 23/09/2021
@version 1.0
@param cIdApon - Id do apontamento - D3_NUMSEQ / H6_IDENT / CYV_NRSQRP
@      cTipo   - Tipo do apontamento - 1-MATA250 / 2-MATA680 / 3-MATA681 / 4-SFC
@return nenhum
/*/
Function fGravaSMO(cIdApon, cTipo)	
	
	Local cProg    := ""	
	Local cUsuario := ""

	Default cIdApon  := ""
	Default cTipo    := ""	

	If !AliasInDic("SMO")
		Return
	EndIf

	If Empty(cIdApon) .Or. Empty(cTipo)
		Return
	EndIf

	If Type("cProgMt250")=="C"
		cProg := cProgMt250
	ElseIf Type("cProgMt681")=="C"
		cProg := cProgMt681
	ElseIf Type("cProgMtSFC")=="C"
		cProg := cProgMtSFC
	EndIf

	If Empty(cProg)
		cProg := FunName()
	EndIf
	
	cUsuario := RetCodUsr()
	
	RecLock("SMO",.T.)
		Replace SMO->MO_FILIAL   With xFilial("SMO"),;
				SMO->MO_IDAPON   With cIdApon,;
				SMO->MO_TIPO     With cTipo,;
				SMO->MO_PROGRAM  With cProg,;
				SMO->MO_CODUSU   With cUsuario
    SMO->(MsUnLock())

Return

/*/{Protheus.doc} fAchoOP
	Verifica se a OP existe. 
	@type  Static Function
	@author maiara.cunhago
	@since 17/12/2021
	@version 1.0
	@param cNumOP, Caractere, traz o cСdifo da OP M->D3_OP
	@return LСgico, retorna se a OP existe 
/*/
Static Function fAchoOP(cNumOp)

	Local   nTam   := TamSx3("C2_NUM")[1]+TamSx3("C2_ITEM")[1]+TamSx3("C2_SEQUEN")[1]

	Default cNumOP := ''

	cNumOP := Substr(cNumOp,1,nTam)

	dbSelectArea("SC2")
	SC2->(dbSetOrder(1))
	If !SC2->(dbseek(xFilial("SC2")+cNumOp))
		HELP(" ",1,"REGNOIS")
		Return .F.
	EndIf 

Return .T.

/*/{Protheus.doc} fValPrdAut
Valida ProduГЦo automАtica por OP
@type Function
@author Michele Girardi
@since 08/06/2021
@version 1.0
@param cOP - Ordem de ProduГЦo a ser apontada
@return LСgico, se permite apontar a OP informada
/*/
Static Function fValPrdAut(cOP)
 
Local aAreaSC2   := SC2->(GetArea())
Local cAlias := ""
Local cQuery := ""
Local cNumOP := ""
Local lRet       := .T.
Local lExisPrdAu := SC2->(FieldPos("C2_PRODAUT")) > 0

If !lExisPrdAu
	Return lRet
EndIf 

If Empty(cOP)
	Return lRet
EndIf

//Se for informada uma OP IntermediАria, buscar a OP PAI e verificar se a OP possui produГЦo automАtica.
//Se a OP PAI possuir produГЦo automАtica nЦo poderА apontar a OP intermediАria separadamente.

SC2->(dbSetOrder(1))
SC2->(dbSeek(xFilial("SC2")+cOP))

cNumOP := SC2->C2_NUM

//Verifica se a OP informada estА marcada como C2_PRODAUT e for OP PAI
//Se estiver marcado - retorna TRUE
If SC2->C2_PRODAUT == "1" .AND. (Empty(SC2->C2_SEQPAI) .OR. SC2->C2_SEQPAI == "000")
	SC2->(RestArea(aAreaSC2))
	Return lRet
EndIf

//Se estiver desmarcado 
//Verificar se o C2_SEQPAI estА em branco ou preenchido com 000
//Indica que И a OP pai e OP pai nЦo aponta via PRODAUT
//Se estiver em branco ou preenchido com 000 - retorna TRUE
If Empty(SC2->C2_SEQPAI) .Or. SC2->C2_SEQPAI == "000"
	SC2->(RestArea(aAreaSC2))
	Return lRet
EndIf 

//Se o C2_SEQPAI possuir valor indica que И uma intermediАria
//Buscar a OP PAI - mesmo C2_NUM com o C2_SEQPAI estА em branco ou preenchido com 000
//Verificar se o C2_PRODAUT da OP PAI estА marcado
//Se estiver marcado nЦo deve permitir apontar a OP intermediАria

cAlias := GetNextAlias()
cQuery := " SELECT Count(*) TOTAL FROM "+RetSqlName('SC2') + " SC2 "
cQuery += "  WHERE SC2.C2_FILIAL  = '"+xFilial("SC2")+"' "
cQuery += "    AND SC2.C2_NUM     = '"+cNumOP+"' "
cQuery += "    AND ( SC2.C2_SEQPAI = ' ' OR SC2.C2_SEQPAI = '000' ) "
cQuery += "    AND SC2.C2_PRODAUT  = '1' " 
cQuery += "    AND SC2.D_E_L_E_T_ = ' ' "

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAlias, .T., .F. )
If (cAlias)->(TOTAL) > 0
	Help(NIL,NIL,'MATA250',NIL,STR0150, 1,0 ) //'Ordem de ProduГЦo informada estА parametrizada como ProduГЦo AutomАtica. NЦo И possМvel realizar o apontamento de uma OP intermediАria com ProduГЦo AutomАtica.'
	lRet := .F.
EndIf 

(cAlias)->(dbCloseArea())

SC2->(RestArea(aAreaSC2))

Return lRet


/*/{Protheus.doc} fRetPrdAut
Retorna conteЗdo do campo C2_PRODAUT
@type  Function
@author Michele Girardi
@since 09/06/2022
@version 1.0
@param cOP - Ordem de ProduГЦo a ser apontada
@return lPrdAut
/*/
Static Function fRetPrdAut(cOP, cInit)

Local aAreaSC2  := ''
Local lExisPrdAu := SC2->(FieldPos("C2_PRODAUT")) > 0
Local lPrdAut := .F.

DEFAULT cInit := 'N'

Static cProcAut := ' '

If cInit == 'S'
	cProcAut := ' '
	Return .F.
EndIf

If !lExisPrdAu
	Return lPrdAut
EndIf 

If Empty(cOP)
	Return lPrdAut
EndIf

If Empty(cProcAut)	

	aAreaSC2   := SC2->(GetArea())

	SC2->(dbSetOrder(1))
	SC2->(dbSeek(xFilial("SC2")+cOP))

	If SC2->C2_PRODAUT == "1"
		cProcAut := '1'
	else
		cProcAut := '2'
	EndIf

	SC2->(RestArea(aAreaSC2))

EndIf 

lPrdAut := IIF(cProcAut=='1',.T.,.F.)

Return lPrdAut

/*/{Protheus.doc} fCompOper
Retorna se existe amarraГЦo de Componente x OperaГЦo
@type  Function
@author Michele Girardi
@since 08/12/2022
@version 1.0
@param cOP - Ordem de ProduГЦo a ser apontada
@return lOperComp
/*/
Static Function fCompOper(cOP)
 
Local aAreaSD4   := SD4->(GetArea())
Local cAlias     := GetNextAlias()
Local cAliAnt1   := Alias()
Local cQuery     := ""
Local lOperComp  := .F.

Default cOP := " "

cQuery := " SELECT Count(*) TOTAL FROM "+RetSqlName('SD4') + " SD4 "
cQuery += "  WHERE SD4.D4_FILIAL  = '"+xFilial("SD4")+"' "
cQuery += "    AND SD4.D4_OP      = '"+cOP+"' "
cQuery += "    AND SD4.D4_OPERAC  <> ' ' " 
cQuery += "    AND SD4.D_E_L_E_T_ = ' ' "

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAlias, .T., .F. )
If (cAlias)->(TOTAL) > 0
	lOperComp := .T.
EndIf 

(cAlias)->(dbCloseArea())

SD4->(RestArea(aAreaSD4))

dbSelectArea(cAliAnt1)

Return lOperComp

/*/{Protheus.doc} fAtuSb8Sbf
Atualiza o empenho da SB8 e SBF quando o apontamento И total e existe Componente x OperaГЦo
@type  Function
@author Michele Girardi
@since 08/12/2022
@version 1.0
@param cOP - Ordem de ProduГЦo a ser apontada
@return nil
/*/
Static Function fAtuSb8Sbf()

Local aAreaSBF   := SBF->(GetArea())
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSDC   := SDC->(GetArea())
Local cAliasBF   := GetNextAlias()
Local cAliasB8   := GetNextAlias()
Local cAliasDC   := GetNextAlias()
Local cQuery     := ""
Local nAtuEmpB8  := 0
Local nAtuEmpBF  := 0
Local nQtAtuDC   := 0
Local nQtd       := 0

//Verificar se controla lote
If Rastro(SD4->D4_COD)
	//Se existir lote na SD4 atualizar o empenho da SB8
	If !Empty(SD4->D4_LOTECTL)

		cQuery := " SELECT R_E_C_N_O_ B8REC "
		cQuery += "   FROM "+RetSqlName('SB8') + " SB8 "
		cQuery += "  WHERE SB8.B8_FILIAL   = '"+xFilial("SB8")+"' "
		cQuery += "    AND SB8.B8_PRODUTO  = '"+ SD4->D4_COD +"' "
		cQuery += "    AND SB8.B8_LOCAL    = '"+ SD4->D4_LOCAL +"' "
		cQuery += "    AND SB8.B8_DTVALID  = '"+ DTOS(SD4->D4_DTVALID)+"' "
		cQuery += "    AND SB8.B8_LOTECTL  = '"+ SD4->D4_LOTECTL +"' "
		cQuery += "    AND SB8.D_E_L_E_T_  = ' ' "

		dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasB8, .T., .F. )
		While !(cAliasB8)->(Eof()) 
		
			SB8->(MsGoto((cAliasB8)->(B8REC)))
			
			nAtuEmpB8 := SB8->B8_EMPENHO
			
			If SB8->B8_EMPENHO >= SD4->D4_SLDEMP 
				nAtuEmpB8 := SD4->D4_SLDEMP 			
			EndIf

			Reclock("SB8",.F.)
				SB8->B8_EMPENHO := SB8->B8_EMPENHO - nAtuEmpB8
			MsUnLock()
		

			(cAliasB8)->(dbSkip())
		EndDo

		(cAliasB8)->(dbCloseArea())
	EndIf
EndIf

//Verificar se controla endereГo
If Localiza(SD4->D4_COD) 

	nQtd := SD4->D4_SLDEMP 

	//Se controlar endereГo verificar se existe a SDC 
	cQuery := " SELECT R_E_C_N_O_ DCREC "
	cQuery += "   FROM "+RetSqlName('SDC') + " SDC "
	cQuery += "  WHERE SDC.DC_FILIAL   = '"+xFilial("SDC")+"' "
	cQuery += "    AND SDC.DC_OP       = '"+ SD4->D4_OP +"' "
	cQuery += "    AND SDC.DC_PRODUTO  = '"+ SD4->D4_COD +"' "
	cQuery += "    AND SDC.DC_LOCAL    = '"+ SD4->D4_LOCAL +"' "
	cQuery += "    AND SDC.DC_TRT      = '"+ SD4->D4_TRT +"' "
	
	If Rastro(SD4->D4_COD)
		cQuery += "    AND SDC.DC_LOTECTL  = '"+ SD4->D4_LOTECTL +"' "
	EndIf
	
	cQuery += "    AND SDC.D_E_L_E_T_  = ' ' "

	dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasDC, .T., .F. )
	While !(cAliasDC)->(Eof()) .And. nQtd > 0 
	
		SDC->(MsGoto((cAliasDC)->(DCREC)))

		//Pode existir N SDC para uma SD4
		//Verificar a quantidade da SDC contra a QTD da SD4
		If SDC->DC_QUANT >= nQtd
			nQtAtuDC = nQtd
		Else
			nQtAtuDC = SDC->DC_QUANT
		EndIf

		nQtd := nQtd - nQtAtuDC

		If nQtAtuDC > 0
			cQuery := " SELECT R_E_C_N_O_ BFREC "
			cQuery += "   FROM "+RetSqlName('SBF') + " SBF "
			cQuery += "  WHERE SBF.BF_FILIAL   = '"+xFilial("SBF")+"' "
			cQuery += "    AND SBF.BF_PRODUTO  = '"+ SDC->DC_PRODUTO +"' "
			cQuery += "    AND SBF.BF_LOCAL    = '"+ SDC->DC_LOCAL +"' "
			cQuery += "    AND SBF.BF_LOCALIZ  = '"+ SDC->DC_LOCALIZ +"' "
		
			If Rastro(SD4->D4_COD)
				cQuery += "    AND SBF.BF_LOTECTL  = '"+ SDC->DC_LOTECTL +"' "
			EndIf 

			cQuery += "    AND SBF.D_E_L_E_T_  = ' ' "

			dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasBF, .T., .F. )
			While !(cAliasBF)->(Eof()) 
			 
				SBF->(MsGoto((cAliasBF)->(BFREC)))

				nAtuEmpBF := SBF->BF_EMPENHO
				
				If SBF->BF_EMPENHO >= nQtAtuDC 
					nAtuEmpBF := nQtAtuDC
				EndIf

				Reclock("SBF",.F.)
					SBF->BF_EMPENHO := SBF->BF_EMPENHO - nAtuEmpBF
				MsUnLock()
		
				(cAliasBF)->(dbSkip())
			EndDo
			(cAliasBF)->(dbCloseArea())	

			Reclock("SDC",.F.)
				SDC->DC_QUANT := SDC->DC_QUANT - nAtuEmpBF
			MsUnLock()						
		EndIf
		(cAliasDC)->(dbSkip())		
	EndDo
	(cAliasDC)->(dbCloseArea())	
EndIf

SBF->(RestArea(aAreaSBF))
SB8->(RestArea(aAreaSB8))
SDC->(RestArea(aAreaSDC))

Return nil

/*/{Protheus.doc} fDesAtB8BF
Atualiza o empenho da SB8 e SBF no estorno de perda anterior quando existe Componente x OperaГЦo
@type  Function
@author Michele Girardi
@since 13/12/2022
@version 1.0
@return nil
/*/
Static Function fDesAtB8BF(nQtdAjus)

Local aAreaSBF   := SBF->(GetArea())
Local aAreaSB2   := SB2->(GetArea())
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSDC   := SDC->(GetArea())
Local cAliasBF   := GetNextAlias()
Local cAliasB2   := GetNextAlias()
Local cAliasB8   := GetNextAlias()
Local cAliasDC   := GetNextAlias()
Local cQuery     := ""
Local nQtAtuDC   := 0
Local nQtd       := 0

//Atualiza SB2
cQuery := " SELECT R_E_C_N_O_ B2REC "
cQuery += "   FROM "+RetSqlName('SB2') + " SB2 "
cQuery += "  WHERE SB2.B2_FILIAL   = '"+xFilial("SB2")+"' "
cQuery += "    AND SB2.B2_COD      = '"+ SD4->D4_COD +"' "
cQuery += "    AND SB2.B2_LOCAL    = '"+ SD4->D4_LOCAL +"' "
cQuery += "    AND SB2.D_E_L_E_T_  = ' ' "

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasB2, .T., .F. )
While !(cAliasB2)->(Eof()) 
		
	SB2->(MsGoto((cAliasB2)->(B2REC)))
			 			
	Reclock("SB2",.F.)
		SB2->B2_QEMP := SB2->B2_QEMP + nQtdAjus
	MsUnLock()
		
	(cAliasB2)->(dbSkip())
EndDo

(cAliasB2)->(dbCloseArea())

//Verificar se controla lote
If Rastro(SD4->D4_COD)
	//Se existir lote na SD4 atualizar o empenho da SB8
	If !Empty(SD4->D4_LOTECTL)

		cQuery := " SELECT R_E_C_N_O_ B8REC "
		cQuery += "   FROM "+RetSqlName('SB8') + " SB8 "
		cQuery += "  WHERE SB8.B8_FILIAL   = '"+xFilial("SB8")+"' "
		cQuery += "    AND SB8.B8_PRODUTO  = '"+ SD4->D4_COD +"' "
		cQuery += "    AND SB8.B8_LOCAL    = '"+ SD4->D4_LOCAL +"' "
		cQuery += "    AND SB8.B8_DTVALID  = '"+ DTOS(SD4->D4_DTVALID)+"' "
		cQuery += "    AND SB8.B8_LOTECTL  = '"+ SD4->D4_LOTECTL +"' "
		cQuery += "    AND SB8.D_E_L_E_T_  = ' ' "

		dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasB8, .T., .F. )
		While !(cAliasB8)->(Eof()) 
		
			SB8->(MsGoto((cAliasB8)->(B8REC)))
			 			
			Reclock("SB8",.F.)
				SB8->B8_EMPENHO := SB8->B8_EMPENHO + nQtdAjus
			MsUnLock()
		
			(cAliasB8)->(dbSkip())
		EndDo

		(cAliasB8)->(dbCloseArea())
	EndIf
EndIf

//Verificar se controla endereГo
If Localiza(SD4->D4_COD) 
	nQtd := nQtdAjus
	//Se controlar endereГo verificar se existe a SDC 
	cQuery := " SELECT R_E_C_N_O_ DCREC "
	cQuery += "   FROM "+RetSqlName('SDC') + " SDC "
	cQuery += "  WHERE SDC.DC_FILIAL   = '"+xFilial("SDC")+"' "
	cQuery += "    AND SDC.DC_OP       = '"+ SD4->D4_OP +"' "
	cQuery += "    AND SDC.DC_PRODUTO  = '"+ SD4->D4_COD +"' "
	cQuery += "    AND SDC.DC_LOCAL    = '"+ SD4->D4_LOCAL +"' "
	cQuery += "    AND SDC.DC_TRT      = '"+ SD4->D4_TRT +"' "
	
	If Rastro(SD4->D4_COD)
		cQuery += "    AND SDC.DC_LOTECTL  = '"+ SD4->D4_LOTECTL +"' "
	EndIf
	
	cQuery += "    AND SDC.D_E_L_E_T_  = ' ' "

	dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasDC, .T., .F. )
	While !(cAliasDC)->(Eof())  .And. nQtd > 0
	
		SDC->(MsGoto((cAliasDC)->(DCREC)))

		//Pode existir N SDC para uma SD4
		//Verificar a quantidade da SDC contra a QTD da SD4
		If (SDC->DC_QTDORIG - SDC->DC_QUANT) >= nQtdAjus
			nQtAtuDC = nQtdAjus 
		Else
			nQtAtuDC = (SDC->DC_QTDORIG - SDC->DC_QUANT)
		EndIf
		
		nQtd := nQtd - nQtAtuDC

		If nQtAtuDC > 0
			cQuery := " SELECT R_E_C_N_O_ BFREC "
			cQuery += "   FROM "+RetSqlName('SBF') + " SBF "
			cQuery += "  WHERE SBF.BF_FILIAL   = '"+xFilial("SBF")+"' "
			cQuery += "    AND SBF.BF_PRODUTO  = '"+ SDC->DC_PRODUTO +"' "
			cQuery += "    AND SBF.BF_LOCAL    = '"+ SDC->DC_LOCAL +"' "
			cQuery += "    AND SBF.BF_LOCALIZ  = '"+ SDC->DC_LOCALIZ +"' "
		
			If Rastro(SD4->D4_COD)
				cQuery += "    AND SBF.BF_LOTECTL  = '"+ SDC->DC_LOTECTL +"' "
			EndIf 

			cQuery += "    AND SBF.D_E_L_E_T_  = ' ' "

			dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasBF, .T., .F. )
			While !(cAliasBF)->(Eof()) 
			 
				SBF->(MsGoto((cAliasBF)->(BFREC)))

				Reclock("SBF",.F.)
					SBF->BF_EMPENHO := SBF->BF_EMPENHO + nQtAtuDC
				MsUnLock()
		
				(cAliasBF)->(dbSkip())
			EndDo
			(cAliasBF)->(dbCloseArea())	

			Reclock("SDC",.F.)
				SDC->DC_QUANT := SDC->DC_QUANT + nQtAtuDC
			MsUnLock()
		EndIf			
		(cAliasDC)->(dbSkip())
	EndDo
	(cAliasDC)->(dbCloseArea())	
EndIf

SBF->(RestArea(aAreaSBF))
SB2->(RestArea(aAreaSB2))
SB8->(RestArea(aAreaSB8))
SDC->(RestArea(aAreaSDC))

Return nil

/*/{Protheus.doc} ExistLote
	FunГЦo que validade se os empenhos possuem lote
	@type  Static Function
	@author maiara.cunhago
	@since 09/02/2023
	@version version
	@param cProduto, Caractere, Produto
	@param cTrt    , Caractere, TRT
	@param cOP     , Caractere, Ordem de ProduГЦo
	@return lRet   , LСgico   , .T. = Existe Lote | .F. - NЦo existe lote
/*/
Static Function ExistLote(cProduto,cTrt,cOP)

Local aAreaSD4   := SD4->(GetArea())
Local cAlias     := GetNextAlias()
Local cQuery := ""
Local lRet   := .F. 

Default cOP := " "
Default cProduto := " "
Default cTrt := " "


cQuery := " SELECT Count(*) TOTAL FROM "+RetSqlName('SD4') + " SD4 "
cQuery += "  WHERE SD4.D4_FILIAL  = '"+xFilial("SD4")+"' "
cQuery += "    AND SD4.D4_OP      = '"+cOP+"' "
cQuery += "    AND SD4.D4_TRT     = '"+cTrt+"' "
cQuery += "    AND SD4.D4_COD     = '"+cProduto+"' "
cQuery += "    AND SD4.D4_LOTECTL  <> ' '  " 
cQuery += "    AND SD4.D_E_L_E_T_ = ' ' "

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAlias, .T., .F. )
If (cAlias)->(TOTAL) > 0
	lRet := .T.
EndIf 

(cAlias)->(dbCloseArea())

SD4->(RestArea(aAreaSD4))

Return lRet

/*/{Protheus.doc} a250ConsDtOp
	FunГЦo que validade se a data И menor que a data da OP
	@type Function
	@author vivian.beatriz
	@since 14/03/2023
	@version version
	@param dDataApon, Date, Data do Apontamento
	@param cOP     , Caractere, Ordem de ProduГЦo
	@return lRet   , LСgico   , .T. = Permite apon | .F. - NЦo permite apon
/*/
Function a250ConsDtOp(dDataApon,cOp)
	Local aAreaSC2 := SC2->(GetArea())
	Local lRet     := .T.
	Local lVerDtOp := SuperGetMV("MV_VERDTOP",.F.,.F.)

	DEFAULT dDataApon := dDataBase
    DEFAULT cOp	      := ""

	If lVerDtOp 
       
	   dbSelectArea("SC2")	
	   SC2->(dbSetOrder(1))
	   SC2->(dbSeek(xFilial("SC2")+cOp))   

	   If dDataApon < SC2->C2_EMISSAO
	      //Mensagem data apontamento menor que a data de emissЦo da OP
	      Help( ,, 'Help',, STR0151, 1, 0 )
	      lRet = .F.
       EndIf

	   SC2->(RestArea(aAreaSC2))
	EndIf

Return lRet

/*/{Protheus.doc} a250GrvLt
	FunГЦo que valida se possui empenho de lote ou endereГo
	@type Function
	@author michele.girardi
	@since 16/05/2023
	@version version
	@param cProd
	@param cLote
	@return lGrvLote,  LСgico
/*/
Static Function a250GrvLt(cProd, cOp, cLocal, cTrt, cLote)

Local cAliasDC := GetNextAlias()
Local cQuery   := ' '
Local lGrvLote := .F.

//NЦo controla lote e nЦo controla endereГo - Retorna FALSE
If !Rastro(cProd,"L") .And. !Localiza(cProd)
	Return lGrvLote
EndIf

//Controla lote e nЦo empenhou o lote - Retorna FALSE
If Rastro(cProd,"L")
	If Empty(cLote)
		Return lGrvLote
	Else
		//Controla lote e empenhou o lote - Restorna TRUE
		lGrvLote := .T.
		Return lGrvLote
	EndIf
EndIf

//Controla endereГo - Verificar se empenhou o endereГo
//Se empenhou o endereГo - Retornar TRUE
//Se NцO empenhou o endereГo - Retornar FALSE
If Localiza(cProd)
	cQuery := " SELECT COUNT(*) COUNTDC "
	cQuery += "   FROM "+RetSqlName('SDC') + " SDC "
	cQuery += "  WHERE SDC.DC_FILIAL   = '"+xFilial("SDC")+"' "
	cQuery += "    AND SDC.DC_OP       = '"+ cOp +"' "
	cQuery += "    AND SDC.DC_PRODUTO  = '"+ cProd +"' "
	cQuery += "    AND SDC.DC_LOCAL    = '"+ cLocal +"' "
	cQuery += "    AND SDC.DC_TRT      = '"+ cTrt +"' "
	cQuery += "    AND SDC.D_E_L_E_T_  = ' ' "

	dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasDC, .T., .F. )
	If !(cAliasDC)->(Eof())  .And. (cAliasDC)->COUNTDC > 0
		lGrvLote := .T.
	EndIf
	(cAliasDC)->(dbCloseArea())	
EndIf
//

Return lGrvLote

/*/{Protheus.doc} a250ApoAut
	FunГЦo que valida se existe produГЦo automАtica para esse apontamento
	@type Function
	@author michele.girardi
	@since 19/05/2023
	@version version
	@param cNumOP, cNumSeq
	@return lRet,  LСgico
/*/
Static Function a250ApoAut(cNumOP, cNumSeq)

Local cAliasAut := GetNextAlias()
Local cQuery    := ' '
Local lRet      := .F.

dbSelectArea("SC2")	
SC2->(dbSetOrder(1))
SC2->(dbSeek(xFilial("SC2")+cNumOP))

cOP := SC2->C2_NUM
cOP += '%'

cQuery := " SELECT COUNT(*) COUNTD3 "
cQuery += "   FROM "+RetSqlName('SD3') + " SD3 "
cQuery += "  WHERE SD3.D3_FILIAL   = '"+xFilial("SD3")+"' "
cQuery += "    AND SD3.D3_OP       LIKE '"+ cOP +"' "
cQuery += "    AND SD3.D3_NUMSEQ   = '"+ cNumSeq +"' "
cQuery += "    AND SD3.D3_CF       = 'PR1' "
cQuery += "    AND SD3.D3_ESTORNO  = ' ' "
cQuery += "    AND SD3.D_E_L_E_T_  = ' ' "

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasAut, .T., .F. )
If !(cAliasAut)->(Eof())  .And. (cAliasAut)->COUNTD3 > 0
	lRet := .T.
EndIf
(cAliasAut)->(dbCloseArea())	

Return lRet


/*/{Protheus.doc} a250EstPrd
	FunГЦo para validar se pode zerar o saldo do aAsaldo devido a problema de arredondamento
	@type Static Function
	@author michele.girardi
	@since 24/07/2023
	@version version
	@param nQuantBxSD4, aArraySD4, nSaldo, nDecSD4, i,w
	@return lRet,  LСgico
/*/
Static Function a250EstPrd(nQuantBxSD4, aArraySD4, nSaldo, nDecSD4, i,w)

Local lRet   := .T.
Local nAchou := 0
Local nDif   := 0
Local nX     := 0 

	//Somente irА permitir a diferenГa de casas decimais quando qtd de casas decimais = 6
	If nDecSD4 != 6
		lRet := .F.
		Return lRet
	EndIf

	// Somente irА permitir a diferenГa de casas decimais quando existir somente produГЦo automАtica
	If EMPTY(aArraySD4[i,w,6]) 
		lRet := .F.
		Return lRet
	EndIf

	//Somente irА permitir a diferenГa se o produto possuir somente a SD4 com produГЦo automАtica
	//NЦo pode possuir registro de saldo em estoque
	cProd := aArraySD4[i,w,3]	
	nAchou := aScan(aArraySD4[i],{|nX| nX[3] == cProd .And. Empty(nX[6])})

	If nAchou > 0
		lRet := .F.
		Return lRet
	EndIf

	/*
	nDif := nQuantBxSD4 - nSaldo

	If nDif >= 0.00005
		lRet := .F.
		Return lRet
	EndIf
	*/

Return lRet

/*/{Protheus.doc} a250AjQtd
	FunГЦo para validar se deverА incrementar a quantidade na SD4
	@type Static Function
	@author michele.girardi
	@since 29/08/2023
	@version version
	@param i, z, aArraySD4, aArrayAux
	@return nQtBx,  numИrico
/*/
Static Function a250AjQtd(i,z,aArraySD4,aArrayAux)

Local cComp    := aArraySD4[i,z,3] //Componente
Local nI1      := 0
Local nI2      := 0
Local nQtAAux  := 0 
Local nQtAAuxI := 0 
Local nQtBx    := aArraySD4[i,z,7] //Quantidade calculada na SD4 - arredondada
Local nRecno   := aArraySD4[i,z,1] //Recno da SD4

//Verifica se o componente estА no aArrayAux e soma as QTDs
For nI1 := 1 to Len(aArrayAux) 
	For nI2 := 1 to Len(aArrayAux[nI1])
		If aArrayAux[nI1,nI2,2] == cComp
			nQtAAux += aArrayAux[nI1,nI2,7]

			If nRecno == aArrayAux[nI1,nI2,1]
				nQtAAuxI := aArrayAux[nI1,nI2,7]
			EndIf
		EndIf
	Next nI2
Next nI1

// Verifica se a soma И um valor inteiro - Nesse caso nЦo precisa incrementar individualmente.
// Se for um valor inteiro busca o valor quebrado com o RECNO da SD4
If nQtAAux > 0
	If nQtAAux - int(nQtAAux) == 0 
		If nQtAAuxI > 0
			nQtBx := nQtAAuxI
		EndIf
	EndIf
EndIf

Return nQtBx
